<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implementing Indexes - graph-api</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">graph-api</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BrynCooke/graph-api" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="implementing-indexes"><a class="header" href="#implementing-indexes">Implementing Indexes</a></h1>
<p>Indexes are a critical component for efficient graph operations, allowing for quick lookups of elements based on
property values. This chapter guides you through implementing different types of indexes in your graph backend.</p>
<h2 id="index-types-overview"><a class="header" href="#index-types-overview">Index Types Overview</a></h2>
<p>The Graph API supports four main types of indexes:</p>
<ol>
<li><strong>Label Indexes</strong>: Index vertices and edges by their label (enum variant)</li>
<li><strong>Hash Indexes</strong>: Lookup elements by a property value using exact matching</li>
<li><strong>Range Indexes</strong>: Find elements with property values in a specific range</li>
<li><strong>Full-Text Indexes</strong>: Search text properties using more complex matching</li>
</ol>
<h2 id="the-index-infrastructure"><a class="header" href="#the-index-infrastructure">The Index Infrastructure</a></h2>
<h3 id="the-index-trait"><a class="header" href="#the-index-trait">The Index Trait</a></h3>
<p>The Graph API defines the <code>Index</code> trait to represent element indexes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Index
where
    Self: Sized + Copy + Eq + Hash + Debug,
{
    /// The type of the element being indexed
    fn ty(&amp;self) -&gt; TypeId;

    /// The index ordinal
    fn ordinal(&amp;self) -&gt; usize;

    /// The type of index
    fn index_type(&amp;self) -&gt; IndexType;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="index-types"><a class="header" href="#index-types">Index Types</a></h3>
<p>The <code>IndexType</code> enum defines the supported index types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum IndexType {
    Hash,       // Exact matching
    Range,      // Range queries
    FullText,   // Text search
}
<span class="boring">}</span></code></pre></pre>
<h3 id="declare-index-support"><a class="header" href="#declare-index-support">Declare Index Support</a></h3>
<p>To support indexes in your implementation, implement the appropriate support traits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Vertex, Edge&gt; Graph for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Core Graph functionality
    // ...
}

// Implement support traits for the indexing features you want to provide
impl&lt;Vertex, Edge&gt; SupportsVertexLabelIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsEdgeLabelIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsVertexHashIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsEdgeHashIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsVertexRangeIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsEdgeRangeIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsVertexFullTextIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-label-indexes"><a class="header" href="#implementing-label-indexes">Implementing Label Indexes</a></h2>
<p>Label indexes allow for quickly finding all vertices or edges of a specific label (enum variant).</p>
<h3 id="data-structure"><a class="header" href="#data-structure">Data Structure</a></h3>
<p>A simple label index can be implemented using a vector of sets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Stores vertex IDs by label
struct LabelIndex {
    // One entry per label, containing all vertex IDs with that label
    indexes: Vec&lt;HashSet&lt;VertexId&gt;&gt;,
}

impl LabelIndex {
    fn new(label_count: usize) -&gt; Self {
        Self {
            indexes: (0..label_count).map(|_| HashSet::new()).collect(),
        }
    }

    fn insert(&amp;mut self, label: usize, id: VertexId) {
        self.indexes[label].insert(id);
    }

    fn remove(&amp;mut self, label: usize, id: &amp;VertexId) {
        self.indexes[label].remove(id);
    }

    fn get(&amp;self, label: usize) -&gt; impl Iterator&lt;Item=VertexId&gt; + '_ {
        self.indexes[label].iter().copied()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-with-vertexedge-operations"><a class="header" href="#integration-with-vertexedge-operations">Integration with Vertex/Edge Operations</a></h3>
<p>Update label indexes during vertex/edge operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_vertex(&amp;mut self, vertex: Self::Vertex) -&gt; Self::VertexId {
    let label_idx = vertex.label().ordinal();
    let vertex_id = // create a new vertex ID

        // Add to label index
        self.label_index.insert(label_idx, vertex_id);

    // Rest of implementation
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-hash-indexes"><a class="header" href="#implementing-hash-indexes">Implementing Hash Indexes</a></h2>
<p>Hash indexes allow for quick lookups by property value using exact matching.</p>
<h3 id="data-structure-1"><a class="header" href="#data-structure-1">Data Structure</a></h3>
<p>A hash index maps property values to sets of element IDs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HashIndex&lt;K, V&gt; {
    map: HashMap&lt;K, HashSet&lt;V&gt;&gt;,
}

impl&lt;K: Hash + Eq, V: Copy + Eq + Hash&gt; HashIndex&lt;K, V&gt; {
    fn new() -&gt; Self {
        Self {
            map: HashMap::new(),
        }
    }

    fn insert(&amp;mut self, key: K, value: V) {
        self.map.entry(key).or_default().insert(value);
    }

    fn remove(&amp;mut self, key: &amp;K, value: &amp;V) {
        if let Some(values) = self.map.get_mut(key) {
            values.remove(value);
            if values.is_empty() {
                self.map.remove(key);
            }
        }
    }

    fn get(&amp;self, key: &amp;K) -&gt; impl Iterator&lt;Item=V&gt; + '_ {
        self.map
            .get(key)
            .into_iter()
            .flat_map(|values| values.iter().copied())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-with-mutation-handling"><a class="header" href="#integration-with-mutation-handling">Integration with Mutation Handling</a></h3>
<p>When a vertex or edge property changes, you need to update the hash indexes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyMutationListener&lt;'reference, Element&gt; {
    indexes: &amp;'reference mut IndexCollection,
    id: VertexInternalId,
}

impl&lt;'reference, Element&gt; MutationListener&lt;'reference, Element&gt;
for MyMutationListener&lt;'reference, Element&gt;
where
    Element: Element,
{
    fn update(&amp;mut self, index: &lt;Element::Label as Label&gt;::Index, before: Value, after: Value) {
        // Remove the old value from the index
        self.indexes[index.ordinal()].remove(&amp;before, self.id);

        // Add the new value to the index
        self.indexes[index.ordinal()].insert(after, self.id);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-range-indexes"><a class="header" href="#implementing-range-indexes">Implementing Range Indexes</a></h2>
<p>Range indexes allow for finding elements with property values in a specific range.</p>
<h3 id="data-structure-2"><a class="header" href="#data-structure-2">Data Structure</a></h3>
<p>A range index typically uses an ordered map like <code>BTreeMap</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RangeIndex&lt;K, V&gt; {
    map: BTreeMap&lt;K, HashSet&lt;V&gt;&gt;,
}

impl&lt;K: Ord, V: Copy + Eq + Hash&gt; RangeIndex&lt;K, V&gt; {
    fn new() -&gt; Self {
        Self {
            map: BTreeMap::new(),
        }
    }

    fn insert(&amp;mut self, key: K, value: V) {
        self.map.entry(key).or_default().insert(value);
    }

    fn remove(&amp;mut self, key: &amp;K, value: &amp;V) {
        if let Some(values) = self.map.get_mut(key) {
            values.remove(value);
            if values.is_empty() {
                self.map.remove(key);
            }
        }
    }

    fn get(&amp;self, key: &amp;K) -&gt; impl Iterator&lt;Item=V&gt; + '_ {
        self.map
            .get(key)
            .into_iter()
            .flat_map(|values| values.iter().copied())
    }

    fn range&lt;'a, R&gt;(&amp;'a self, range: R) -&gt; impl Iterator&lt;Item=V&gt; + 'a
    where
        R: RangeBounds&lt;K&gt; + 'a,
        K: 'a,
    {
        self.map
            .range(range)
            .flat_map(|(_, values)| values.iter().copied())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handling-range-queries"><a class="header" href="#handling-range-queries">Handling Range Queries</a></h3>
<p>Implement range query support in your vertex and edge iterators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn vertices&lt;'search&gt;(
    &amp;self,
    search: &amp;VertexSearch&lt;'search, Self&gt;,
) -&gt; Self::VertexIter&lt;'search, '_&gt; {
    // ...other search handling

    if let VertexSearch::Range { index, range, .. } = search {
        let index_storage = &amp;self.indexes[index.ordinal()];
        return VertexIter {
            iter: index_storage.range(range.clone(), index),
            // ...other fields
        };
    }

    // ...default handling
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-full-text-indexes"><a class="header" href="#implementing-full-text-indexes">Implementing Full-Text Indexes</a></h2>
<p>Full-text indexes enable searching through text properties with capabilities like prefix matching, fuzzy matching, or
tokenized searches.</p>
<h3 id="data-structure-3"><a class="header" href="#data-structure-3">Data Structure</a></h3>
<p>A simple full-text index implementation might use an inverted index:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FullTextIndex&lt;V&gt; {
    // Maps tokens to element IDs
    tokens: HashMap&lt;String, HashSet&lt;V&gt;&gt;,
    // Maps element IDs to their full text
    contents: HashMap&lt;V, String&gt;,
}

impl&lt;V: Copy + Eq + Hash&gt; FullTextIndex&lt;V&gt; {
    fn new() -&gt; Self {
        Self {
            tokens: HashMap::new(),
            contents: HashMap::new(),
        }
    }

    fn insert(&amp;mut self, id: V, text: &amp;str) {
        // Remove old content if it exists
        self.remove(&amp;id);

        // Store the full text
        self.contents.insert(id, text.to_string());

        // Tokenize the text and add to inverted index
        for token in tokenize(text) {
            self.tokens.entry(token).or_default().insert(id);
        }
    }

    fn remove(&amp;mut self, id: &amp;V) {
        if let Some(text) = self.contents.remove(id) {
            // Remove from token index
            for token in tokenize(&amp;text) {
                if let Some(ids) = self.tokens.get_mut(&amp;token) {
                    ids.remove(id);
                    if ids.is_empty() {
                        self.tokens.remove(&amp;token);
                    }
                }
            }
        }
    }

    fn search(&amp;self, query: &amp;str) -&gt; impl Iterator&lt;Item=V&gt; + '_ {
        // Tokenize the query
        let query_tokens: Vec&lt;_&gt; = tokenize(query).collect();

        // Find matches
        query_tokens
            .into_iter()
            .filter_map(move |token| self.tokens.get(&amp;token))
            .flatten()
            .copied()
            .collect::&lt;HashSet&lt;_&gt;&gt;() // Deduplicate
            .into_iter()
    }
}

// Helper function to tokenize text
fn tokenize(text: &amp;str) -&gt; impl Iterator&lt;Item=String&gt; + '_ {
    text.to_lowercase()
        .split_whitespace()
        .map(|s| s.to_string())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-full-text-features"><a class="header" href="#advanced-full-text-features">Advanced Full-Text Features</a></h3>
<p>For more advanced full-text search capabilities, consider:</p>
<ol>
<li><strong>Stemming</strong>: Reducing words to their root form (e.g., "running" → "run")</li>
<li><strong>N-grams</strong>: Creating token sequences for partial matching</li>
<li><strong>Fuzzy Matching</strong>: Supporting approximate matching with edit distance</li>
<li><strong>Relevance Scoring</strong>: Ranking results by relevance to the query</li>
</ol>
<h2 id="efficient-index-updates"><a class="header" href="#efficient-index-updates">Efficient Index Updates</a></h2>
<p>For efficient index updates, consider these strategies:</p>
<h3 id="lazy-updates"><a class="header" href="#lazy-updates">Lazy Updates</a></h3>
<p>Only update indexes when needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_vertex(&amp;mut self, id: Self::VertexId) -&gt; Option&lt;Self::Vertex&gt; {
    // Fetch the vertex
    let vertex = self.vertices.get(id.index())?;

    // Only update indexes if the vertex exists
    for index in vertex.label().indexes() {
        self.indexes[index.ordinal()].remove(&amp;self.get_value(vertex, index), id.index());
    }

    // Remove the vertex
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batched-updates"><a class="header" href="#batched-updates">Batched Updates</a></h3>
<p>For bulk operations, batch index updates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_vertices_batch(&amp;mut self, vertices: Vec&lt;Self::Vertex&gt;) -&gt; Vec&lt;Self::VertexId&gt; {
    let mut ids = Vec::with_capacity(vertices.len());
    let mut index_updates = Vec::new();

    // First pass: add vertices and collect index updates
    for vertex in vertices {
        let id = self.add_vertex_no_index(vertex);
        ids.push(id);

        // Collect index updates
        for index in vertex.label().indexes() {
            index_updates.push((index, self.get_value(&amp;vertex, index), id));
        }
    }

    // Second pass: apply all index updates
    for (index, value, id) in index_updates {
        self.indexes[index.ordinal()].insert(value, id);
    }

    ids
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<p>When implementing indexes, watch out for these common issues:</p>
<ol>
<li><strong>Index Inconsistency</strong>: Ensure indexes are always updated when elements change</li>
<li><strong>Memory Overhead</strong>: Indexes increase memory usage; consider selective indexing</li>
<li><strong>Type Safety</strong>: Ensure index type safety, especially with range and full-text indexes</li>
<li><strong>Empty Sets</strong>: Handle empty index entries to avoid wasted memory</li>
<li><strong>Concurrency</strong>: If supporting concurrent access, protect indexes with appropriate synchronization</li>
</ol>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>For optimal index performance:</p>
<ol>
<li><strong>Index Selection</strong>: Only index properties that will be frequently queried</li>
<li><strong>Data Structure Choice</strong>: Choose appropriate data structures based on workload</li>
<li><strong>Memory vs. Speed</strong>: Balance memory usage with lookup speed</li>
<li><strong>Measure</strong>: Benchmark index operations to identify bottlenecks</li>
</ol>
<h2 id="testing-indexes"><a class="header" href="#testing-indexes">Testing Indexes</a></h2>
<p>Test your index implementation thoroughly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_hash_index() {
    let mut graph = MyGraph::new();

    // Add vertices with indexed properties
    let v1 = graph.add_vertex(Vertex::Person {
        name: "Alice".to_string(),
        age: 30,
        // ...other fields
    });

    let v2 = graph.add_vertex(Vertex::Person {
        name: "Bob".to_string(),
        age: 25,
        // ...other fields
    });

    // Test index lookup
    let results = graph.walk()
        .vertices(Vertex::person_by_name("Alice"))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    assert_eq!(results.len(), 1);
    assert_eq!(results[0].id(), v1);

    // Test index update after mutation
    graph.vertex_mut(v1).unwrap()
        .project_mut::&lt;PersonMut&lt;_&gt;&gt;().unwrap()
        .set_name("Alicia");

    let results = graph.walk()
        .vertices(Vertex::person_by_name("Alicia"))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    assert_eq!(results.len(), 1);
    assert_eq!(results[0].id(), v1);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Implementing efficient indexes is key to building a high-performance graph backend. By carefully designing index
structures and ensuring proper updates during mutations, you can provide fast lookup capabilities while maintaining
reasonable memory usage. Remember that different use cases may require different indexing strategies, so consider the
expected query patterns when deciding which indexes to implement and how to optimize them.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../implementation/features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../implementation/benchmarks.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../implementation/features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../implementation/benchmarks.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
