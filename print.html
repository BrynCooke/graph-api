<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>graph-api</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">graph-api</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BrynCooke/graph-api" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img src="./mascot.png" width="400" height="200" style="display: block; padding: 1em; margin: 0 auto" alt="GraphApi mascot">
<h1 id="introduction-to-graph-api"><a class="header" href="#introduction-to-graph-api">Introduction to Graph API</a></h1>
<p>Graph API is an ergonomic library for working with <strong>in memory</strong> graphs in Rust that provides a flexible and type-safe
way to interact with graph data structures.</p>
<p>Heavily inspired by <a href="https://tinkerpop.apache.org/">Apache TinkerPop</a>, it
offers an <strong>iterator-like</strong> interface specifically designed for graph traversal and manipulation.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This library offers a unified interface for working with different types of graphs while maintaining strong type safety
and ergonomic usage patterns. It includes features for graph traversal, modification, and custom extensions.</p>
<h2 id="advantages"><a class="header" href="#advantages">Advantages</a></h2>
<ul>
<li><strong>Iterator-like interface for graphs</strong>: Intuitive API that feels familiar to Rust developers</li>
<li><strong>Works with multiple backends</strong>:
<ul>
<li><strong><a href="reference/implementations/simple_graph.html">simple graph</a></strong> - A simple adjacency list based graph with index
support</li>
<li><strong><a href="reference/implementations/petgraph.html">petgraph</a></strong> - An excellent established graph library</li>
<li>You can also create your own!</li>
</ul>
</li>
<li><strong>Composable operations</strong>: Chain graph operations together in a fluent, declarative style</li>
<li><strong>Separation of graph model and implementation</strong>: Define your domain model once and use it with any supported backend</li>
</ul>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Type-safe graph operations</strong>: Work with graph data in a strongly-typed manner</li>
<li><strong>Flexible vertex and edge traversal</strong>: Explore graph relationships with powerful walker API</li>
<li><strong>Custom graph implementations support</strong>: Adapt to various graph storage backends</li>
<li><strong>Derive macros for extending graph functionality</strong>: Automatically generate boilerplate code</li>
<li><strong>Comprehensive testing utilities</strong>: Including fuzzing support</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-rust noplayground">    // Find a person using the username index (exact match)
    let bryn = graph
        .walk()
        .vertices(Vertex::person_by_username("bryn123"))
        .first()
        .expect("Bryn should exist in the graph");

    println!("Found person: {:?}", bryn);

    // Find projects created by a person
    let projects_created_by_bryn = graph
        .walk()
        .vertices_by_id(vec![bryn])
        .edges(Edge::created().outgoing())
        .head()
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Bryn created {} projects", projects_created_by_bryn.len());

    // Find all people followed by Bryn
    let followed_by_bryn = graph
        .walk()
        .vertices_by_id(vec![bryn])
        .edges(Edge::follows().outgoing())
        .head()
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Bryn follows {} people", followed_by_bryn.len());

    // Find all people with "graph" in their biography
    let graph_enthusiasts = graph
        .walk()
        .vertices(Vertex::person_by_biography("graph"))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} graph enthusiasts", graph_enthusiasts.len());

    // Find people in a specific age range
    let people_in_30s = graph
        .walk()
        .vertices(Vertex::person_by_age_range(30..40))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} people in their 30s", people_in_30s.len());</code></pre>
<h2 id="book-organization"><a class="header" href="#book-organization">Book Organization</a></h2>
<p>This book is organized into several sections:</p>
<ul>
<li><strong>User Guide</strong>: How to use the Graph API to work with graph data</li>
<li><strong>Implementation Guide</strong>: How to implement the Graph API traits for your own graph types</li>
<li><strong>Reference</strong>: Detailed information about API components and functionality</li>
<li><strong>Appendix</strong>: Additional resources and reference materials</li>
</ul>
<p>Whether you're a graph API user or implementing your own graph backend, this book provides comprehensive documentation
to help you make the most of the Graph API library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p><code>graph-api</code> is an API that helps you work with graphs in Rust. Graphs are powerful data structures used to represent
relationships between entities. With the Graph API, you can create, manipulate, and traverse graphs with ease.</p>
<p>Any implementation of the Graph trait will benefit from an ergonomic walker API that allows you to perform complex
traversals. For the purposes of this documentation, we will use <code>SimpleGraph</code>, but you may choose any other graph
implementation.</p>
<h2 id="basic-concepts"><a class="header" href="#basic-concepts">Basic Concepts</a></h2>
<p>A graph consists of:</p>
<ul>
<li><strong>Vertices</strong> (also called nodes): These represent entities in your data model</li>
<li><strong>Edges</strong> (also called links or connections): These represent relationships between entities</li>
<li><strong>Properties</strong>: Both vertices and edges can have properties that store data</li>
</ul>
<p>The Graph API provides:</p>
<ul>
<li>A common interface for working with graph data</li>
<li>Powerful traversal capabilities with the Walker API</li>
<li>Index support for efficient lookups</li>
<li>Derive macros for easy model definition</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add the Graph API to your project dependencies:</p>
<pre><code class="language-toml">[dependencies]
graph-api-lib = "0.1.4"
graph-api-derive = "0.1.2"  # For derive macros
</code></pre>
<p>For a simple graph implementation:</p>
<pre><code class="language-toml">[dependencies]
graph-api-simplegraph = "0.1.4"
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="your-first-graph"><a class="header" href="#your-first-graph">Your First Graph</a></h3>
<p>Let's define a simple graph model with people and projects:</p>
<pre><code class="language-rust noplayground">// Define our vertex types using derive macro
#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    // A person vertex with name and age properties
    Person {
        name: String,
        #[index(hash)]
        username: String,
        age: u8,
    },
    // A project vertex with just a name
    Project {
        name: String,
    },
}

// Define our edge types using derive macro
#[derive(Debug, Clone, EdgeExt)]
enum Edge {
    // Simple relationship types
    Knows,
    Created,
    WorksOn,
}</code></pre>
<p>Now we can create a graph and add some data:</p>
<pre><code class="language-rust noplayground">        // Create a new empty graph
        let mut graph = SimpleGraph::&lt;Vertex, Edge&gt;::new();

        // Add vertices
        let alice = graph.add_vertex(Vertex::Person {
            name: "Alice".to_string(),
            username: "alice123".to_string(),
            age: 30,
        });

        let bob = graph.add_vertex(Vertex::Person {
            name: "Bob".to_string(),
            username: "bob456".to_string(),
            age: 28,
        });

        let project = graph.add_vertex(Vertex::Project {
            name: "Graph API".to_string(),
        });

        // Connect vertices with edges
        graph.add_edge(alice, bob, Edge::Knows);
        graph.add_edge(alice, project, Edge::Created);
        graph.add_edge(bob, project, Edge::WorksOn);</code></pre>
<p>And finally, we can query the graph:</p>
<pre><code class="language-rust noplayground">        // Find all people who created a project
        let creators = graph
            .walk()
            .vertices(VertexSearch::scan())
            .filter_person() // Type-safe filter using generated helper
            .edges(Edge::created()) // Using generated search function
            .head()
            .filter_project() // Type-safe filter using generated helper
            .map(|v, _| {
                // Use projection for type-safe property access
                v.project::&lt;Project&lt;_&gt;&gt;().unwrap().name().to_string()
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();

        // Find all people who know someone
        let people_with_friends = graph
            .walk()
            .vertices(VertexSearch::scan())
            .filter_person() // Type-safe filter using generated helper
            .edges(Edge::knows()) // Using generated search function
            .tail()
            .filter_person() // Type-safe filter using generated helper
            .map(|v, _| {
                // Use projection for type-safe property access
                v.project::&lt;Person&lt;_&gt;&gt;().unwrap().name().to_string()
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<p>Graph API supports more advanced features that we'll explore in later sections:</p>
<ul>
<li>Complex traversals with the Walker API</li>
<li>Different index types for optimized queries</li>
<li>Transaction support (with appropriate graph implementations)</li>
<li>Custom property types</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you have created your first graph, you can:</p>
<ol>
<li>Learn about <a href="user_guide/./defining_a_model.html">defining a model</a> for your graph data</li>
<li>Explore <a href="user_guide/./basic_operations.html">basic operations</a> for working with graphs</li>
<li>Discover <a href="user_guide/./traversal.html">graph traversal</a> techniques using walkers</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-model"><a class="header" href="#defining-a-model">Defining a Model</a></h1>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Graph API provides a flexible way to define your graph data model using Rust's enum types and derive macros. This
approach gives you the benefits of Rust's type system while maintaining the flexibility of property graphs.</p>
<h2 id="basic-concepts-1"><a class="header" href="#basic-concepts-1">Basic Concepts</a></h2>
<p>A graph consists of two primary elements:</p>
<ol>
<li><strong>Vertices</strong> (nodes): The entities in your graph</li>
<li><strong>Edges</strong>: The relationships connecting vertices</li>
</ol>
<p>For each of these, you'll define a Rust enum that represents all possible types.</p>
<h2 id="model-definition"><a class="header" href="#model-definition">Model Definition</a></h2>
<object type="image/svg+xml" data="defining_a_model/image.svg">
Diagram showing graph elements (Person, Project vertices) and relationships (Follows, Created edges)
</object>
<p>The equivalent definition using Graph API is:</p>
<pre><code class="language-rust noplayground">// Define vertex types for a social media application
#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    // Person vertex with various properties
    Person {
        name: String, // Not indexed

        #[index(hash)] // Hash index for exact lookups
        username: String,

        #[index(full_text)] // Full-text index for text search
        biography: String,

        #[index(range)] // Range index for range queries
        age: u8,
    },

    // Project vertex with minimal properties
    Project {
        name: String,
    },

    // Comment vertex
    Comment {
        text: String,
        date: String,
    },
}

// Define edge types that connect vertices
#[derive(Debug, Clone, EdgeExt)]
pub enum Edge {
    // Simple edges without properties
    Created,
    Follows,

    // Edges with properties
    Liked { timestamp: String },
    Commented { timestamp: String },
}</code></pre>
<p>This model defines vertex types for people, projects, and comments, along with edge types for the relationships between
them.</p>
<h2 id="creating-instances"><a class="header" href="#creating-instances">Creating Instances</a></h2>
<p>Once you've defined your model, you can create instances of vertices and edges:</p>
<object type="image/svg+xml" data="defining_a_model/graph_instance.svg">
Diagram showing the specific graph instance created by the code
</object>
<pre><code class="language-rust noplayground">    let mut graph = SimpleGraph::new();

    // Create vertices
    let bryn = graph.add_vertex(Vertex::Person {
        name: "Bryn".to_string(),
        username: "bryn123".to_string(),
        biography: "Graph enthusiast".to_string(),
        age: 28,
    });

    let julia = graph.add_vertex(Vertex::Person {
        name: "Julia".to_string(),
        username: "julia456".to_string(),
        biography: "Software developer".to_string(),
        age: 34,
    });

    let eve = graph.add_vertex(Vertex::Person {
        name: "Eve".to_string(),
        username: "eve789".to_string(),
        biography: "Network specialist".to_string(),
        age: 31,
    });

    let graph_api = graph.add_vertex(Vertex::Project {
        name: "GraphApi".to_string(),
    });

    let alpaca = graph.add_vertex(Vertex::Project {
        name: "Alpaca".to_string(),
    });

    // Create edges
    graph.add_edge(bryn, graph_api, Edge::Created);
    graph.add_edge(julia, alpaca, Edge::Created);
    graph.add_edge(julia, bryn, Edge::Follows);
    graph.add_edge(eve, julia, Edge::Follows);
    graph.add_edge(bryn, eve, Edge::Follows);
    graph.add_edge(
        bryn,
        alpaca,
        Edge::Liked {
            timestamp: "2023-01-01".to_string(),
        },
    );
    graph.add_edge(
        bryn,
        alpaca,
        Edge::Commented {
            timestamp: "2023-01-02".to_string(),
        },
    );</code></pre>
<h2 id="using-derive-macros"><a class="header" href="#using-derive-macros">Using Derive Macros</a></h2>
<p>The <code>VertexExt</code> and <code>EdgeExt</code> derive macros generate implementations for your model types that enable them to work with
Graph API's traversal and query features.</p>
<h3 id="vertexext"><a class="header" href="#vertexext">VertexExt</a></h3>
<p>This macro provides:</p>
<ul>
<li>Integration with the indexing system</li>
<li>Projection types</li>
<li>Type-safe accessors for properties</li>
<li>Type-safe filters for traversals</li>
</ul>
<h3 id="edgeext"><a class="header" href="#edgeext">EdgeExt</a></h3>
<p>This macro provides:</p>
<ul>
<li>Integration with label-based indexing</li>
<li>Projection types</li>
<li>Type-safe accessors for properties</li>
<li>Type-safe filters for traversals</li>
</ul>
<h2 id="indexing"><a class="header" href="#indexing">Indexing</a></h2>
<p>You can define indexes for efficient lookups using attributes:</p>
<ul>
<li><code>#[index(hash)]</code>: Creates a hash index for exact match lookups</li>
<li><code>#[index(range)]</code>: Creates a range index for range queries</li>
<li><code>#[index(full_text)]</code>: Creates a full-text index for text search</li>
</ul>
<p>For more details on indexes and examples, see the <a href="user_guide/./property_graphs.html">Property Graphs</a> section.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>When defining your graph model:</p>
<ol>
<li><strong>Use descriptive names</strong> - Choose clear names for vertex and edge types</li>
<li><strong>Index strategically</strong> - Only index fields used in frequent queries</li>
<li><strong>Use appropriate index types</strong> - Match index types to query patterns</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-graphs"><a class="header" href="#property-graphs">Property Graphs</a></h1>
<p>A property graph is a powerful data model that allows you to represent complex, interconnected data in a highly
intuitive way. Graph API leverages Rust's type system to provide a strongly-typed property graph experience.</p>
<h2 id="what-are-property-graphs"><a class="header" href="#what-are-property-graphs">What are Property Graphs?</a></h2>
<p>Property graphs consist of two primary elements:</p>
<ol>
<li>
<p><strong>Vertices</strong> (nodes): Represent entities in your data model. Each vertex has a type (label) and can hold multiple
key-value properties.</p>
<object type="image/svg+xml" data="property_graphs/vertex_with_properties.svg">
Diagram showing a single vertex with properties
</object>
</li>
<li>
<p><strong>Edges</strong> (relationships): Connect vertices to express relationships. Edges are directed, have a type (label), and
can also hold properties.</p>
<object type="image/svg+xml" data="property_graphs/edge_with_properties.svg">
Diagram showing two vertices connected by an edge with properties
</object>
</li>
</ol>
<p>Both vertices and edges can have properties (attributes) that store additional information. In Graph API, these
properties are represented using Rust's enum types, giving you full type safety.</p>
<h2 id="why-use-property-graphs"><a class="header" href="#why-use-property-graphs">Why Use Property Graphs?</a></h2>
<p>Property graphs excel at representing highly connected data where relationships are as important as the entities
themselves. They're particularly useful for:</p>
<ul>
<li>Social networks (people, friendships, interests)</li>
<li>Knowledge graphs (concepts, relationships)</li>
<li>Recommendation systems (users, products, preferences)</li>
<li>Network topologies (devices, connections)</li>
<li>Dependency graphs (components, dependencies)</li>
</ul>
<p>The key advantages of property graphs include:</p>
<ul>
<li><strong>Intuitive modeling</strong>: Reflects how we naturally think about connected data</li>
<li><strong>Relationship-centric</strong>: Makes connections first-class citizens</li>
<li><strong>Flexible schema</strong>: Easily adapt to changing data models</li>
<li><strong>Performance</strong>: Efficient for traversal and relationship-based queries</li>
</ul>
<h2 id="graph-apis-approach-to-property-graphs"><a class="header" href="#graph-apis-approach-to-property-graphs">Graph API's Approach to Property Graphs</a></h2>
<p>Graph API uses Rust's strong type system to create a safe, ergonomic property graph experience:</p>
<ul>
<li><strong>Enum-based modeling</strong>: Define vertices and edges using Rust enums</li>
<li><strong>Derive macros</strong>: Generate boilerplate code for traversal and querying</li>
<li><strong>Type-safe queries</strong>: Leverage Rust's type checking for query correctness</li>
<li><strong>Efficient indexing</strong>: First-class support for various index types</li>
</ul>
<h2 id="property-graph-example"><a class="header" href="#property-graph-example">Property Graph Example</a></h2>
<p>Here's a simple example of how Graph API models a property graph:</p>
<pre><code class="language-rust noplayground">// Define vertex types for a social media application
#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    // Person vertex with various properties
    Person {
        name: String, // Not indexed

        #[index(hash)] // Hash index for exact lookups
        username: String,

        #[index(full_text)] // Full-text index for text search
        biography: String,

        #[index(range)] // Range index for range queries
        age: u8,
    },

    // Project vertex with minimal properties
    Project {
        name: String,
    },

    // Comment vertex
    Comment {
        text: String,
        date: String,
    },
}

// Define edge types that connect vertices
#[derive(Debug, Clone, EdgeExt)]
pub enum Edge {
    // Simple edges without properties
    Created,
    Follows,

    // Edges with properties
    Liked { timestamp: String },
    Commented { timestamp: String },
}</code></pre>
<h2 id="understanding-indexes"><a class="header" href="#understanding-indexes">Understanding Indexes</a></h2>
<p>Indexes are a crucial part of an efficient graph database. They allow you to quickly locate vertices and edges without
scanning the entire graph.</p>
<p>In Graph API, indexes are defined as part of your model using derive macros. The following sections explore different
types of indexes and how to use them effectively:</p>
<ul>
<li><a href="user_guide/./property_graphs/no_index.html">Exploring Without Indexes</a>: Understand the challenges of graph traversal without
indexes</li>
<li><a href="user_guide/./property_graphs/hash_index.html">Hash Indexes</a>: Fast lookups by exact property value</li>
<li><a href="user_guide/./property_graphs/range_index.html">Range Indexes</a>: Range queries for numeric and range properties</li>
<li><a href="user_guide/./property_graphs/full_text_index.html">Full-text Indexes</a>: Text search capabilities for string properties</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploring-without-indexes"><a class="header" href="#exploring-without-indexes">Exploring Without Indexes</a></h1>
<p>Before we dive into indexes, let's understand why they're necessary by exploring graph traversal without them.</p>
<h2 id="the-challenge-of-finding-starting-points"><a class="header" href="#the-challenge-of-finding-starting-points">The Challenge of Finding Starting Points</a></h2>
<p>In a property graph, one of the biggest challenges is finding the right starting points for your traversal. Without
indexes, your only option is to scan the entire graph, examining each vertex to find matches.</p>
<p><object type="image/svg+xml" data="./no_index/image.svg" title="Diagram a full scan of graph vertice"></object></p>
<p>In this diagram:</p>
<ul>
<li>The <strong>graph</strong> contains several vertices (A-E), some of which have the property <code>name: "Alice"</code>.</li>
<li>The <strong>query</strong> at the top left indicates the desired starting condition: find vertices where <code>name = "Alice"</code>.</li>
<li>The <strong>blue arrows</strong> illustrate the process <em>without an index</em>: To satisfy the query, the traversal mechanism must
conceptually examine <strong>every single vertex</strong> (A, B, C, D, E) to check if its <code>name</code> property matches "Alice". This
represents a full graph scan.</li>
<li>The <strong>orange highlighting</strong> on vertices <code>A</code> and <code>C</code> shows the <em>result</em> of this scan â€“ these are the only vertices
found that satisfy the query condition.</li>
</ul>
<p>This full scan becomes computationally expensive and slow, especially in large graphs, highlighting the need for indexes
to quickly locate starting vertices.</p>
<h2 id="example-graph-without-indexes"><a class="header" href="#example-graph-without-indexes">Example: Graph Without Indexes</a></h2>
<p>Let's consider a simple social network model without any indexes:</p>
<pre><code class="language-rust noplayground">// Define vertex types for a social media application
#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    // Person vertex with various properties
    Person {
        name: String, // Not indexed

        #[index(hash)] // Hash index for exact lookups
        username: String,

        #[index(full_text)] // Full-text index for text search
        biography: String,

        #[index(range)] // Range index for range queries
        age: u8,
    },

    // Project vertex with minimal properties
    Project {
        name: String,
    },

    // Comment vertex
    Comment {
        text: String,
        date: String,
    },
}

// Define edge types that connect vertices
#[derive(Debug, Clone, EdgeExt)]
pub enum Edge {
    // Simple edges without properties
    Created,
    Follows,

    // Edges with properties
    Liked { timestamp: String },
    Commented { timestamp: String },
}</code></pre>
<h2 id="scanning-the-entire-graph"><a class="header" href="#scanning-the-entire-graph">Scanning the Entire Graph</a></h2>
<p>Without indexes, the only way to find vertices matching specific criteria is to scan the entire graph.</p>
<h3 id="finding-by-name-without-index"><a class="header" href="#finding-by-name-without-index">Finding by Name (Without Index)</a></h3>
<p>When a field isn't indexed (like <code>name</code> in the <code>Person</code> vertex), we have to scan all vertices to find matches:</p>
<pre><code class="language-rust noplayground">    // INEFFICIENT: Find all people named "Bryn" by scanning
    // Since name is not indexed, we must scan all vertices
    let bryn_vertices = graph
        .walk()
        .vertices(VertexSearch::scan()) // Must scan ALL vertices
        .filter_by_person(|person, _| person.name() == "Bryn")
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} vertices for Bryn", bryn_vertices.len());</code></pre>
<h3 id="finding-projects-without-index"><a class="header" href="#finding-projects-without-index">Finding Projects (Without Index)</a></h3>
<p>Similarly, to find a project by name, we need to scan the entire graph:</p>
<pre><code class="language-rust noplayground">    // INEFFICIENT: Find all projects with a specific name by scanning
    // Since Project::name is not indexed, we must scan all vertices
    let graphapi_projects = graph
        .walk()
        .vertices(VertexSearch::scan()) // Must scan ALL vertices
        .filter_by_project(|project, _| project.name() == "GraphApi")
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} GraphApi projects", graphapi_projects.len());</code></pre>
<h3 id="performance-comparison"><a class="header" href="#performance-comparison">Performance Comparison</a></h3>
<p>Let's compare the performance of a full scan versus using an index:</p>
<ol>
<li><strong>Inefficient approach</strong> - scanning all vertices:</li>
</ol>
<pre><code class="language-rust noplayground">    // COMPARISON: Using an index vs. not using an index
    // 1. Inefficient: Find people with a specific username using a scan
    let julia_by_scan = graph
        .walk()
        .vertices(VertexSearch::scan())
        .filter_by_person(|person, _| person.username() == "julia456")
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} with username julia456", julia_by_scan.len());</code></pre>
<ol start="2">
<li><strong>Efficient approach</strong> - using the index:</li>
</ol>
<pre><code class="language-rust noplayground">    // 2. Efficient: Find the same person using the username index
    let julia_by_index = graph
        .walk()
        .vertices(Vertex::person_by_username("julia456"))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} with username julia456", julia_by_index.len());</code></pre>
<h2 id="performance-implications"><a class="header" href="#performance-implications">Performance Implications</a></h2>
<p>For small graphs, scanning might be acceptable, but as graphs grow, scanning becomes increasingly inefficient:</p>
<ol>
<li><strong>Linear Time Complexity</strong>: Scanning requires examining every vertex, making it O(n) where n is the number of
vertices</li>
<li><strong>Resource Intensive</strong>: Needs to load and process every vertex, even those not matching criteria</li>
<li><strong>Poor Scalability</strong>: Performance degrades linearly as the graph grows</li>
</ol>
<h2 id="when-to-use-full-scans"><a class="header" href="#when-to-use-full-scans">When to Use Full Scans</a></h2>
<p>Despite their inefficiency, full scans do have legitimate uses:</p>
<ul>
<li><strong>During initial development</strong>: When you're still figuring out your data model</li>
<li><strong>For admin or maintenance tasks</strong>: When completeness is more important than speed</li>
<li><strong>For small graphs</strong>: When the overhead of maintaining indexes exceeds their benefit</li>
<li><strong>For exploratory analysis</strong>: When you need to examine all data without preconceptions</li>
</ul>
<h2 id="moving-beyond-scans"><a class="header" href="#moving-beyond-scans">Moving Beyond Scans</a></h2>
<p>In the following sections, we'll explore how different types of indexes can dramatically improve traversal performance
by allowing you to:</p>
<ol>
<li><strong>Find vertices by exact property values</strong> using standard indexes</li>
<li><strong>Search for vertices within ranges</strong> using range indexes</li>
<li><strong>Find vertices containing specific text</strong> using full-text indexes</li>
</ol>
<p>Indexes provide the entry points for efficient graph traversal, turning potentially expensive operations into
near-constant time lookups.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-indexes"><a class="header" href="#hash-indexes">Hash Indexes</a></h1>
<p>Hash indexes are the most common type of index in a property graph. They enable fast lookups for exact matches on
property values, dramatically improving query performance.</p>
<h2 id="what-are-hash-indexes"><a class="header" href="#what-are-hash-indexes">What are Hash Indexes?</a></h2>
<p>A hash index maps property values to vertices, allowing you to quickly find all vertices with a specific property
value without scanning the entire graph. It uses a hash table data structure for O(1) lookups.</p>
<p><object type="image/svg+xml" data="./hash_index/image.svg" title="Diagram showing a hash index mapping names to graph vertice"></object></p>
<p>In this diagram:</p>
<ul>
<li>The <strong>graph</strong> on the right contains vertices (A, B, C, D) with properties.</li>
<li>The <strong>index</strong> on the left is specifically for the <code>name</code> property.</li>
<li>The <strong>dashed arrows</strong> show the mapping:
<ul>
<li>Looking up <code>"Alice"</code> in the index quickly leads to vertices <code>A</code> and <code>C</code>.</li>
<li>Looking up <code>"Bob"</code> leads to vertex <code>B</code>.</li>
</ul>
</li>
</ul>
<p>This allows a query like "find all vertices where name is 'Alice'" to directly access nodes A and C via the index,
instead of checking every vertex in the graph.</p>
<h2 id="defining-hash-indexes"><a class="header" href="#defining-hash-indexes">Defining Hash Indexes</a></h2>
<p>In Graph API, you define a hash index by adding the <code>#[index(hash)]</code> attribute to a field in your vertex enum:</p>
<pre><code class="language-rust noplayground">#[derive(Debug, VertexExt)]
pub enum IndexedVertex {
    // Person vertex with various properties
    Person {
        name: String, // Not indexed

        #[index(hash)] // Hash index for exact lookups
        username: String,
    },
}</code></pre>
<h2 id="how-hash-indexes-work"><a class="header" href="#how-hash-indexes-work">How Hash Indexes Work</a></h2>
<p>When you apply the <code>#[index(hash)]</code> attribute to a field:</p>
<ol>
<li>The derive macro generates a hash index entry for that field</li>
<li>The graph implementation maintains a hash map from property values to vertices</li>
<li>When you query using the index, the graph can directly look up matching vertices in constant time</li>
</ol>
<h2 id="querying-with-hash-indexes"><a class="header" href="#querying-with-hash-indexes">Querying with Hash Indexes</a></h2>
<p>The real power of hash indexes becomes apparent when querying the graph:</p>
<pre><code class="language-rust noplayground">    // Find a person by their username (using hash index)
    let julia = graph
        .walk()
        .vertices(Vertex::person_by_username("julia456"))
        .first();

    println!("Found Julia: {}", julia.is_some());</code></pre>
<h2 id="performance-benefits"><a class="header" href="#performance-benefits">Performance Benefits</a></h2>
<p>Hash indexes offer significant performance advantages:</p>
<ol>
<li><strong>Constant time lookups</strong>: O(1) rather than O(n) for full scans</li>
<li><strong>Reduced memory pressure</strong>: Only relevant vertices are loaded</li>
<li><strong>Improved scalability</strong>: Performance remains consistent as the graph grows</li>
</ol>
<h2 id="when-to-use-hash-indexes"><a class="header" href="#when-to-use-hash-indexes">When to Use Hash Indexes</a></h2>
<p>Hash indexes are ideal for:</p>
<ul>
<li><strong>Unique identifiers</strong>: User IDs, product codes, etc.</li>
<li><strong>Common lookup fields</strong>: Names, titles, categories</li>
<li><strong>Fields used in equality predicates</strong>: Where you need exact matches</li>
</ul>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<p>When using hash indexes:</p>
<ol>
<li><strong>Be selective</strong>: Only index fields you frequently query</li>
<li><strong>Choose appropriate fields</strong>: Index fields with high selectivity</li>
<li><strong>Consider cardinality</strong>: Fields with many unique values benefit most from indexing</li>
<li><strong>Balance maintenance cost</strong>: Each index adds storage and update overhead</li>
</ol>
<h2 id="index-limitations"><a class="header" href="#index-limitations">Index Limitations</a></h2>
<p>Hash indexes have some limitations:</p>
<ol>
<li><strong>Exact matches only</strong>: Cannot handle range or partial text queries</li>
<li><strong>Memory overhead</strong>: Each index increases memory usage</li>
<li><strong>Update cost</strong>: Indexes must be maintained when data changes</li>
</ol>
<p>For range queries or partial text matching, consider <a href="user_guide/property_graphs/./range_index.html">range indexes</a>
or <a href="user_guide/property_graphs/./full_text_index.html">full-text indexes</a> respectively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range-indexes"><a class="header" href="#range-indexes">Range Indexes</a></h1>
<p>Range indexes enable efficient querying for values within a specific range, such as finding people of a certain age
range or products within a price bracket.</p>
<h2 id="what-are-range-indexes"><a class="header" href="#what-are-range-indexes">What are Range Indexes?</a></h2>
<p>A range index organizes data in a way that optimizes searches for values within ranges rather than exact matches. This
allows for efficient "greater than," "less than," and "between" queries.</p>
<p>Consider an index on an <code>age</code> property:</p>
<p><object type="image/svg+xml" data="./range_index/image.svg" title="Diagram showing a range index on age, highlighting nodes with age >= 35"></object></p>
<p>In this diagram:</p>
<ul>
<li>The <strong>graph</strong> on the right contains vertices (A, B, C, D) with an <code>age</code> property.</li>
<li>The <strong>range index</strong> on the left stores <code>(age, vertex)</code> pairs, crucially <strong>sorted by age</strong>. Notice how <code>age: 35</code>
appears twice, pointing to both <code>B</code> and <code>D</code>.</li>
<li>When a <strong>range query</strong> like <code>age &gt;= 35</code> is executed:
<ul>
<li>The index efficiently locates the starting point for the value <code>35</code>.</li>
<li>It then scans forward through the sorted index entries (35, 35, 42) until the condition is no longer met.</li>
<li>The vertices associated with these index entries (<code>B</code>, <code>D</code>, <code>C</code>) are identified as the result.</li>
</ul>
</li>
<li>The <strong>orange highlighting</strong> shows the portion of the index scanned (<code>age &gt;= 35</code>) and the resulting vertices (<code>B</code>, <code>D</code>,
<code>C</code>) in the graph.</li>
<li><strong>Blue arrows</strong> point from the selected index entries to the corresponding graph vertices.</li>
</ul>
<p>This is much faster than checking the <code>age</code> property of every single vertex in the graph for large datasets.</p>
<h2 id="defining-range-indexes"><a class="header" href="#defining-range-indexes">Defining Range Indexes</a></h2>
<p>In Graph API, you define a range index by adding the <code>#[index(range)]</code> attribute to a field in your vertex or edge enum:</p>
<pre><code class="language-rust noplayground">#[derive(Debug, VertexExt)]
pub enum IndexedVertex {
    // Person vertex with various properties
    Person {
        name: String, // Not indexed

        #[index(range)] // Range index for range lookups
        age: u8,
    },
}</code></pre>
<h2 id="how-range-indexes-work"><a class="header" href="#how-range-indexes-work">How Range Indexes Work</a></h2>
<p>When you apply the <code>#[index(range)]</code> attribute to a field:</p>
<ol>
<li>The derive macro generates a range index entry for that field</li>
<li>The graph implementation maintains an ordered data structure mapping property values to vertices</li>
<li>When you make a range query, the graph can efficiently find all values within the specified range</li>
</ol>
<p>Range indexes typically use ordered data structures like B-trees or skip lists to enable efficient range lookups.</p>
<h2 id="querying-with-range-indexes"><a class="header" href="#querying-with-range-indexes">Querying with Range Indexes</a></h2>
<p>The primary benefit of range indexes is the ability to perform efficient range queries:</p>
<pre><code class="language-rust noplayground">    // Find people within a specific age range (29-35)
    let age_range_results = graph
        .walk()
        .vertices(Vertex::person_by_age_range(29..36))
        .collect::&lt;Vec&lt;_&gt;&gt;();
    println!("Found {} people aged 29-35", age_range_results.len());
</code></pre>
<h2 id="performance-benefits-1"><a class="header" href="#performance-benefits-1">Performance Benefits</a></h2>
<p>Range indexes offer significant performance advantages for range-based queries:</p>
<ol>
<li><strong>Logarithmic lookup time</strong>: O(log n) rather than O(n) for full scans</li>
<li><strong>Reduced memory pressure</strong>: Only relevant vertices are loaded</li>
<li><strong>Efficient for slices</strong>: Get only the elements within a specific range</li>
</ol>
<h2 id="when-to-use-range-indexes"><a class="header" href="#when-to-use-range-indexes">When to Use Range Indexes</a></h2>
<p>Range indexes are ideal for:</p>
<ul>
<li><strong>Numeric properties</strong>: Age, price, quantity, ratings</li>
<li><strong>Date/time values</strong>: Timestamps, creation dates, expiration dates</li>
<li><strong>Sequential identifiers</strong>: Version numbers, sequential IDs</li>
<li><strong>Properties used in inequality filters</strong>: Where you need &gt;, &lt;, &gt;=, &lt;= comparisons</li>
</ul>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<p>When using range indexes:</p>
<ol>
<li><strong>Apply to ordered data</strong>: Only index fields where ordering is meaningful</li>
<li><strong>Consider data distribution</strong>: Range indexes work best with evenly distributed values</li>
<li><strong>Time vs. space tradeoff</strong>: Range indexes may use more space than hash indexes</li>
<li><strong>Use for common queries</strong>: Index fields frequently used in range filters</li>
<li><strong>Choose proper data types</strong>: Use comparable types that have a meaningful ordering</li>
</ol>
<h2 id="index-limitations-1"><a class="header" href="#index-limitations-1">Index Limitations</a></h2>
<p>Range indexes have some limitations:</p>
<ol>
<li><strong>Storage overhead</strong>: Typically larger than hash indexes</li>
<li><strong>Update cost</strong>: Maintaining order requires more work when updating</li>
<li><strong>Not for full-text search</strong>: For text search use <a href="user_guide/property_graphs/./full_text_index.html">full-text indexes</a> instead</li>
</ol>
<h2 id="supported-types"><a class="header" href="#supported-types">Supported Types</a></h2>
<p>Range indexes can be applied to:</p>
<ul>
<li><strong>Numeric types</strong>: integers (<code>u8</code>, <code>i32</code>, etc.), floating-point numbers (<code>f32</code>, <code>f64</code>)</li>
<li><strong>String types</strong>: <code>String</code>, <code>&amp;str</code> (lexicographic ordering)</li>
<li><strong>Date/time types</strong>: When represented as ISO-8601 strings or numeric timestamps</li>
<li><strong>Other ordered types</strong>: Any type that implements <code>Ord</code> and appropriate serialization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-text-indexes"><a class="header" href="#full-text-indexes">Full-text Indexes</a></h1>
<p>Full-text indexes enable powerful text search capabilities, allowing you to find vertices containing specific words or
phrases within a text field.</p>
<h2 id="what-are-full-text-indexes"><a class="header" href="#what-are-full-text-indexes">What are Full-text Indexes?</a></h2>
<p>A full-text index is a specialized index that processes text fields to enable efficient searching based on word content.
Unlike standard indexes that require exact matches, full-text indexes allow you to find vertices that contain specific
words, regardless of their position within the text.</p>
<p>Consider an index on a <code>description</code> property:
<object type="image/svg+xml" data="./full_text_index/image.svg" title="Diagram showing a full-text index mapping words to graph vertices, highlighting a search for 'traversal'"></object></p>
<p>In this diagram:</p>
<ul>
<li>The <strong>graph</strong> on the right has vertices (A, B, C) with text <code>description</code> properties.</li>
<li>The <strong>full-text index</strong> on the left is an inverted index:
<ul>
<li>It lists processed <strong>tokens</strong> (like 'fast', 'graph', 'traversal').</li>
<li>For each token, it points to the <strong>vertices</strong> (<code>A</code>, <code>B</code>, <code>C</code>) whose <code>description</code> contains that token after
processing. Note how 'graph' points to both <code>A</code> and <code>B</code>.</li>
</ul>
</li>
<li>When a <strong>query</strong> like <code>description CONTAINS 'traversal'</code> is performed:
<ul>
<li>The index is used to look up the token 'traversal'.</li>
<li>The index directly provides the list of matching vertices: <code>[ B, C ]</code>.</li>
</ul>
</li>
<li>The <strong>orange highlighting</strong> shows the index entry for 'traversal' being used and the resulting vertices (<code>B</code>, <code>C</code>)
identified in the graph.</li>
<li><strong>Blue arrows</strong> point from the selected index entry to the corresponding graph vertices.</li>
</ul>
<p>This approach is fundamental to searching documentation, product descriptions, user comments, or any unstructured text
associated with graph elements.</p>
<h2 id="defining-full-text-indexes"><a class="header" href="#defining-full-text-indexes">Defining Full-text Indexes</a></h2>
<p>In Graph API, you define a full-text index by using the <code>#[index(full_text)]</code> attribute on string fields:</p>
<pre><code class="language-rust noplayground">#[derive(Debug, VertexExt)]
pub enum IndexedVertex {
    // Person vertex with various properties
    Person {
        name: String, // Not indexed

        #[index(hash)] // Hash index for exact lookups
        username: String,
    },
}</code></pre>
<h2 id="how-full-text-indexes-work"><a class="header" href="#how-full-text-indexes-work">How Full-text Indexes Work</a></h2>
<p>Behind the scenes, full-text indexes:</p>
<ol>
<li>Process text by splitting into words (tokenization)</li>
<li>Normalize words (lowercasing, removing punctuation)</li>
<li>Create an inverted index mapping words to vertices</li>
<li>Enable efficient lookup by word or phrase</li>
</ol>
<h2 id="querying-with-full-text-indexes"><a class="header" href="#querying-with-full-text-indexes">Querying with Full-text Indexes</a></h2>
<p>Full-text indexes dramatically simplify text search operations:</p>
<pre><code class="language-rust noplayground">    // Find people with "developer" in their biography
    let developers = graph
        .walk()
        .vertices(Vertex::person_by_biography("developer"))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} people who are developers", developers.len());</code></pre>
<h2 id="performance-benefits-2"><a class="header" href="#performance-benefits-2">Performance Benefits</a></h2>
<p>Full-text indexes provide significant advantages for text search:</p>
<ol>
<li><strong>Efficient keyword matching</strong>: Find text containing specific words without scanning</li>
<li><strong>Reduced memory requirements</strong>: Only load relevant vertices</li>
<li><strong>Better user experience</strong>: Enable natural language search patterns</li>
<li><strong>Improved relevance</strong>: Return results based on word presence rather than exact matches</li>
</ol>
<h2 id="when-to-use-full-text-indexes"><a class="header" href="#when-to-use-full-text-indexes">When to Use Full-text Indexes</a></h2>
<p>Full-text indexes are ideal for:</p>
<ul>
<li><strong>Content search</strong>: Articles, posts, descriptions</li>
<li><strong>User profiles</strong>: Biographies, skills, interests</li>
<li><strong>Product descriptions</strong>: Features, benefits, specifications</li>
<li><strong>Documentation</strong>: API details, manuals, guides</li>
<li><strong>Search functionality</strong>: Implementing search features in your application</li>
</ul>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<p>When using full-text indexes:</p>
<ol>
<li><strong>Choose appropriate fields</strong>: Apply to content-rich text fields</li>
<li><strong>Consider search patterns</strong>: Think about how users will search</li>
<li><strong>Balance with standard indexes</strong>: Use standard indexes for fields requiring exact matches</li>
<li><strong>Be mindful of size</strong>: Full-text indexes can be larger than standard indexes</li>
</ol>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Full-text indexes have some limitations:</p>
<ol>
<li><strong>String fields only</strong>: Only applicable to string properties</li>
<li><strong>Implementation dependent</strong>: Search capabilities vary by graph implementation</li>
<li><strong>Tokenization limitations</strong>: Basic word splitting may not handle all languages equally</li>
<li><strong>Update complexity</strong>: Maintaining the index adds overhead during updates</li>
</ol>
<p>For range-based queries, see <a href="user_guide/property_graphs/./range_index.html">range indexes</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-macros"><a class="header" href="#derive-macros">Derive Macros</a></h1>
<p>Graph API's derive macros automatically generate code that integrates your custom types with the Graph API framework,
making your graph operations type-safe and ergonomic. This section explains the types that are generated and how to use
them effectively.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Graph API provides two primary derive macros:</p>
<ol>
<li><code>VertexExt</code> - For vertex enum types</li>
<li><code>EdgeExt</code> - For edge enum types</li>
</ol>
<pre><code class="language-rust noplayground">    // Create a new graph with our model
    let mut graph = SimpleGraph::&lt;Vertex, Edge&gt;::new();

    // Add vertices of different types
    let alice = graph.add_vertex(Vertex::Person {
        name: "Alice".to_string(),
        username: "alice_dev".to_string(),
        biography: "Software engineer and graph enthusiast".to_string(),
        age: 29,
    });

    let project = graph.add_vertex(Vertex::Project {
        name: "GraphDB".to_string(),
    });

    // Add edges connecting vertices
    graph.add_edge(alice, project, Edge::Created);

    // Use type-safe projections for property access
    let person_info = graph
        .walk()
        .vertices(VertexSearch::scan())
        .filter_person() // Generated helper method
        .map(|v, _| {
            // Use type-safe projection
            let person = v.project::&lt;Person&lt;_&gt;&gt;().unwrap();

            // Return formatted string with person information
            format!(
                "Person: {} (@{})\n  Bio: {}\n  Age: {}",
                person.name(),
                person.username(),
                person.biography(),
                person.age()
            )
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // Print the collected information
    for info in person_info {
        println!("{}", info);
    }</code></pre>
<h2 id="generated-types-for-vertexext"><a class="header" href="#generated-types-for-vertexext">Generated Types for VertexExt</a></h2>
<p>When you apply <code>#[derive(VertexExt)]</code> to an enum, several useful types are generated:</p>
<h3 id="1-label-enum-vertexlabel"><a class="header" href="#1-label-enum-vertexlabel">1. Label Enum (VertexLabel)</a></h3>
<p>A type-safe enum representing the variants of your vertex enum:</p>
<pre><code class="language-rust noplayground">// Given this vertex definition
#[derive(VertexExt)]
enum Vertex {
    Person { /* fields */ },
    Project { /* fields */ },
    Comment { /* fields */ },
}

// This is generated
pub enum VertexLabel {
    Person,
    Project,
    Comment,
}</code></pre>
<p><strong>Purpose</strong>: Provides type-safe representations of vertex types, used for label-based indexing and filtering.</p>
<h3 id="2-index-selectors"><a class="header" href="#2-index-selectors">2. Index selectors</a></h3>
<p>Selectors to make querying easier:</p>
<pre><code class="language-rust noplayground">impl Vertex {
    // Find all Person vertices
    pub fn person() -&gt; VertexSearch { /* ... */ }
    
    // Find Person vertices by indexed properties
    pub fn person_by_username(username: &amp;str) -&gt; VertexSearch { /* ... */ }
    pub fn person_by_biography(text: &amp;str) -&gt; VertexSearch { /* ... */ }
    pub fn person_by_age_range(range: Range&lt;u8&gt;) -&gt; VertexSearch { /* ... */ }
}</code></pre>
<p><strong>Purpose</strong>: Enables efficient querying of vertices by label and properties.</p>
<h3 id="3-projection-types"><a class="header" href="#3-projection-types">3. Projection Types</a></h3>
<p>For each variant with fields, two projection structs are generated:</p>
<pre><code class="language-rust noplayground">// For Person variant
pub struct Person&lt;'a, V&gt; {
    // Immutable references to fields
    name: &amp;'a String,
    username: &amp;'a String,
    biography: &amp;'a String,
    age: &amp;'a u8,
    unique_id: &amp;'a Uuid,
}

pub struct PersonMut&lt;'a, V&gt; {
    // Mutable references to fields
    name: &amp;'a mut String,
    username: &amp;'a mut String,
    biography: &amp;'a mut String,
    age: &amp;'a mut u8,
    unique_id: &amp;'a mut Uuid,
}</code></pre>
<p><strong>Purpose</strong>: Provides type-safe access to variant fields without manually matching on enum variants.</p>
<h3 id="4-filter-extension-traits"><a class="header" href="#4-filter-extension-traits">4. Filter Extension Traits</a></h3>
<p>Extension methods for the walker builder to filter by vertex type:</p>
<pre><code class="language-rust noplayground">// On WalkerBuilder
// For all Person vertices
fn filter_person(self) -&gt; Self;

// For Person vertices with custom criteria
fn filter_by_person&lt;F&gt;(self, filter: F) -&gt; Self
where
    F: Fn(Person&lt;Vertex&gt;, &amp;Context) -&gt; bool;</code></pre>
<p><strong>Purpose</strong>: Enables type-safe filtering of vertices during traversals.</p>
<h2 id="generated-types-for-edgeext"><a class="header" href="#generated-types-for-edgeext">Generated Types for EdgeExt</a></h2>
<p>When you apply <code>#[derive(EdgeExt)]</code> to an enum, similar types are generated:</p>
<h3 id="1-label-enum-edgelabel"><a class="header" href="#1-label-enum-edgelabel">1. Label Enum (EdgeLabel)</a></h3>
<pre><code class="language-rust noplayground">// Given this edge definition
#[derive(EdgeExt)]
enum Edge {
    Created,
    Follows,
    Liked { timestamp: String },
    Commented { timestamp: String },
}

// This is generated
pub enum EdgeLabel {
    Created,
    Follows,
    Liked,
    Commented,
}</code></pre>
<p><strong>Purpose</strong>: Provides type-safe representations of edge types, used for label-based indexing and filtering.</p>
<h3 id="2-index-selectors-1"><a class="header" href="#2-index-selectors-1">2. Index selectors</a></h3>
<p>Selectors to make querying easier</p>
<pre><code class="language-rust noplayground">impl Edge {
    // Find all Created edges
    pub fn created() -&gt; EdgeSearch { /* ... */ }
    
    // Find all Follows edges
    pub fn follows() -&gt; EdgeSearch { /* ... */ }
    
    // Find all Liked edges
    pub fn liked() -&gt; EdgeSearch { /* ... */ }
    
    // Find all Commented edges
    pub fn commented() -&gt; EdgeSearch { /* ... */ }
}</code></pre>
<p><strong>Purpose</strong>: Enables efficient querying of edges by label.</p>
<h3 id="3-projection-types-1"><a class="header" href="#3-projection-types-1">3. Projection Types</a></h3>
<p>For each variant with fields, projection structs are generated:</p>
<pre><code class="language-rust noplayground">// For Liked variant
pub struct Liked&lt;'a, E&gt; {
    timestamp: &amp;'a String,
}

pub struct LikedMut&lt;'a, E&gt; {
    timestamp: &amp;'a mut String,
}</code></pre>
<p><strong>Purpose</strong>: Provides type-safe access to edge properties.</p>
<h3 id="4-filter-extension-traits-1"><a class="header" href="#4-filter-extension-traits-1">4. Filter Extension Traits</a></h3>
<p>Extension methods for the walker builder to filter by edge type:</p>
<pre><code class="language-rust noplayground">// On WalkerBuilder
// For all Liked edges
fn filter_liked(self) -&gt; Self;

// For Liked edges with custom criteria
fn filter_by_liked&lt;F&gt;(self, filter: F) -&gt; Self
where
    F: Fn(Liked&lt;Edge&gt;, &amp;Context) -&gt; bool;</code></pre>
<p><strong>Purpose</strong>: Enables type-safe filtering of edges during traversals.</p>
<h2 id="using-the-generated-types"><a class="header" href="#using-the-generated-types">Using the Generated Types</a></h2>
<h3 id="vertex-querying"><a class="header" href="#vertex-querying">Vertex Querying</a></h3>
<pre><code class="language-rust noplayground">// Find all Person vertices
let people = graph
    .walk()
    .vertices(Vertex::person())
    .collect::&lt;Vec&lt;_&gt;&gt;();

// Find Person vertices with a specific username
let user = graph
    .walk()
    .vertices(Vertex::person_by_username("bryn123"))
    .first()
    .unwrap();

// Find Person vertices in an age range
let adults = graph
    .walk()
    .vertices(Vertex::person_by_age_range(18..65))
    .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="edge-traversal"><a class="header" href="#edge-traversal">Edge Traversal</a></h3>
<pre><code class="language-rust noplayground">// Find outgoing Created edges from a person
let created_projects = graph
    .walk()
    .vertices_by_id([person_id])
    .edges(Edge::created().outgoing())
    .tail()  // Follow edges to target vertices
    .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="type-safe-filtering"><a class="header" href="#type-safe-filtering">Type-Safe Filtering</a></h3>
<pre><code class="language-rust noplayground">// Find Person vertices that match specific criteria
let experienced_devs = graph
    .walk()
    .vertices(Vertex::person())
    .filter_by_person(|person, _| {
        person.age() &gt; 25 &amp;&amp; person.biography().contains("developer")
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="projection-for-type-safety"><a class="header" href="#projection-for-type-safety">Projection for Type Safety</a></h3>
<pre><code class="language-rust noplayground">// Working with a vertex reference
if let Some(vertex_ref) = graph.vertex(vertex_id) {
    // Project to Person variant
    if let Some(person) = vertex_ref.project::&lt;Person&lt;_&gt;&gt;() {
        println!("Name: {}, Age: {}", person.name(), person.age());
    }
}</code></pre>
<h2 id="index-attributes"><a class="header" href="#index-attributes">Index Attributes</a></h2>
<p>You can apply these attributes to fields to control indexing behavior:</p>
<ul>
<li><code>#[index]</code> - Standard index for exact match queries</li>
<li><code>#[index(range)]</code> - Range index for range queries</li>
<li><code>#[index(full_text)]</code> - Full-text index for text search (String fields only)</li>
</ul>
<pre><code class="language-rust noplayground">#[derive(VertexExt)]
enum User {
    Profile {
        #[index]  // Standard index
        username: String,
        
        #[index(range)]  // Range queries possible
        age: u32,
        
        #[index(full_text)]  // Text search possible
        bio: String,
        
        // Not indexed
        email: String,
    }
}</code></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li>
<p><strong>Selective Indexing</strong>: Only add indexes to fields you'll frequently query, as each index increases memory usage.</p>
</li>
<li>
<p><strong>Choose Appropriate Index Types</strong>:</p>
<ul>
<li>Use <code>#[index]</code> for exact match lookups</li>
<li>Use <code>#[index(range)]</code> for numeric fields that need range queries</li>
<li>Use <code>#[index(full_text)]</code> for text fields that need substring or keyword search</li>
</ul>
</li>
<li>
<p><strong>Use Type-Safe Methods</strong>:</p>
<ul>
<li>Prefer <code>filter_by_person()</code> over generic <code>filter()</code> with manual pattern matching</li>
<li>Use the generated search methods (<code>person_by_username()</code>, etc.) for efficient queries</li>
</ul>
</li>
<li>
<p><strong>Leverage Projections</strong>:</p>
<ul>
<li>Use the projection types to safely access variant fields without repetitive pattern matching</li>
<li>This makes your code more maintainable and less error-prone</li>
</ul>
</li>
<li>
<p><strong>Consider Query Performance</strong>:</p>
<ul>
<li>Using an indexed search in the initial <code>vertices()</code> step is typically more efficient than scanning and then
filtering</li>
<li>The more you can narrow your search using indexes, the better your graph traversal performance</li>
</ul>
</li>
</ol>
<p>For more detailed information on the derive macros, see the <a href="user_guide/../reference/derive_macros.html">API Reference</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h1>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Once you've defined your graph model, you can perform basic operations like adding vertices and edges, querying the
graph, and modifying elements. This guide covers the fundamental operations available in Graph API.</p>
<h2 id="creating-a-graph"><a class="header" href="#creating-a-graph">Creating a Graph</a></h2>
<p>To start working with graphs, first create a new graph instance:</p>
<pre><code class="language-rust noplayground">        // Import the standard model and create a new graph
        let mut graph = SimpleGraph::&lt;Vertex, Edge&gt;::new();</code></pre>
<h2 id="adding-vertices"><a class="header" href="#adding-vertices">Adding Vertices</a></h2>
<p>Once you have a graph instance, you can add vertices to it:</p>
<pre><code class="language-rust noplayground">        // Add a person vertex
        let bryn = graph.add_vertex(Vertex::Person {
            name: "Bryn".to_string(),
            username: "bryn123".to_string(),
            biography: "Graph enthusiast".to_string(),
            age: 28,
        });

        // Add a project vertex
        let project = graph.add_vertex(Vertex::Project {
            name: "GraphAPI".to_string(),
        });

        // Add a comment vertex
        let comment = graph.add_vertex(Vertex::Comment {
            text: "Great project!".to_string(),
            date: "2023-05-15".to_string(),
        });</code></pre>
<h2 id="adding-edges"><a class="header" href="#adding-edges">Adding Edges</a></h2>
<p>Edges connect vertices in your graph:</p>
<pre><code class="language-rust noplayground">        // Add simple edges
        graph.add_edge(bryn, project, Edge::Created);
        graph.add_edge(julia, bryn, Edge::Follows);

        // Add edges with properties
        graph.add_edge(
            bryn,
            project,
            Edge::Liked {
                timestamp: "2023-01-15".to_string(),
            },
        );</code></pre>
<h2 id="querying-vertices"><a class="header" href="#querying-vertices">Querying Vertices</a></h2>
<p>You can query vertices using the walker API. Here are some examples:</p>
<h3 id="full-scan"><a class="header" href="#full-scan">Full Scan</a></h3>
<p>When you need to find all vertices in the graph:</p>
<pre><code class="language-rust noplayground">        // Get all vertices in the graph
        let all_vertices = graph
            .walk()
            .vertices() // Start with all vertices
            .collect::&lt;Vec&lt;_&gt;&gt;();

        // Count vertices by type using type-safe filters
        let person_count = graph
            .walk()
            .vertices()
            .filter_person() // Use generated helper method
            .count();

        let project_count = graph
            .walk()
            .vertices()
            .filter_project() // Use generated helper method
            .count();</code></pre>
<h3 id="label-based-lookup"><a class="header" href="#label-based-lookup">Label-Based Lookup</a></h3>
<p>For more efficient queries, use label-based indexes:</p>
<pre><code class="language-rust noplayground">        // Find all Person vertices using label index
        let all_people = graph
            .walk()
            .vertices()
            .filter_person() // Use generated helper for label filtering
            .collect::&lt;Vec&lt;_&gt;&gt;();

        // Find all Project vertices using label index
        let all_projects = graph
            .walk()
            .vertices()
            .filter_project() // Use generated helper for label filtering
            .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="property-filtering"><a class="header" href="#property-filtering">Property Filtering</a></h3>
<p>Filter vertices based on their properties:</p>
<pre><code class="language-rust noplayground">        // Find people over 30 years old
        let older_people = graph
            .walk()
            .vertices()
            .filter_by_person(|person, _| {
                // Type-safe access to Person properties
                person.age() &gt; 30
            })
            .map(|v, _| {
                // Use type-safe projection and accessor methods
                let person = v.project::&lt;Person&lt;_&gt;&gt;().unwrap();
                format!("{} ({})", person.name(), person.age())
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();

        // Find people with "programmer" in their biography
        let programmers = graph
            .walk()
            .vertices()
            .filter_by_person(|person, _| {
                // Type-safe access to Person properties
                person.biography().contains("programmer")
            })
            .map(|v, _| {
                // Use type-safe projection and accessor methods
                v.project::&lt;Person&lt;_&gt;&gt;().unwrap().name().to_string()
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h2 id="working-with-edges"><a class="header" href="#working-with-edges">Working with Edges</a></h2>
<p>The walker API also provides powerful tools for working with edges:</p>
<h3 id="finding-connected-edges"><a class="header" href="#finding-connected-edges">Finding Connected Edges</a></h3>
<p>Get all edges connected to a vertex:</p>
<pre><code class="language-rust noplayground">            // Get all edges connected to a specific vertex
            let connected_edges = graph
                .walk()
                .vertices_by_id(vec![person_id])
                .edges(EdgeSearch::scan()) // Get all connected edges
                .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="directional-edge-queries"><a class="header" href="#directional-edge-queries">Directional Edge Queries</a></h3>
<p>Specify whether you want incoming or outgoing edges:</p>
<pre><code class="language-rust noplayground">            // Get only outgoing edges
            let outgoing_edges = graph
                .walk()
                .vertices_by_id(vec![person_id])
                .edges(EdgeSearch::scan().outgoing()) // Only outgoing edges
                .collect::&lt;Vec&lt;_&gt;&gt;();

            // Get only incoming edges
            let incoming_edges = graph
                .walk()
                .vertices_by_id(vec![person_id])
                .edges(EdgeSearch::scan().incoming()) // Only incoming edges
                .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="label-based-edge-filtering"><a class="header" href="#label-based-edge-filtering">Label-Based Edge Filtering</a></h3>
<p>Filter edges by their label:</p>
<pre><code class="language-rust noplayground">        // Find all "Created" edges in the graph
        let creation_edges = graph
            .walk()
            .edges(EdgeSearch::scan())
            .filter_created() // Type-safe filter using generated helper
            .collect::&lt;Vec&lt;_&gt;&gt;();

        // Find all "Follows" edges in the graph
        let follow_edges = graph
            .walk()
            .edges(EdgeSearch::scan())
            .filter_follows() // Type-safe filter using generated helper
            .collect::&lt;Vec&lt;_&gt;&gt;();

        // Find all edges with timestamp properties
        let timestamped_edges = graph
            .walk()
            .edges(EdgeSearch::scan())
            .filter(|e, _| match e.weight() {
                Edge::Liked { timestamp } =&gt; true,
                Edge::Commented { timestamp } =&gt; true,
                _ =&gt; false,
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h2 id="modifying-the-graph"><a class="header" href="#modifying-the-graph">Modifying the Graph</a></h2>
<p>You can modify the graph during traversal using the mutation API:</p>
<h3 id="updating-vertex-properties"><a class="header" href="#updating-vertex-properties">Updating Vertex Properties</a></h3>
<pre><code class="language-rust noplayground">        // Update all Person vertices to increment their age
        let updated_count = graph
            .walk_mut()
            .vertices()
            .filter_person() // Type-safe filter using generated helper
            .mutate(|v| {
                // Type-safe mutation using projection
                if let Some(mut person) = v.project_mut::&lt;Person&lt;_&gt;&gt;() {
                    // Update the age property
                    let current_age = person.age();
                    person.set_age(current_age + 1);
                    true // Indicate that we modified the vertex
                } else {
                    false // No modification
                }
            });

        // Add a property to a specific person
        graph
            .walk_mut()
            .vertices()
            .filter_by_person(|p, _| p.username() == "bryn123")
            .mutate(|v| {
                // Type-safe mutation using projection
                if let Some(mut person) = v.project_mut::&lt;Person&lt;_&gt;&gt;() {
                    // Update the biography property
                    person.set_biography("Updated biography: Graph API expert");
                    true // Indicate that we modified the vertex
                } else {
                    false // No modification
                }
            });</code></pre>
<h3 id="verifying-changes"><a class="header" href="#verifying-changes">Verifying Changes</a></h3>
<p>After modification, you can verify the changes:</p>
<pre><code class="language-rust noplayground">        // Check that Bryn's biography was updated
        let updated_bio = graph
            .walk()
            .vertices()
            .filter_by_person(|p, _| p.username() == "bryn123")
            .map(|v, _| {
                // Type-safe access using projection
                v.project::&lt;Person&lt;_&gt;&gt;().unwrap().biography().to_string()
            })
            .first();

        // Verify all people are now older
        let all_ages = graph
            .walk()
            .vertices()
            .filter_person() // Type-safe filter using generated helper
            .map(|v, _| {
                // Type-safe access using projection
                let person = v.project::&lt;Person&lt;_&gt;&gt;().unwrap();
                (person.name().to_string(), person.age())
            })
            .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you understand the basic operations, you can:</p>
<ol>
<li>Learn about <a href="user_guide/./traversal.html">Advanced Traversals</a> using the Walker API</li>
<li>Explore <a href="user_guide/./walker/context_system.html">Context and State</a> in graph traversals</li>
<li>See <a href="user_guide/./walker/steps.html">Examples of Walker Steps</a> to build more complex queries</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-traversal"><a class="header" href="#graph-traversal">Graph Traversal</a></h1>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The Graph API provides a powerful traversal interface called "walkers" that enables you to navigate and analyze your
graph in a flexible, type-safe way. Walkers are the primary method for querying and manipulating graph data.</p>
<h2 id="basic-concepts-2"><a class="header" href="#basic-concepts-2">Basic Concepts</a></h2>
<p>Walkers are built by chaining steps that define how to traverse the graph. Each step performs a specific operation, such
as:</p>
<ul>
<li>Starting at specific vertices</li>
<li>Moving to connected edges</li>
<li>Filtering elements</li>
<li>Collecting data</li>
<li>Modifying the graph</li>
</ul>
<h2 id="traversal-order-depth-first"><a class="header" href="#traversal-order-depth-first">Traversal Order (Depth-First)</a></h2>
<p>By default, the Graph API walker performs a <strong>Depth-First Search (DFS)</strong> traversal. This means it explores as far as
possible along each branch before backtracking.</p>
<object type="image/svg+xml" data="traversal/dfs_traversal_image.svg">
Diagram illustrating Depth-First Search traversal order
</object>
<p>In the diagram above:</p>
<ul>
<li>The traversal starts at node <strong>A</strong>.</li>
<li>It explores the <strong>left branch</strong> first: <strong>A â†’ B â†’ D â†’ E</strong>.</li>
<li>After reaching the end of the left branch (E), it <strong>backtracks</strong> to B, then A.</li>
<li>It then explores the <strong>right branch</strong>: <strong>A â†’ C â†’ F</strong>.</li>
<li>The <strong>final DFS order</strong> is indicated by the numbers: <strong>A(1) â†’ B(2) â†’ D(3) â†’ E(4) â†’ C(5) â†’ F(6)</strong>.</li>
<li>The <strong>orange arrows</strong> highlight the path taken during the traversal.</li>
</ul>
<p>This DFS behaviour is fundamental to how walkers navigate the graph.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="basic-traversal"><a class="header" href="#basic-traversal">Basic Traversal</a></h3>
<p>Here's an example that finds all Project vertices that were created by someone that a Person knows:</p>
<pre><code class="language-rust noplayground">// Basic traversal example showing a complex path through the graph
pub fn basic_traversal_example&lt;G&gt;(graph: &amp;G)
where
    G: Graph&lt;Vertex = Vertex, Edge = Edge&gt; + SupportsVertexLabelIndex + SupportsEdgeLabelIndex,
{
    // Find all Person vertices who know someone who created a Project
    let _results = graph
        .walk()
        .vertices(Vertex::person()) // Start with Person vertices
        .edges(Edge::follows()) // Follow "follows" edges
        .tail() // Move to the target Person
        .edges(Edge::created()) // Follow "created" edges
        .tail() // Move to the Project
        .filter_project()
        .collect::&lt;Vec&lt;_&gt;&gt;(); // Collect results
}</code></pre>
<p>This traversal:</p>
<ol>
<li>Starts with Person vertices</li>
<li>Follows "knows" edges to find friends</li>
<li>Follows "created" edges from friends</li>
<li>Filters for Project vertices</li>
<li>Collects the results</li>
</ol>
<h3 id="working-with-context"><a class="header" href="#working-with-context">Working with Context</a></h3>
<p>Walkers have a built-in context system that allows you to store and transform data as you traverse the graph:</p>
<pre><code class="language-rust noplayground">// Context example showing how to calculate the total age of all friends
pub fn context_traversal_example&lt;G&gt;(graph: &amp;G, person_id: G::VertexId)
where
    G: Graph&lt;Vertex = Vertex, Edge = Edge&gt; + SupportsEdgeLabelIndex,
{
    // Calculate total age of all friends of a person
    let _total_age = graph
        .walk()
        .vertices_by_id(vec![person_id])
        .edges(Edge::follows())
        .tail()
        .filter_person()
        .push_context(|v, _| {
            // Store age in context
            if let Some(person) = v.project::&lt;Person&lt;_&gt;&gt;() {
                person.age()
            } else {
                0
            }
        })
        .fold(0, |acc, _, age| acc + age.deref());
}</code></pre>
<p>In this example, we:</p>
<ol>
<li>Start with a specific person</li>
<li>Find all friends (via "knows" edges)</li>
<li>Filter for Person vertices</li>
<li>Store each person's age in the context</li>
<li>Sum up all the ages</li>
</ol>
<h2 id="walker-steps"><a class="header" href="#walker-steps">Walker Steps</a></h2>
<p>The Graph API provides many steps that can be combined to create complex traversals. Each step is documented with:</p>
<p>See the <a href="user_guide/./walker/steps.html">Walker Steps</a> section for detailed documentation on each available step.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walker-overview"><a class="header" href="#walker-overview">Walker Overview</a></h1>
<p>Walkers are the central concept in Graph API traversals. They provide a fluent interface for exploring and manipulating
graph data.</p>
<h2 id="what-are-walkers"><a class="header" href="#what-are-walkers">What are Walkers?</a></h2>
<p>A walker represents a traversal through a graph. It consists of:</p>
<ol>
<li>A <strong>current position</strong> in the graph (vertices or edges)</li>
<li><strong>Context data</strong> that can be carried along the traversal</li>
<li>A sequence of <strong>steps</strong> that define the traversal path</li>
</ol>
<p>Walkers use a builder pattern where each step returns a new walker with the accumulated operations.</p>
<h2 id="how-walkers-work"><a class="header" href="#how-walkers-work">How Walkers Work</a></h2>
<ol>
<li>Start with an empty walker using <code>graph.walk()</code></li>
<li>Chain steps to define your traversal: <code>.vertices().edges().tail()</code></li>
<li>End with a terminal operation: <code>.collect()</code>, <code>.first()</code>, <code>.count()</code>, etc.</li>
</ol>
<p>Each step in the chain modifies the traversal in a specific way, moving to different elements, filtering, or collecting
data.</p>
<h2 id="types-of-walkers"><a class="header" href="#types-of-walkers">Types of Walkers</a></h2>
<p>The Graph API has two main types of walkers:</p>
<ol>
<li><strong>Vertex Walkers</strong>: Traverse vertex elements</li>
<li><strong>Edge Walkers</strong>: Traverse edge elements</li>
</ol>
<p>Some operations switch between these types. For example, <code>.edges()</code> converts a vertex walker to an edge walker, while
<code>.head()</code> and <code>.tail()</code> convert an edge walker to a vertex walker.</p>
<h2 id="walker-states"><a class="header" href="#walker-states">Walker States</a></h2>
<p>A walker can be in one of several states:</p>
<ol>
<li><strong>Empty</strong>: No elements to traverse (starting state)</li>
<li><strong>Active</strong>: Contains elements to traverse</li>
<li><strong>Terminal</strong>: Has performed its final operation</li>
</ol>
<h2 id="creating-walkers"><a class="header" href="#creating-walkers">Creating Walkers</a></h2>
<p>You create a walker by calling the <code>walk()</code> method on a graph:</p>
<pre><code class="language-rust noplayground">let walker = graph.walk();</code></pre>
<p>This returns an empty walker that can be used to start your traversal.</p>
<h2 id="starting-traversals"><a class="header" href="#starting-traversals">Starting Traversals</a></h2>
<p>There are several ways to populate a walker with initial elements:</p>
<pre><code class="language-rust noplayground">// Start with all vertices
graph.walk().vertices(VertexSearch::scan())

// Start with specific vertex IDs
graph.walk().vertices_by_id(vec![vertex_id1, vertex_id2])

// Start with vertices matching criteria
graph.walk().vertices(VertexSearch::scan().with_label(Person::label()))</code></pre>
<h2 id="walker-flow-control"><a class="header" href="#walker-flow-control">Walker Flow Control</a></h2>
<p>Walkers provide several ways to control the traversal flow:</p>
<ul>
<li><strong>Filtering</strong>: Keep only elements matching a condition</li>
<li><strong>Limiting</strong>: Restrict the number of elements processed</li>
<li><strong>Branching</strong>: Create sub-traversals that explore different paths</li>
<li><strong>Early Termination</strong>: Stop traversal after finding a match</li>
</ul>
<h2 id="example-walker-traversals"><a class="header" href="#example-walker-traversals">Example Walker Traversals</a></h2>
<h3 id="basic-traversal-1"><a class="header" href="#basic-traversal-1">Basic Traversal</a></h3>
<pre><code class="language-rust noplayground">    // Find all Project vertices created by a Person
    let _results = graph
        .walk()
        .vertices(Vertex::person()) // Start with all Person vertices
        .edges(Edge::created()) // Follow "Created" edges
        .tail() // Move to the target vertices (Projects)
        .collect::&lt;Vec&lt;_&gt;&gt;(); // Collect the Project vertices</code></pre>
<h3 id="multi-step-traversal"><a class="header" href="#multi-step-traversal">Multi-Step Traversal</a></h3>
<pre><code class="language-rust noplayground">    // Find all people who follow someone who created a project
    let _results = graph
        .walk()
        .vertices(Vertex::person()) // Start with all Person vertices
        .edges(Edge::follows()) // Follow "follows" edges
        .tail() // Move to the followed person
        .edges(Edge::created()) // Find "created" edges from these people
        .tail() // Move to the Project vertices
        .collect::&lt;Vec&lt;_&gt;&gt;(); // Collect results</code></pre>
<h3 id="traversal-with-detour"><a class="header" href="#traversal-with-detour">Traversal with Detour</a></h3>
<pre><code class="language-rust noplayground">    // For each person, find the projects they created
    let _results = graph
        .walk()
        .vertices(Vertex::person()) // Start with all Person vertices
        .detour(|person_walker| {
            // For each person, collect the projects they created
            person_walker
                .edges(Edge::created()) // Follow "created" edges
                .tail() // Move to the target (projects)
                .take(1) // Only need one match to qualify
        })
        // Continue with original person vertices that have created projects
        .collect::&lt;Vec&lt;_&gt;&gt;(); // Collect results</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>To learn more about specific walker steps, see the <a href="user_guide/walker/./steps.html">Walker Steps</a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walker-steps-1"><a class="header" href="#walker-steps-1">Walker Steps</a></h1>
<p>Walker steps are the building blocks for graph traversals. Each step performs a specific operation on the traversal,
such as moving the position, filtering elements, or collecting results.</p>
<h2 id="what-are-walker-steps"><a class="header" href="#what-are-walker-steps">What are Walker Steps?</a></h2>
<p>Walker steps are chainable operations that build a graph traversal. Each step performs a specific operation on the
traversal, such as:</p>
<ul>
<li>Moving the traversal position (vertices, edges, head, tail)</li>
<li>Filtering elements (filter)</li>
<li>Limiting results (limit, first)</li>
<li>Collecting results (collect)</li>
<li>Modifying the graph (mutate)</li>
<li>And many more</li>
</ul>
<h2 id="available-steps"><a class="header" href="#available-steps">Available Steps</a></h2>
<h3 id="traversal-initiation"><a class="header" href="#traversal-initiation">Traversal Initiation</a></h3>
<ul>
<li><a href="user_guide/walker/steps/vertices.html">vertices</a> - Start traversal from vertices matching criteria</li>
<li><a href="user_guide/walker/steps/vertices_by_id.html">vertices_by_id</a> - Start traversal from vertices with specific IDs</li>
</ul>
<h3 id="traversal-movement"><a class="header" href="#traversal-movement">Traversal Movement</a></h3>
<ul>
<li><a href="user_guide/walker/steps/detour.html">detour</a> - Create a sub-traversal from the current position</li>
<li><a href="user_guide/walker/steps/edges.html">edges</a> - Traverse along edges</li>
<li><a href="user_guide/walker/steps/head.html">head</a> - Move to source vertices of edges</li>
<li><a href="user_guide/walker/steps/tail.html">tail</a> - Move to target vertices of edges</li>
</ul>
<h3 id="filtering-and-limiting"><a class="header" href="#filtering-and-limiting">Filtering and Limiting</a></h3>
<ul>
<li><a href="user_guide/walker/steps/filter.html">filter</a> - Filter elements based on a predicate</li>
<li><a href="user_guide/walker/steps/first.html">first</a> - Get only the first element</li>
<li><a href="user_guide/walker/steps/take.html">take</a> - Take a specified number of elements</li>
</ul>
<h3 id="context-and-data-handling"><a class="header" href="#context-and-data-handling">Context and Data Handling</a></h3>
<ul>
<li><a href="user_guide/walker/steps/push_context.html">push_context</a> - Associate custom data with traversal elements</li>
<li><a href="user_guide/walker/steps/default_context.html">default_context</a> - Use predefined context for common patterns</li>
<li><a href="user_guide/walker/steps/mutate_context.html">mutate_context</a> - Modify context during traversal</li>
</ul>
<h3 id="terminal-operations"><a class="header" href="#terminal-operations">Terminal Operations</a></h3>
<ul>
<li><a href="user_guide/walker/steps/collect.html">collect</a> - Gather results into a collection</li>
<li><a href="user_guide/walker/steps/count.html">count</a> - Count elements in the traversal</li>
<li><a href="user_guide/walker/steps/into_iter.html">into_iter</a> - Convert traversal to an iterator</li>
<li><a href="user_guide/walker/steps/fold.html">fold</a> - Fold elements into an accumulated value</li>
<li><a href="user_guide/walker/steps/map.html">map</a> - Transform elements during traversal</li>
<li><a href="user_guide/walker/steps/reduce.html">reduce</a> - Combine elements using a reduction function</li>
</ul>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<ul>
<li><a href="user_guide/walker/steps/control_flow.html">control_flow</a> - Control traversal flow and early termination</li>
</ul>
<h3 id="side-effects"><a class="header" href="#side-effects">Side effects</a></h3>
<ul>
<li><a href="user_guide/walker/steps/mutate.html">mutate</a> - Modify the graph after traversal</li>
<li><a href="user_guide/walker/steps/probe.html">probe</a> - Inspect elements during traversal</li>
</ul>
<h3 id="debugging"><a class="header" href="#debugging">Debugging</a></h3>
<ul>
<li><a href="user_guide/walker/steps/dbg.html">dbg</a> - Print debug information during traversal</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vertices-step"><a class="header" href="#vertices-step">Vertices Step</a></h1>
<p>The <code>vertices</code> step starts a traversal by selecting an initial set of vertices from the graph based on specified criteria (e.g., using an index or a scan). This step initiates the stream of elements for subsequent walker operations.</p>
<object type="image/svg+xml" data="vertices/image.svg" title="Vertices Step Diagram">
Vertices step diagram showing initial selection of vertices based on criteria
</object>
<p>In this diagram:</p>
<ul>
<li>The <strong>Conceptual Graph Vertices</strong> represent the available vertices in the graph (A: Person, B: Product, C: Person, D: Review).</li>
<li>The <strong><code>graph.walk().vertices(Vertex::person())</code></strong> step is applied, using criteria (like a label index) to select only "Person" vertices.</li>
<li>The <strong>Output Stream</strong> contains only the selected vertices <strong>A</strong> and <strong>C</strong>, which match the criteria and become the initial elements for the rest of the traversal.</li>
</ul>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<pre><code class="language-rust noplayground">graph.walk().vertices(search_criteria)</code></pre>
<p>Where <code>search_criteria</code> is a <code>VertexSearch</code> object or a predefined search from an index.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li><code>search_criteria</code>: A <code>VertexSearch</code> object that defines the criteria for selecting vertices</li>
</ul>
<h2 id="return-value"><a class="header" href="#return-value">Return Value</a></h2>
<p>Returns a new walker positioned at the vertices matching the search criteria.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="full-scan-1"><a class="header" href="#full-scan-1">Full Scan</a></h3>
<p>When you need to find all vertices in a graph:</p>
<pre><code class="language-rust noplayground">    // Scan all vertices in the graph
    // This performs a full graph scan, which can be expensive for large graphs
    let all_vertices = graph
        .walk()
        .vertices(VertexSearch::scan())
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} total vertices in the graph", all_vertices.len());</code></pre>
<h3 id="using-a-label-index"><a class="header" href="#using-a-label-index">Using a Label Index</a></h3>
<p>For more efficient queries, use label-based indexes:</p>
<pre><code class="language-rust noplayground">    // Use a label-based index for more efficient lookups
    // This narrows the search to only person vertices
    let people = graph.walk().vertices(Vertex::person()).collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} person vertices", people.len());</code></pre>
<h3 id="property-based-filtering"><a class="header" href="#property-based-filtering">Property-Based Filtering</a></h3>
<p>Find vertices based on their properties:</p>
<pre><code class="language-rust noplayground">    // Use property-based filtering
    // This finds vertices with a specific property value
    let people_named_bob = graph
        .walk()
        .vertices(VertexSearch::scan())
        .filter_person() // First filter by vertex type
        .filter_by_person(|person, _| {
            // Then use type-safe accessor methods
            person.name() == "Julia"
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} people named Bob", people_named_bob.len());</code></pre>
<h3 id="combined-filtering"><a class="header" href="#combined-filtering">Combined Filtering</a></h3>
<p>Chain multiple conditions for complex queries:</p>
<pre><code class="language-rust noplayground">    // Combine filtering to find young people
    // Filter after retrieval when specialized indexes aren't available
    let young_people = graph
        .walk()
        .vertices(Vertex::person()) // Get all Person vertices
        .filter_by_person(|person, _| {
            // Use type-safe accessor methods
            person.age() &lt; 30 // Find people under 30
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} people under age 30", young_people.len());</code></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<ul>
<li>Start with the most specific index when possible instead of scanning all vertices</li>
<li>Use specialized indexes for frequently queried properties to improve performance</li>
<li>Combine multiple search criteria to narrow results early in the traversal</li>
<li>For ordered results, rely on range indexes rather than sorting later</li>
</ul>
<h2 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h2>
<ul>
<li><strong>Entity retrieval</strong>: Finding vertices of a specific type (e.g., all users, products, etc.)</li>
<li><strong>Initial selection</strong>: Starting traversals by selecting entry points based on criteria</li>
<li><strong>Filtered starting sets</strong>: Beginning with a targeted subset that matches complex conditions</li>
<li><strong>Index-driven queries</strong>: Leveraging custom indexes for specialized lookups based on specific properties</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vertices-by-id-step"><a class="header" href="#vertices-by-id-step">Vertices By ID Step</a></h1>
<p>The <code>vertices_by_id</code> step starts a traversal from a specific set of vertices identified by their IDs. This is typically the most efficient way to start a traversal when you know exactly which vertices you want to begin with.</p>
<object type="image/svg+xml" data="vertices_by_id/image.svg" title="Vertices By ID Step Diagram">
Vertices By ID step diagram showing selection of vertices based on specific IDs
</object>
<p>In this diagram:</p>
<ul>
<li>The <strong>Conceptual Graph Vertices</strong> represent available vertices V1 (id=1), V2 (id=2), V3 (id=3), and V4 (id=4).</li>
<li>The <strong><code>graph.walk().vertices_by_id([1, 3])</code></strong> step is applied, specifying IDs 1 and 3.</li>
<li>Pointers indicate that the step uses these IDs to look up the corresponding vertices (<strong>V1</strong> and <strong>V3</strong>) from the graph.</li>
<li>The <strong>Output Stream</strong> contains only the selected vertices <strong>V1</strong> and <strong>V3</strong>, which become the initial elements for the rest of the traversal.</li>
</ul>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<pre><code class="language-rust noplayground">graph.walk().vertices_by_id(ids)</code></pre>
<p>Where <code>ids</code> is an iterator yielding vertex IDs.</p>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<ul>
<li><code>ids</code>: An iterator yielding vertex IDs to include in the traversal</li>
</ul>
<h2 id="return-value-1"><a class="header" href="#return-value-1">Return Value</a></h2>
<p>Returns a new walker positioned at the vertices with the specified IDs.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<p>Start a traversal with specific vertex IDs:</p>
<pre><code class="language-rust noplayground">    // Start a traversal with specific vertex IDs
    let specific_vertices = graph
        .walk()
        .vertices_by_id(vec![bryn_id, julia_id])
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} specific vertices", specific_vertices.len());</code></pre>
<h3 id="following-relationships"><a class="header" href="#following-relationships">Following Relationships</a></h3>
<p>Start from a specific vertex and follow its relationships:</p>
<pre><code class="language-rust noplayground">    // Start with specific vertices and follow relationships
    let knows_relationships = graph
        .walk()
        .vertices_by_id(vec![bryn_id])
        .edges(Edge::follows().outgoing())
        .tail()
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Person knows {} other people", knows_relationships.len());</code></pre>
<h3 id="using-dynamically-collected-ids"><a class="header" href="#using-dynamically-collected-ids">Using Dynamically Collected IDs</a></h3>
<p>Use IDs collected from a previous traversal:</p>
<pre><code class="language-rust noplayground">    // Using dynamically collected IDs
    // First, find all project vertices
    let project_vertices = graph.walk().vertices(Vertex::project()).collect::&lt;Vec&lt;_&gt;&gt;();

    // Use those IDs to start a new traversal
    let projects = graph
        .walk()
        .vertices_by_id(project_vertices)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} projects using vertices_by_id", projects.len());</code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<ul>
<li>Prefer <code>vertices_by_id</code> over other methods when you already have the exact IDs</li>
<li>Be aware that invalid IDs are silently skipped rather than causing errors</li>
<li>Keep track of the original ID order if the order of results matters</li>
<li>Consider batching large ID collections for better performance in extensive traversals</li>
</ul>
<h2 id="common-use-cases-1"><a class="header" href="#common-use-cases-1">Common Use Cases</a></h2>
<ul>
<li><strong>Known entry points</strong>: Starting traversals from specific, known vertices</li>
<li><strong>Multi-stage traversals</strong>: Using the results of one traversal as the starting point for another</li>
<li><strong>External ID mapping</strong>: Starting from IDs provided by external systems or caches</li>
<li><strong>Selective subgraph processing</strong>: Working with a specific subset of vertices identified by ID</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edges-step"><a class="header" href="#edges-step">Edges Step</a></h1>
<p>The <code>edges</code> step traverses from vertices to their connecting edges, allowing navigation along relationships in the
graph. This step shifts the walker's position from vertices to their adjacent edges, transforming a stream of vertices into a stream of edges.</p>
<object type="image/svg+xml" data="edges/image.svg" title="Edges Step Diagram">
Edges step diagram showing traversal from a vertex to its outgoing edges
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains vertex <strong>A</strong>.</li>
<li>Vertex <strong>A</strong> has outgoing edges: <strong>A-&gt;B</strong> (likes) and <strong>A-&gt;C</strong> (created).</li>
<li>The <strong><code>.edges(EdgeSearch::scan())</code></strong> step processes vertex <strong>A</strong>.</li>
<li>The <strong>Output Stream</strong> contains the edge elements <strong>A-&gt;B</strong> and <strong>A-&gt;C</strong> connected to vertex A.</li>
</ul>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.edges(search_criteria)</code></pre>
<p>Where <code>search_criteria</code> is an <code>EdgeSearch</code> object or a predefined search from an index.</p>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<ul>
<li><code>search_criteria</code>: An <code>EdgeSearch</code> object that defines criteria for selecting edges, including:
<ul>
<li>Edge labels</li>
<li>Direction (incoming, outgoing, or both)</li>
<li>Property values (when supported)</li>
</ul>
</li>
</ul>
<h2 id="return-value-2"><a class="header" href="#return-value-2">Return Value</a></h2>
<p>Returns a new walker positioned at the edges matching the search criteria.</p>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<h3 id="finding-all-connected-edges"><a class="header" href="#finding-all-connected-edges">Finding All Connected Edges</a></h3>
<p>Get all edges connected to a vertex:</p>
<pre><code class="language-rust noplayground">    // Get all edges (both incoming and outgoing) from a vertex
    let all_connected_edges = graph
        .walk()
        .vertices_by_id([bryn])
        .edges(EdgeSearch::scan())
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(
        "Found {} total edges connected to Bryn",
        all_connected_edges.len()
    );</code></pre>
<h3 id="directional-edge-queries-1"><a class="header" href="#directional-edge-queries-1">Directional Edge Queries</a></h3>
<p>Specify whether you want incoming or outgoing edges:</p>
<pre><code class="language-rust noplayground">    // Get only outgoing edges from a vertex
    let outgoing_edges = graph
        .walk()
        .vertices_by_id([bryn])
        .edges(EdgeSearch::scan().outgoing())
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} outgoing edges from Bryn", outgoing_edges.len());

    // Get only incoming edges to a vertex
    let incoming_edges = graph
        .walk()
        .vertices_by_id([bryn])
        .edges(EdgeSearch::scan().incoming())
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} incoming edges to Bryn", incoming_edges.len());</code></pre>
<h3 id="label-based-edge-filtering-1"><a class="header" href="#label-based-edge-filtering-1">Label-Based Edge Filtering</a></h3>
<p>Filter edges by their label:</p>
<pre><code class="language-rust noplayground">    // Get only edges with a specific label
    // Using the label index is more efficient
    let created_edges = graph
        .walk()
        .vertices_by_id([bryn])
        .edges(Edge::created())
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} 'Created' edges for Bryn", created_edges.len());</code></pre>
<h3 id="combined-filtering-1"><a class="header" href="#combined-filtering-1">Combined Filtering</a></h3>
<p>Combine direction and label filtering:</p>
<pre><code class="language-rust noplayground">    // Combine direction and label filtering
    let outgoing_follows_edges = graph
        .walk()
        .vertices_by_id([bryn])
        .edges(Edge::follows().outgoing())
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Bryn follows {} people", outgoing_follows_edges.len());

    // Find incoming follows edges (people who follow Bryn)
    let incoming_follows_edges = graph
        .walk()
        .vertices_by_id([bryn])
        .edges(Edge::follows().incoming())
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("{} people follow Bryn", incoming_follows_edges.len());</code></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<ul>
<li>Specify the direction when possible to limit the search space</li>
<li>Use label-based indexes to avoid scanning all edges</li>
<li>Follow edges step with head() or tail() to continue vertex-based traversals</li>
<li>Consider the naming of relationships to match conceptual understanding</li>
</ul>
<h2 id="common-use-cases-2"><a class="header" href="#common-use-cases-2">Common Use Cases</a></h2>
<ul>
<li><strong>Relationship navigation</strong>: Moving from vertices to their connections</li>
<li><strong>Filtered relationships</strong>: Finding specific types of connections between vertices</li>
<li><strong>Direction-specific queries</strong>: Finding incoming or outgoing relationships</li>
<li><strong>Relationship property examination</strong>: Inspecting metadata on connections</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="head-step"><a class="header" href="#head-step">Head Step</a></h1>
<p>The <code>head</code> step navigates from edges to their <strong>target</strong> (destination) vertices, allowing traversal to where the edges point to. It transforms a stream of edges into a stream of vertices.</p>
<object type="image/svg+xml" data="head/image.svg" title="Head Step Diagram">
Head step diagram showing traversal from edge to target vertex
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains edge elements (e.g., <strong>A-&gt;B</strong>, <strong>C-&gt;D</strong>).</li>
<li>The <strong><code>.head()</code> step</strong> processes each edge.</li>
<li>The <strong>Output Stream</strong> contains the corresponding <strong>target (head) vertices</strong> (<strong>B</strong>, <strong>D</strong>) for each input edge.</li>
</ul>
<h2 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.head()</code></pre>
<h2 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h2>
<p>This step takes no parameters.</p>
<h2 id="return-value-3"><a class="header" href="#return-value-3">Return Value</a></h2>
<p>Returns a new walker positioned at the <strong>target</strong> vertices of the edges in the current traversal.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Find projects created by people known by a starting person:</p>
<pre><code class="language-rust noplayground">    // Find the projects created by people followed by the starting person
    let projects: Vec&lt;_&gt; = graph
        .walk()
        .vertices_by_id([start_person_id]) // Start at a specific person
        .edges(EdgeSearch::scan().outgoing()) // Follow outgoing edges
        .filter_follows() // Keep only 'Follows' edges
        .head() // Move to the target vertices (people followed by the start person)
        .edges(EdgeSearch::scan().outgoing()) // Follow outgoing edges from these people
        .filter_created() // Keep only 'Created' edges
        .head() // Move to the target vertices (projects created by known people)
        .collect();

    println!(
        "Projects created by people followed by the starting person ({:?}):",
        projects
    );</code></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<ul>
<li>Use <code>head()</code> to follow relationships in their natural direction (to the target).</li>
<li>Chain edge-head sequences for multi-hop traversals towards targets.</li>
<li>Maintain context information when necessary to preserve edge properties while moving to the target.</li>
<li>Consider traversal depth carefully in highly connected graphs when following edges.</li>
</ul>
<h2 id="common-use-cases-3"><a class="header" href="#common-use-cases-3">Common Use Cases</a></h2>
<ul>
<li><strong>Following relationships</strong>: Finding what vertices are connected <em>to</em> your starting points (targets).</li>
<li><strong>Multi-hop traversals</strong>: Discovering indirect connections through multiple relationships towards targets.</li>
<li><strong>Graph exploration</strong>: Navigating through the graph in a directed manner towards targets.</li>
<li><strong>Social network queries</strong>: Implementing patterns like "friends of friends" or "recommendations" by moving to targets.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tail-step"><a class="header" href="#tail-step">Tail Step</a></h1>
<p>The <code>tail</code> step navigates from edges to their <strong>source</strong> (origin) vertices, allowing traversal back to where the edges
start from. It transforms a stream of edges into a stream of vertices.</p>
<object type="image/svg+xml" data="tail/image.svg" title="Tail Step Diagram">
Tail step diagram showing traversal from edge to source vertex
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains edge elements (e.g., <strong>A-&gt;B</strong>, <strong>C-&gt;D</strong>).</li>
<li>The <strong><code>.tail()</code> step</strong> processes each edge.</li>
<li>The <strong>Output Stream</strong> contains the corresponding <strong>source (tail) vertices</strong> (<strong>A</strong>, <strong>C</strong>) for each input edge.</li>
</ul>
<h2 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.tail()</code></pre>
<h2 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h2>
<p>This step takes no parameters.</p>
<h2 id="return-value-4"><a class="header" href="#return-value-4">Return Value</a></h2>
<p>Returns a new walker positioned at the <strong>source</strong> vertices of the edges in the current traversal.</p>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="basic-tail-step"><a class="header" href="#basic-tail-step">Basic Tail Step</a></h3>
<p>Find people who created projects by getting back to the source vertex:</p>
<pre><code class="language-rust noplayground">    // Find projects created by people
    // 1. Start with all people
    // 2. Find "created" edges they made
    // 3. Use head() to get to the projects (the target vertices)
    let projects = graph
        .walk()
        .vertices(Vertex::person())
        .edges(Edge::created().outgoing())
        .head() // Move to the target vertex of the edge
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} projects created by people", projects.len());</code></pre>
<h3 id="multi-step-traversal-1"><a class="header" href="#multi-step-traversal-1">Multi-Step Traversal</a></h3>
<p>Traverse multiple relationships to find indirect connections:</p>
<pre><code class="language-rust noplayground">    // Find people who follow someone who created a project
    // This demonstrates chaining head and tail multiple times
    let indirect_creators = graph
        .walk()
        .vertices(Vertex::person())
        .edges(Edge::follows().outgoing())
        .tail() // Move to the people they follow
        .edges(Edge::created().outgoing())
        .tail() // Move to the projects created by those people
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(
        "Found {} projects created by people the original people know",
        indirect_creators.len()
    );</code></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<ul>
<li>Always follow edge traversals with either <code>head()</code> or <code>tail()</code> to return to vertices.</li>
<li>Use contexts to retain information about the edge when moving back to the source vertex via <code>tail()</code>.</li>
<li>Remember that <code>tail()</code> returns the <strong>source</strong> vertex (where the edge starts).</li>
<li>For retrieving both endpoints, consider using context to store one while visiting the other.</li>
</ul>
<h2 id="common-use-cases-4"><a class="header" href="#common-use-cases-4">Common Use Cases</a></h2>
<ul>
<li><strong>Author identification</strong>: Finding who created something by looking at edge sources (<code>tail()</code>).</li>
<li><strong>Relationship sources</strong>: Identifying the initiators of connections (<code>tail()</code>).</li>
<li><strong>Backtracking</strong>: Returning to source vertices after examining edges (<code>tail()</code>).</li>
<li><strong>Edge-based filtering</strong>: Finding vertices that have specific <em>incoming</em> edges (by traversing the edge and using
<code>tail()</code>).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filter-step"><a class="header" href="#filter-step">Filter Step</a></h1>
<p>The <code>filter</code> step narrows a traversal by keeping only vertices or edges that match a specified predicate.</p>
<object type="image/svg+xml" data="filter/image.svg" title="Filter Step Diagram">
Filter step diagram showing elements being kept or discarded based on a predicate
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains elements <strong>A</strong> (age=35), <strong>B</strong> (age=25), and <strong>C</strong> (age=40).</li>
<li>The <strong><code>.filter(|v| v.age &gt; 30)</code></strong> step processes each element, applying the predicate.</li>
<li>Elements <strong>A</strong> and <strong>C</strong> satisfy the predicate (age &gt; 30) and pass through to the <strong>Output Stream</strong>.</li>
<li>Element <strong>B</strong> does not satisfy the predicate and is <strong>Discarded</strong>, marked with an 'X'.</li>
</ul>
<h2 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.filter(|element, context| /* predicate logic */)</code></pre>
<h2 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h2>
<ul>
<li><code>predicate</code>: A function that takes a reference to a graph element and optional context, and returns a boolean.
<ul>
<li>Returns <code>true</code> to keep the element in the traversal</li>
<li>Returns <code>false</code> to remove it from the traversal</li>
</ul>
</li>
</ul>
<h2 id="return-value-5"><a class="header" href="#return-value-5">Return Value</a></h2>
<p>Returns a new walker containing only the elements that match the predicate.</p>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="basic-filter"><a class="header" href="#basic-filter">Basic Filter</a></h3>
<p>Filter vertices based on a simple condition:</p>
<pre><code class="language-rust noplayground">    // Basic filter using a closure
    let adult_people = graph
        .walk()
        .vertices(Vertex::person())
        .filter_by_person(|person, _| person.age() &gt;= 18)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} adults", adult_people.len());</code></pre>
<h3 id="type-specific-filtering"><a class="header" href="#type-specific-filtering">Type-Specific Filtering</a></h3>
<p>Use the type-specific filter methods generated by derive macros:</p>
<pre><code class="language-rust noplayground">    // Use the type-specific filter methods generated by the VertexExt derive macro
    let people_named_b = graph
        .walk()
        .vertices(Vertex::person())
        .filter_by_person(|person, _| {
            // This closure gets a strongly-typed view of the Person data
            person.name().starts_with('B')
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(
        "Found {} people whose names start with B",
        people_named_b.len()
    );</code></pre>
<h3 id="chained-filters"><a class="header" href="#chained-filters">Chained Filters</a></h3>
<p>Combine multiple filters for complex queries:</p>
<pre><code class="language-rust noplayground">    // Chain multiple filters for complex conditions
    let specific_people = graph
        .walk()
        .vertices(Vertex::person())
        // First filter: age range
        .filter_by_person(|person, _| person.age() &gt; 25 &amp;&amp; person.age() &lt; 40)
        // Second filter: name contains 'y'
        .filter_by_person(|person, _| person.name().contains('y'))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(
        "Found {} people aged 26-39 with 'y' in their name",
        specific_people.len()
    );</code></pre>
<h3 id="filter-with-context"><a class="header" href="#filter-with-context">Filter with Context</a></h3>
<p>Filter based on context information:</p>
<pre><code class="language-rust noplayground">    // Use filter with context
    let result = graph
        .walk()
        .vertices(Vertex::person())
        .push_context(|v, _| {
            // Store original vertex in context
            if let Some(person) = v.project::&lt;Person&lt;_&gt;&gt;() {
                person.name().to_string()
            } else {
                String::new()
            }
        })
        .filter(|_, ctx| {
            // Filter based on context
            ctx.len() &gt; 3
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(
        "Found {} people with names longer than 3 characters",
        result.len()
    );</code></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<ul>
<li>Prefer indexed searches over filter steps when querying by property values</li>
<li>Break complex filtering logic into multiple chained filters for readability</li>
<li>Use pattern matching to handle different vertex or edge types correctly</li>
<li>Leverage generated filter methods from derive macros for stronger type safety</li>
</ul>
<h2 id="common-use-cases-5"><a class="header" href="#common-use-cases-5">Common Use Cases</a></h2>
<ul>
<li><strong>Post-retrieval refinement</strong>: Filtering elements after initial selection when indexes don't fully cover criteria</li>
<li><strong>Dynamic filtering</strong>: Applying runtime conditions that can't be encoded in initial searches</li>
<li><strong>Complex conditions</strong>: Implementing filtering logic that combines multiple properties or calculations</li>
<li><strong>Context-aware filtering</strong>: Using information from previous traversal steps to inform filtering decisions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controlflow-step"><a class="header" href="#controlflow-step">ControlFlow Step</a></h1>
<p>The <code>control_flow</code> step provides precise control over traversal by evaluating each element with a predicate that returns a <code>std::ops::ControlFlow</code> value. This allows for both filtering and conditional traversal termination in a single operation.</p>
<object type="image/svg+xml" data="control_flow/image.svg" title="ControlFlow Step Diagram">
ControlFlow step diagram showing elements being kept, skipped, or causing traversal termination
</object>
<p>In this diagram:</p>
<ul>
<li><strong>Before <code>control_flow()</code></strong>: The walker contains all highlighted vertices <strong>A</strong>, <strong>B</strong>, and <strong>C</strong>.</li>
<li>The <strong><code>.control_flow(predicate)</code></strong> step is applied, which makes decisions for each vertex:
<ul>
<li>Continue and keep the vertex (Vertex <strong>B</strong>)</li>
<li>Continue but skip the vertex (Vertex <strong>A</strong>, which is faded)</li>
<li>Break traversal and optionally keep a final vertex (Vertex <strong>C</strong>, which terminates the traversal)</li>
</ul>
</li>
</ul>
<h2 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.control_flow(|element, context| /* control flow logic */)</code></pre>
<h2 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h2>
<ul>
<li><code>predicate</code>: A function that takes a reference to a graph element and a mutable reference to its context, and returns a <code>std::ops::ControlFlow</code> value:
<ul>
<li><code>ControlFlow::Continue(Some(element))</code>: Include the element and continue traversal</li>
<li><code>ControlFlow::Continue(None)</code>: Skip the element and continue traversal</li>
<li><code>ControlFlow::Break(Some(element))</code>: Include the element and stop traversal</li>
<li><code>ControlFlow::Break(None)</code>: Stop traversal without including any more elements</li>
</ul>
</li>
</ul>
<h2 id="return-value-6"><a class="header" href="#return-value-6">Return Value</a></h2>
<p>Returns a new walker that applies the control flow logic to the traversal.</p>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<h3 id="vertex-control-flow"><a class="header" href="#vertex-control-flow">Vertex Control Flow</a></h3>
<pre><code class="language-rust noplayground">    // Use control_flow to either skip a vertex (None), include it (Some), or stop traversal (Break)
    let _project = graph
        .walk()
        .vertices(VertexSearch::scan())
        .control_flow(|vertex, _| {
            if let Vertex::Project { name } = vertex.weight() {
                // If we find a project with "Graph" in the name, stop traversal
                if name.contains("Graph") {
                    return ControlFlow::Break(Some(vertex));
                }
                // Include other project vertices
                return ControlFlow::Continue(Some(vertex));
            }
            // Skip non-project vertices
            ControlFlow::Continue(None)
        })
        .first();</code></pre>
<h3 id="edge-control-flow"><a class="header" href="#edge-control-flow">Edge Control Flow</a></h3>
<pre><code class="language-rust noplayground">    // Use control_flow to skip edges (None), include them (Some), or stop traversal (Break)
    let _early_connection = graph
        .walk()
        .vertices_by_id(vec![start_id])
        .edges(EdgeSearch::scan())
        .control_flow(|edge, _| {
            if let Edge::Follows = edge.weight() {
                // With Follows edge type, always break
                return ControlFlow::Break(Some(edge));
            }
            // Skip non-'follows' edges
            ControlFlow::Continue(None)
        })
        .first();</code></pre>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<ul>
<li>Use <code>control_flow</code> when you need to conditionally terminate traversal based on finding specific elements</li>
<li>Prefer <code>filter</code> for simple inclusion/exclusion if you don't need to stop traversal</li>
<li>Use the context parameter to track state or accumulate data during traversal</li>
<li>Return <code>Break</code> as soon as you find what you're looking for to optimize performance</li>
</ul>
<h2 id="common-use-cases-6"><a class="header" href="#common-use-cases-6">Common Use Cases</a></h2>
<ul>
<li><strong>Early termination</strong>: Stop traversal as soon as a match is found</li>
<li><strong>Conditional processing</strong>: Apply different logic based on element properties</li>
<li><strong>Limited collection</strong>: Gather elements until a specific condition is met</li>
<li><strong>State-driven traversal</strong>: Use context to make decisions based on previously seen elements</li>
<li><strong>Performance optimization</strong>: Avoid unnecessary traversal when a sufficient result is found</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-step"><a class="header" href="#map-step">Map Step</a></h1>
<p>The <code>map</code> step transforms vertices or edges in the traversal by applying a mapping function, returning a standard Rust iterator over the transformed elements. This is a terminal step that consumes the walker and ends the Graph API traversal chain.</p>
<object type="image/svg+xml" data="map/image.svg" title="Map Step Diagram">
Map step diagram showing elements being transformed into values in an iterator
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains elements <strong>A, B, C</strong>.</li>
<li>The <strong><code>.map(|v| v.name())</code></strong> step processes each element, applying the transformation function.</li>
<li>The output is represented as a <strong>Rust Iterator</strong> box, containing the resulting values (e.g., <code>"NameA"</code>, <code>"NameB"</code>, <code>"NameC"</code>).</li>
<li>The diagram indicates that this step <strong>Terminates Walker</strong>, meaning no further Graph API steps can be chained after <code>map</code>. Standard Rust iterator methods can be used on the result.</li>
</ul>
<h2 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.map(|element, context| {
    // transformation logic
})</code></pre>
<h2 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h2>
<ul>
<li><code>mapping</code>: A function that takes:
<ul>
<li>A reference to the current element (vertex or edge)</li>
<li>The element's context</li>
<li>Returns a transformed value</li>
</ul>
</li>
</ul>
<h2 id="return-value-7"><a class="header" href="#return-value-7">Return Value</a></h2>
<p>Returns an iterator that yields the transformed elements. The type of the iterator items is determined by the return
type of the mapping function.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-rust noplayground">pub fn map_example() {
    // Stub example - to be implemented
}</code></pre>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<ul>
<li>Structure your mapping logic to handle all expected element types and properties</li>
<li>Use pattern matching in your mapping function to handle different vertex or edge types</li>
<li>Leverage context data for transformations that require information from previous steps</li>
<li>Chain standard iterator methods after mapping to further refine results</li>
</ul>
<h2 id="common-use-cases-7"><a class="header" href="#common-use-cases-7">Common Use Cases</a></h2>
<ul>
<li><strong>Property extraction</strong>: Transforming graph elements into specific properties or attributes</li>
<li><strong>Type conversion</strong>: Converting graph elements into domain-specific data structures</li>
<li><strong>Data aggregation</strong>: Creating composite values from multiple element properties</li>
<li><strong>Format transformation</strong>: Preparing graph data for serialization or external systems</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fold-step"><a class="header" href="#fold-step">Fold Step</a></h1>
<p>The <code>fold</code> step accumulates a result by processing each element in a traversal, operating like the standard Rust <code>fold</code> operation but specifically for graph traversals. It's a powerful terminal operation that builds a single value from all elements in the stream.</p>
<object type="image/svg+xml" data="fold/image.svg" title="Fold Step Diagram">
Fold step diagram showing accumulation of values from traversal elements
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains elements <strong>A</strong> (age=30), <strong>B</strong> (age=25), and <strong>C</strong> (age=40).</li>
<li>The <strong><code>.fold(0, |acc, v| acc + v.age())</code></strong> step is applied. It starts with an initial accumulator value of <code>0</code>.</li>
<li>The <strong>Accumulator</strong> visualization shows the value being updated as each element is processed:
<ul>
<li>Initial: <code>0</code></li>
<li>After A: <code>0 + 30 = 30</code></li>
<li>After B: <code>30 + 25 = 55</code></li>
<li>After C: <code>55 + 40 = 95</code></li>
</ul>
</li>
<li>The <strong>Final Result</strong> box shows the final accumulated value (<code>95</code>).</li>
<li>This step <strong>Terminates Walker</strong>, meaning no further Graph API steps can be chained after <code>fold</code>.</li>
</ul>
<h2 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.fold(initial_value, |accumulator, element, context| {
    // accumulation logic
})</code></pre>
<h2 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h2>
<ul>
<li><code>initial_value</code>: The starting value for the accumulator</li>
<li><code>f</code>: A closure that takes:
<ul>
<li>The current accumulator value</li>
<li>A reference to the current element (vertex or edge)</li>
<li>The current element's context</li>
<li>Returns the updated accumulator value</li>
</ul>
</li>
</ul>
<h2 id="return-value-8"><a class="header" href="#return-value-8">Return Value</a></h2>
<p>Returns the final accumulated value after processing all elements in the traversal.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><code class="language-rust noplayground">pub fn fold_example() {
    // Create a graph with standard test data
    let graph = standard_populated_graph();

    // Calculate the sum of ages of all people using fold
    let total_age = graph
        .walk()
        .vertices(VertexSearch::scan())
        .filter_person()
        .fold(0, |acc, vertex, _ctx| {
            // Add the person's age to the accumulator
            if let Some(person) = vertex.project::&lt;Person&lt;_&gt;&gt;() {
                acc + person.age() as u32
            } else {
                acc
            }
        });

    println!("Total age of all people: {}", total_age);

    // Example with context: Collect names of people older than the context age
    let initial_age_threshold = 30;
    let names_older_than_threshold = graph
        .walk()
        .vertices(VertexSearch::scan())
        .filter_person()
        .push_context(|_, _| initial_age_threshold) // Push the threshold as context
        .fold(Vec::new(), |mut names, vertex, ctx| {
            if let Some(person) = vertex.project::&lt;Person&lt;_&gt;&gt;() {
                // Use context (threshold) in the fold logic
                if person.age() as u32 &gt; **ctx {
                    names.push(person.name().to_string());
                }
            }
            names
        });

    println!(
        "Names of people older than {}: {:?}",
        initial_age_threshold, names_older_than_threshold
    );
}</code></pre>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<ul>
<li>Choose an appropriate initial value that handles edge cases (empty traversals)</li>
<li>Design fold closures to be commutative when possible for predictable results</li>
<li>Use type annotations for complex accumulator types to improve readability</li>
<li>Consider specialized steps like <code>count()</code> when their behavior matches your needs</li>
</ul>
<h2 id="common-use-cases-8"><a class="header" href="#common-use-cases-8">Common Use Cases</a></h2>
<ul>
<li><strong>Aggregation</strong>: Calculating sums, averages, or other numerical aggregates</li>
<li><strong>Collection building</strong>: Creating custom collections or data structures from traversal results</li>
<li><strong>State tracking</strong>: Building a final state that incorporates data from all elements</li>
<li><strong>Custom reductions</strong>: Implementing specialized reduction operations not covered by built-in steps</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reduce-step"><a class="header" href="#reduce-step">Reduce Step</a></h1>
<p>The <code>reduce</code> step combines all elements in a traversal using a binary operation, returning a single result element. It repeatedly applies a function to pairs of elements, keeping one from each pair, until only one element remains.</p>
<object type="image/svg+xml" data="reduce/image.svg" title="Reduce Step Diagram">
Reduce step diagram showing pairwise comparison reducing elements to a single result
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains elements <strong>A</strong> (age=30), <strong>B</strong> (age=25), and <strong>C</strong> (age=40).</li>
<li>The <strong><code>.reduce(|acc, v| ...)</code></strong> step is applied, using a reducer function that keeps the element with the maximum age.</li>
<li>The <strong>Reduction Process</strong> visualization shows the pairwise comparisons:
<ul>
<li><strong>A vs B</strong>: Element <strong>A</strong> is kept (30 &gt; 25), <strong>B</strong> is discarded.</li>
<li><strong>(A) vs C</strong>: Element <strong>C</strong> is kept (40 &gt; 30), <strong>A</strong> is discarded.</li>
</ul>
</li>
<li>The <strong>Result</strong> of the reduction process is the single remaining element (<strong>C</strong>), which continues in the walker chain.</li>
</ul>
<h2 id="syntax-9"><a class="header" href="#syntax-9">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.reduce(|accumulated, next_element, context| {
    // combine elements and return either accumulated or next_element
})</code></pre>
<h2 id="parameters-9"><a class="header" href="#parameters-9">Parameters</a></h2>
<ul>
<li><code>reducer</code>: A function that takes:
<ul>
<li>The accumulated element from previous reduction steps</li>
<li>The next element to be considered</li>
<li>The parent walker's context (immutable)</li>
<li>Returns a ControlFlow with either the accumulated or next element</li>
</ul>
</li>
</ul>
<h2 id="return-value-9"><a class="header" href="#return-value-9">Return Value</a></h2>
<p>Returns an <code>Option</code> containing the result element if the traversal is not empty, or <code>None</code> if the traversal is empty.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><code class="language-rust noplayground">use crate::standard_model::{Person, VertexExt, standard_populated_graph};
use graph_api_lib::{Graph, VertexReference, VertexSearch};

pub fn reduce_example() {
    // Create a graph with standard test data
    let graph = standard_populated_graph();

    // Find the oldest person in the graph using reduce
    let oldest = graph
        .walk()
        .vertices(VertexSearch::scan())
        .filter_person()
        .reduce(|acc, vertex, _ctx| {
            let acc_age = if let Some(person) = acc.project::&lt;Person&lt;_&gt;&gt;() {
                person.age()
            } else {
                0
            };
            let vertex_age = if let Some(person) = vertex.project::&lt;Person&lt;_&gt;&gt;() {
                person.age()
            } else {
                0
            };

            // Return the person with higher age
            if vertex_age &gt; acc_age { vertex } else { acc }
        })
        .map(|vertex, _ctx| {
            if let Some(person) = vertex.project::&lt;Person&lt;_&gt;&gt;() {
                format!(
                    "The oldest person is {:?}, age {}",
                    vertex.id(),
                    person.age()
                )
            } else {
                format!("Unexpected non-person vertex: {:?}", vertex.id())
            }
        })
        .next()
        .expect("Should find at least one person");

    println!("{}", oldest);
}</code></pre>
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<ul>
<li>Design reducers that follow associative properties when possible</li>
<li>Handle empty traversals by checking for None in the result</li>
<li>The reducer can only select one of the elements, not create new ones</li>
<li>Use <code>ControlFlow::Continue</code> to keep reducing, and <code>ControlFlow::Break</code> to halt early</li>
<li>Consider <code>fold</code> instead when you need to build a new value rather than select among elements (note: <code>fold</code> terminates the walker)</li>
<li>Remember that unlike the old API, the context is immutable in the reducer function</li>
</ul>
<h2 id="common-use-cases-9"><a class="header" href="#common-use-cases-9">Common Use Cases</a></h2>
<ul>
<li><strong>Extrema finding</strong>: Selecting maximum or minimum elements by some property</li>
<li><strong>Best match selection</strong>: Choosing the most relevant element from a set of results</li>
<li><strong>Representative selection</strong>: Picking a single representative element from similar options</li>
<li><strong>Priority determination</strong>: Finding highest/lowest priority elements in a graph</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="take-step"><a class="header" href="#take-step">Take Step</a></h1>
<p>The <code>take</code> step restricts a traversal to return at most a specified number of elements, helping to control result size
and improve performance.</p>
<object type="image/svg+xml" data="take/image.svg" title="Take Step Diagram">
Take step diagram showing traversal stopping after a specified number of elements
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains elements <strong>A, B, C, D</strong>.</li>
<li>The <strong><code>.take(2)</code> step</strong> acts like a gate, processing elements sequentially.</li>
<li>Only the first two elements, <strong>A</strong> and <strong>B</strong>, pass through to the <strong>Output Stream</strong>.</li>
<li>Elements <strong>C</strong> and <strong>D</strong> are <strong>Discarded</strong> because the limit of 2 was reached. The traversal stops after yielding the second element.</li>
</ul>
<h2 id="syntax-10"><a class="header" href="#syntax-10">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.take(n)</code></pre>
<h2 id="parameters-10"><a class="header" href="#parameters-10">Parameters</a></h2>
<ul>
<li><code>n</code>: A <code>usize</code> value specifying the maximum number of elements the traversal should return</li>
</ul>
<h2 id="return-value-10"><a class="header" href="#return-value-10">Return Value</a></h2>
<p>Returns a new walker that will yield at most <code>n</code> elements.</p>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre><code class="language-rust noplayground">    // Get the first 2 people in the graph
    println!("First 2 people in the graph:");
    let people = graph
        .walk()
        .vertices(Vertex::person())
        .take(2) // Only take the first 2 vertices
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for person in &amp;people {
        println!("  - {:?}", person);
    }
    println!("Found {} people (limited to 2)", people.len());</code></pre>
<h3 id="with-filtering"><a class="header" href="#with-filtering">With Filtering</a></h3>
<pre><code class="language-rust noplayground">    // Get up to 3 people over the age of 30
    println!("\nUp to 3 people over 30:");
    let older_people = graph
        .walk()
        .vertices(Vertex::person()) // Get all Person vertices
        .filter_by_person(|person, _| {
            // Using the typed projection with accessor methods
            person.age() &gt; 30
        })
        .take(3) // Only take up to 3 matches
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for person in &amp;older_people {
        println!("  - {:?}", person);
    }
    println!("Found {} people (limited to 3)", older_people.len());</code></pre>
<h3 id="edge-traversal-example"><a class="header" href="#edge-traversal-example">Edge Traversal Example</a></h3>
<pre><code class="language-rust noplayground">    // Find the first 2 connections from the first person
    if let Some(first_person) = graph.walk().vertices(Vertex::person()).first() {
        println!("\nFirst 2 connections from a person:");

        let connections = graph
            .walk()
            .vertices_by_id([first_person])
            .edges(EdgeSearch::scan()) // All edge types
            .take(2) // Only take the first 2 edges
            .collect::&lt;Vec&lt;_&gt;&gt;();

        for edge in &amp;connections {
            println!("  - {:?}", edge);
        }
        println!("Found {} connections (limited to 2)", connections.len());
    }</code></pre>
<h2 id="best-practices-15"><a class="header" href="#best-practices-15">Best Practices</a></h2>
<ul>
<li>Use <code>take</code> early in the traversal chain to reduce computation on intermediate steps</li>
<li>Combine with ordered indexes when sequence matters to ensure consistent results</li>
<li>For single element retrieval, prefer the more idiomatic <code>first()</code> over <code>take(1)</code></li>
<li>Set conservative limits when exploring large graphs to prevent memory issues</li>
</ul>
<h2 id="common-use-cases-10"><a class="header" href="#common-use-cases-10">Common Use Cases</a></h2>
<ul>
<li><strong>Performance optimization</strong>: Restricting result size for large graph traversals</li>
<li><strong>Pagination</strong>: Implementing "page-by-page" data retrieval when combined with skip/offset mechanisms</li>
<li><strong>Top-N queries</strong>: Getting the first N elements matching certain criteria</li>
<li><strong>Resource control</strong>: Preventing excessive memory or processing use in production systems</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-step"><a class="header" href="#first-step">First Step</a></h1>
<p>The <code>first</code> step consumes the walker and returns the <strong>ID</strong> of the very first element encountered in the traversal stream, wrapped in an <code>Option</code>. If the stream is empty, it returns <code>None</code>. This is a <strong>terminal</strong> operation that efficiently short-circuits the traversal as soon as the first element is found.</p>
<object type="image/svg+xml" data="first/image.svg" title="First Step Diagram">
First step diagram showing elements flowing into the step, only the first being considered, and an Option<ID> as the output
</object>
<p>In this diagram:</p>
<ul>
<li><strong>Input Elements</strong>: The walker starts with elements <strong>A, B, C, D</strong>.</li>
<li>The <strong><code>.first()</code></strong> step processes the stream, immediately takes element <strong>A</strong>, and consumes the walker. Elements B, C, and D are never processed or considered.</li>
<li><strong>Returns: Option&lt;ID&gt;</strong>: The step returns <code>Some(ID(A))</code>, containing the ID of the first element found.</li>
<li><strong>Terminates Walker</strong>: This step ends the Graph API walker chain.</li>
</ul>
<h2 id="syntax-11"><a class="header" href="#syntax-11">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.first()</code></pre>
<h2 id="parameters-11"><a class="header" href="#parameters-11">Parameters</a></h2>
<p>This step takes no parameters.</p>
<h2 id="return-value-11"><a class="header" href="#return-value-11">Return Value</a></h2>
<p>Returns an <code>Option</code> containing the first element from the traversal, or <code>None</code> if the traversal is empty.</p>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<h3 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h3>
<p>Retrieve the first person vertex from the graph:</p>
<pre><code class="language-rust noplayground">    // Get the first person in the graph (if any)
    let first_person = graph.walk().vertices(Vertex::person()).first();

    match first_person {
        Some(person) =&gt; println!("Found a person: {:?}", person),
        None =&gt; println!("No people in the graph"),
    }</code></pre>
<h3 id="with-filtering-1"><a class="header" href="#with-filtering-1">With Filtering</a></h3>
<p>Get the first person matching specific criteria:</p>
<pre><code class="language-rust noplayground">    // Get the first person with a specific name
    let first_bryn = graph
        .walk()
        .vertices(Vertex::person()) // Get all Person vertices
        .filter_by_person(|person, _| {
            // Using the typed projection with accessor methods
            person.name().contains("Bryn")
        })
        .first();

    match first_bryn {
        Some(bryn) =&gt; println!("Found Bryn: {:?}", bryn),
        None =&gt; println!("No one named Bryn in the graph"),
    }</code></pre>
<h3 id="existence-check"><a class="header" href="#existence-check">Existence Check</a></h3>
<p>Check if any elements match a condition:</p>
<pre><code class="language-rust noplayground">    // Use first to check if any element matches a condition
    let has_young_person = graph
        .walk()
        .vertices(Vertex::person())
        .filter_by_person(|person, _| {
            // Using type-safe accessor methods
            person.age() &lt; 30
        })
        .first()
        .is_some();

    println!(
        "Graph {} people under 30",
        if has_young_person {
            "contains"
        } else {
            "doesn't contain"
        }
    );</code></pre>
<h2 id="best-practices-16"><a class="header" href="#best-practices-16">Best Practices</a></h2>
<ul>
<li>Always handle the <code>None</code> case when using <code>first()</code> on potentially empty traversals</li>
<li>Use filtering before <code>first()</code> to ensure you get the element you want</li>
<li>For deterministic results, combine with ordered indexes or explicit sorting</li>
<li>Prefer <code>first()</code> over <code>limit(1).collect::&lt;Vec&lt;_&gt;&gt;()</code> for better performance</li>
</ul>
<h2 id="common-use-cases-11"><a class="header" href="#common-use-cases-11">Common Use Cases</a></h2>
<ul>
<li><strong>Single element retrieval</strong>: Getting exactly one element matching specific criteria</li>
<li><strong>Existence checking</strong>: Determining if any elements match a condition with <code>is_some()</code></li>
<li><strong>Quick lookup</strong>: Finding a representative example of a vertex or edge type</li>
<li><strong>Early termination</strong>: Efficiently stopping traversal after finding the first match</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>The <code>push_context</code> step allows you to carry information along a graph traversal, making it possible to access data from
previous steps while working with the current element. Context creates a typed value that travels with the traversal
without changing its position.</p>
<object type="image/svg+xml" data="context/image.svg" title="Push Context Step Diagram">
Context step diagram showing a fixed context value being attached to elements
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains elements <strong>A</strong> and <strong>B</strong>.</li>
<li>The <strong><code>.push_context(|v| v.id())</code></strong> step is applied. The context function (e.g., <code>|v| v.id()</code>) is evaluated <em>once</em> when the step is encountered (conceptually, when element <strong>A</strong> is processed).</li>
<li>The resulting context value (e.g., <code>"A_ID"</code>) is then attached to <strong>all</strong> subsequent elements (<strong>A</strong> and <strong>B</strong>) in the <strong>Output Stream</strong>.</li>
<li>This demonstrates that the context value is determined when the <code>push_context</code> step is applied and remains fixed for the rest of that traversal segment.</li>
</ul>
<h2 id="methods-for-adding-context"><a class="header" href="#methods-for-adding-context">Methods for Adding Context</a></h2>
<pre><code class="language-rust noplayground">// Adding context to a traversal
walker.push_context(|element, current_context| {
    // Create and return new context value
})

// Adding current vertex/edge as context
walker.push_default_context()</code></pre>
<h2 id="parameters-12"><a class="header" href="#parameters-12">Parameters</a></h2>
<ul>
<li><code>context_fn</code>: A function that takes:
<ul>
<li>A reference to the current element (vertex or edge)</li>
<li>The current context (if any)</li>
<li>Returns a new context value to be carried along the traversal</li>
</ul>
</li>
</ul>
<h2 id="return-value-12"><a class="header" href="#return-value-12">Return Value</a></h2>
<p>Returns a new walker with the context added, preserving the current traversal position.</p>
<h2 id="accessing-context"><a class="header" href="#accessing-context">Accessing Context</a></h2>
<p>Any step that accepts a function with context (like <code>map</code>, <code>filter</code>, etc.) will receive:</p>
<ul>
<li>The current element as the first parameter</li>
<li>The context as the second parameter</li>
</ul>
<pre><code class="language-rust noplayground">// Using context in a map step
walker
    .push_context(|v, _| v.id())  // Store vertex ID
    .map(|current, context| {
        // Use the stored vertex ID from context
        format!("Current: {}, Source: {}", current.id(), context)
    })</code></pre>
<h2 id="examples-10"><a class="header" href="#examples-10">Examples</a></h2>
<h3 id="vertex-context"><a class="header" href="#vertex-context">Vertex Context</a></h3>
<p>Store information about the source vertex during a traversal:</p>
<pre><code class="language-rust noplayground">    // Use push_default_context to make source vertex information available during traversal
    let knows: Vec&lt;_&gt; = graph
        .walk()
        .vertices_by_id(vec![bryn_id, julia_id])
        .push_default_context()
        .edges(EdgeSearch::scan().outgoing())
        .filter_follows()
        .head()
        .map(|target, ctx| {
            if let Vertex::Person { name, .. } = ctx.vertex() {
                format!(
                    "{} follows {}",
                    name,
                    target.project::&lt;Person&lt;_&gt;&gt;().unwrap().name()
                )
            } else {
                "Not a person".to_string()
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // Check the results - should have 2 person descriptions
    assert_eq!(knows.len(), 2);
    println!("Vertex Context Example - Relationships found:");
    for relationship in &amp;knows {
        println!("- {}", relationship);
    }</code></pre>
<h3 id="edge-context"><a class="header" href="#edge-context">Edge Context</a></h3>
<p>Track edge types during traversal:</p>
<pre><code class="language-rust noplayground">    // Walk the graph starting from the person vertex
    let edge_types = graph
        .walk()
        .vertices_by_id(vec![person_id])
        .edges(EdgeSearch::scan().outgoing())
        .push_context(|edge, _ctx| {
            // Determine edge type based on the edge type
            let edge_type = match edge.weight() {
                Edge::Created =&gt; "Created",
                Edge::Follows =&gt; "Follows",
                Edge::Liked { .. } =&gt; "Liked",
                Edge::Commented { .. } =&gt; "Commented",
            };

            // Return the edge type as context
            edge_type
        })
        .map(|_v, c| *c)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("{:?}", edge_types);</code></pre>
<h3 id="path-tracking"><a class="header" href="#path-tracking">Path Tracking</a></h3>
<p>Build a representation of the path taken during traversal:</p>
<pre><code class="language-rust noplayground">    // Track the path while traversing
    let paths = graph
        .walk()
        .vertices_by_id(vec![start_id])
        // Start with an empty path containing just the start vertex name
        .push_context(|v, _| {
            vec![match v.weight() {
                Vertex::Person { name, .. } =&gt; name.clone(),
                _ =&gt; "Unknown".to_string(),
            }]
        })
        // Follow outgoing follows edges
        .edges(EdgeSearch::scan().outgoing())
        .filter_follows()
        .tail()
        // Add each person to the path
        .push_context(|v, ctx| {
            let mut new_path = (**ctx).clone();
            if let Vertex::Person { name, .. } = v.weight() {
                new_path.push(name.clone());
            }
            new_path
        })
        // Collect all paths
        .map(|_, ctx| ctx.join(" -&gt; "))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // Print all paths
    println!("All paths from start:");
    for path in paths {
        println!("- {}", path);
    }</code></pre>
<h2 id="type-safety"><a class="header" href="#type-safety">Type Safety</a></h2>
<p>The context system is fully type-safe:</p>
<ul>
<li>Each context value has a concrete type</li>
<li>Context transformation functions must return the correct type</li>
<li>Closures that receive context are provided with the correctly typed context</li>
</ul>
<h2 id="common-use-cases-12"><a class="header" href="#common-use-cases-12">Common Use Cases</a></h2>
<ul>
<li><strong>Path tracking</strong>: Store the sequence of vertices or edges traversed</li>
<li><strong>Metadata collection</strong>: Gather information from different parts of the graph</li>
<li><strong>Aggregation</strong>: Build up composite results during traversal</li>
<li><strong>Decision making</strong>: Use information from earlier steps to influence later decisions</li>
</ul>
<h2 id="best-practices-17"><a class="header" href="#best-practices-17">Best Practices</a></h2>
<ul>
<li>Keep contexts immutable - create new contexts rather than modifying existing ones</li>
<li>Use <code>push_default_context()</code> when you simply need to track the current vertex/edge</li>
<li>Chain multiple context operations to build complex data structures</li>
<li>Consider type-safety when designing context pipelines</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-context"><a class="header" href="#default-context">Default Context</a></h1>
<p>The <code>push_default_context</code> step provides a simplified way to track vertex and edge information during traversal, without
having to define custom context types. It automatically captures the current vertex or edge to make it available in
downstream steps.</p>
<object type="image/svg+xml" data="default_context/image.svg" title="Push Default Context Step Diagram">
Default Context step diagram showing the context automatically tracking the current element
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains elements <strong>A</strong> and <strong>B</strong>.</li>
<li>The <strong><code>.push_default_context()</code></strong> step is applied.</li>
<li>In the <strong>Output Stream</strong>, each element is paired with a context that automatically contains <em>that specific element</em>.
<ul>
<li>Element <strong>A</strong> is paired with <code>Context: A</code>.</li>
<li>Element <strong>B</strong> is paired with <code>Context: B</code>.</li>
</ul>
</li>
<li>This shows how the default context dynamically reflects the current element being processed.</li>
</ul>
<h2 id="syntax-12"><a class="header" href="#syntax-12">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.push_default_context()</code></pre>
<h2 id="parameters-13"><a class="header" href="#parameters-13">Parameters</a></h2>
<p>This step takes no parameters.</p>
<h2 id="return-value-13"><a class="header" href="#return-value-13">Return Value</a></h2>
<p>Returns a new walker with the default context added, preserving the current traversal position.</p>
<h2 id="examples-11"><a class="header" href="#examples-11">Examples</a></h2>
<h3 id="tracking-relationships"><a class="header" href="#tracking-relationships">Tracking Relationships</a></h3>
<p>Use default context to describe relationships between people:</p>
<pre><code class="language-rust noplayground">pub fn default_context_example&lt;G&gt;(graph: &amp;G, bryn_id: G::VertexId, julia_id: G::VertexId)
where
    G: Graph&lt;Vertex = Vertex, Edge = Edge&gt;,
{
    // Use default context to access vertex information directly from prior in the traversal
    let knows = graph
        .walk()
        .vertices_by_id(vec![bryn_id, julia_id])
        .push_default_context()
        .edges(EdgeSearch::scan().outgoing())
        .filter_follows()
        .head()
        .map(|target_vertex, ctx| {
            // Access source person name from context
            let source_name = match ctx.vertex() {
                Vertex::Person { name, .. } =&gt; name.clone(),
                _ =&gt; "Unknown".to_string(),
            };

            // Access target person name from vertex
            let person = target_vertex.project::&lt;Person&lt;_&gt;&gt;().unwrap();

            format!("{} knows {}", source_name, person.name())
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // Check the results
    println!("Relationships found:");
    for relationship in &amp;knows {
        println!("- {}", relationship);
    }
}</code></pre>
<h3 id="working-with-edge-properties"><a class="header" href="#working-with-edge-properties">Working with Edge Properties</a></h3>
<p>Combine edge properties with source vertex information:</p>
<pre><code class="language-rust noplayground">pub fn edge_properties_example&lt;G&gt;(graph: &amp;G, person_id: G::VertexId)
where
    G: Graph&lt;Vertex = Vertex, Edge = Edge&gt;,
{
    // Find relationships with metadata
    let relationships = graph
        .walk()
        .vertices_by_id(vec![person_id])
        .push_default_context()
        .edges(EdgeSearch::scan().outgoing())
        .map(|edge, ctx| {
            // Get the source person's name
            let source_name = match ctx.vertex() {
                Vertex::Person { name, .. } =&gt; name.clone(),
                _ =&gt; "Unknown".to_string(),
            };

            // Format based on edge type
            match edge.weight() {
                Edge::Follows =&gt; {
                    format!("{} follows someone", source_name)
                }
                Edge::Created =&gt; {
                    format!("{} created something", source_name)
                }
                Edge::Liked { timestamp } =&gt; {
                    format!("{} liked something at {}", source_name, timestamp)
                }
                Edge::Commented { timestamp } =&gt; {
                    format!("{} commented on something at {}", source_name, timestamp)
                }
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Person relationships with metadata:");
    for rel in relationships {
        println!("- {}", rel);
    }
}</code></pre>
<h2 id="default-context-structure"><a class="header" href="#default-context-structure">Default Context Structure</a></h2>
<p>The default context automatically tracks:</p>
<ul>
<li>For vertices: The current vertex reference</li>
<li>For edges: Both the source and target vertex references</li>
</ul>
<h2 id="accessing-default-context"><a class="header" href="#accessing-default-context">Accessing Default Context</a></h2>
<p>You can access the context in subsequent steps like this:</p>
<pre><code class="language-rust noplayground">// After pushing default context
walker
    .push_default_context()
    .map(|current_element, ctx| {
        // Access vertex from context
        let context_vertex = ctx.vertex();
        
        // Work with the context vertex
        // ...
    })</code></pre>
<h2 id="best-practices-18"><a class="header" href="#best-practices-18">Best Practices</a></h2>
<ul>
<li>Use default context for simple element tracking rather than creating custom context types</li>
<li>Chain default contexts in multi-step traversals to maintain element history</li>
<li>Access context values using the appropriate type-safe methods (e.g., <code>ctx.vertex()</code>, <code>ctx.edge()</code>)</li>
<li>Consider default context before writing complex custom context functions for basic traversals</li>
</ul>
<h2 id="common-use-cases-13"><a class="header" href="#common-use-cases-13">Common Use Cases</a></h2>
<ul>
<li><strong>Relationship description</strong>: Building natural language descriptions (e.g., "Person A knows Person B")</li>
<li><strong>Path tracking</strong>: Recording the sequence of vertices and edges in a traversal</li>
<li><strong>Element comparison</strong>: Comparing properties between current and previous elements</li>
<li><strong>Data collection</strong>: Gathering information from connected elements in the graph</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutate-context"><a class="header" href="#mutate-context">Mutate Context</a></h1>
<p>The <code>mutate_context</code> step allows you to modify context data during a graph traversal without affecting the traversal position. This provides a way to update state or accumulate information as you move through the graph.</p>
<object type="image/svg+xml" data="mutate_context/image.svg" title="Mutate Context Step Diagram">
Mutate context step diagram showing context being modified while elements remain unchanged
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains elements <strong>A</strong> and <strong>B</strong>, each associated with a context value.</li>
<li>The <strong><code>.mutate_context(|e, ctx| { /* modify ctx */ })</code></strong> step is applied, allowing in-place modification of the context associated with each element.</li>
<li>The resulting <strong>Output Stream</strong> shows the same elements (<strong>A</strong> and <strong>B</strong>) but with modified context values.</li>
<li>This demonstrates that <code>mutate_context</code> affects only the context data, not the traversal elements or position.</li>
</ul>
<h2 id="syntax-13"><a class="header" href="#syntax-13">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.mutate_context(|element, context| {
    // Modify context in-place via mutable reference
})</code></pre>
<h2 id="parameters-14"><a class="header" href="#parameters-14">Parameters</a></h2>
<ul>
<li><code>callback</code>: A function that takes:
<ul>
<li>A reference to the current element (vertex or edge)</li>
<li>A mutable reference to the current context</li>
<li>Performs in-place modifications to the context</li>
</ul>
</li>
</ul>
<h2 id="return-value-14"><a class="header" href="#return-value-14">Return Value</a></h2>
<p>Returns a new walker with the same position but modified context data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="detour-step"><a class="header" href="#detour-step">Detour Step</a></h1>
<p>The <code>detour</code> step is a powerful operation that allows you to execute a sub-traversal for <em>each</em> element currently in the
main walker stream. The results yielded by each sub-traversal <em>do not replace</em> the original element in the main stream.
This enables complex conditional logic and exploration without losing the main traversal context.</p>
<object type="image/svg+xml" data="detour/image.svg" title="Detour Step Diagram">
Detour step diagram showing input elements triggering sub-walkers, whose results form the output stream
</object>
<p>In this diagram:</p>
<ul>
<li><strong>Input Elements</strong>: The main walker stream arrives at the <code>detour</code> step with elements <strong>A</strong> and <strong>X</strong>.</li>
<li><strong><code>.detour(|sub| ...)</code></strong>: For each input element, a sub-walker is initiated:
<ul>
<li><strong>Sub-Walker (from A)</strong>: Starts at A, executes the steps defined in the closure (e.g., <code>edges().head()</code>), and
yields results <strong>B</strong> and <strong>C</strong>.</li>
<li><strong>Sub-Walker (from X)</strong>: Starts at X, executes the same steps, and yields result <strong>Y</strong>.</li>
</ul>
</li>
<li><strong>Output Elements (Results)</strong>: The main walker stream continues, now containing the <em>combined results</em> from all
sub-walkers (<strong>A, A, X</strong>). The original elements (A, X) have been replaced.</li>
</ul>
<h2 id="syntax-14"><a class="header" href="#syntax-14">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.detour(|sub_walker_builder| {
    // Configure the sub-walker with additional steps
    sub_walker_builder
        .edges(...) // Example step
        .head()     // Example step
        // ... more steps ...
})</code></pre>
<h2 id="parameters-15"><a class="header" href="#parameters-15">Parameters</a></h2>
<ul>
<li><code>detour_fn</code>: A closure that receives a <code>StartWalkerBuilder</code> positioned at the current element from the main stream.
This closure defines the steps for the sub-traversal.</li>
</ul>
<h2 id="return-value-15"><a class="header" href="#return-value-15">Return Value</a></h2>
<p>Returns a new walker where the elements are the combined results of all the sub-traversals executed within the <code>detour</code>.</p>
<h2 id="examples-12"><a class="header" href="#examples-12">Examples</a></h2>
<h3 id="basic-detour"><a class="header" href="#basic-detour">Basic Detour</a></h3>
<p>This example shows how to use a detour to find projects created by people who follow someone over 30:</p>
<pre><code class="language-rust noplayground">    // Basic detour example: Find projects created by people who follow someone over 30
    println!("Projects created by people who follow someone over 30:");

    let projects = graph
        .walk()
        .vertices(Vertex::person()) // Start with all people
        .detour(|sub_walker| {
            // The detour checks if this person follows someone over 30
            sub_walker
                .edges(Edge::follows()) // Follow "follows" edges
                .head() // Move to the target person
                .filter_by_person(|person, _| person.age() &gt; 30) // Check if they're over 30
                .take(1) // We only need one match to qualify
        })
        // Back to original person vertices that passed the detour check
        .edges(Edge::created()) // Find what they created
        .head() // Move to the created project
        .filter_project() // Keep only project vertices
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for project in projects {
        println!("{:?}", project);
    }</code></pre>
<h3 id="nested-detours"><a class="header" href="#nested-detours">Nested Detours</a></h3>
<p>This example demonstrates using nested detours for more complex traversal logic:</p>
<pre><code class="language-rust noplayground">    // Complex detour example: Find people who created projects that were liked by others
    println!("\nPeople who created projects that were liked by others:");

    let creators = graph
        .walk()
        .vertices(Vertex::person()) // Start with all people
        .push_default_context()
        .detour(|creator_walker| {
            // Detour to check if this person created something that was liked
            creator_walker
                .edges(Edge::created()) // Find what they created
                .head() // Move to the created project
                .detour(|project_walker| {
                    // Nested detour to check if the project was liked
                    project_walker
                        .edges(Edge::liked()) // Find "liked" edges pointing to this project
                        .tail() // Move to the person who liked it
                        .filter(|liker, ctx| {
                            // Check that the liker is different from the creator
                            *ctx.vertex_id() != liker.id()
                        })
                })
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    for creator in creators {
        println!("{:?} created something that was liked", creator);
    }</code></pre>
<h2 id="when-to-use-detour"><a class="header" href="#when-to-use-detour">When to use <code>detour</code></a></h2>
<p>Detour shines in several common graph traversal scenarios:</p>
<ul>
<li>
<p><strong>Conditional filtering based on connected elements</strong>:<br />
For example, "Find people who follow someone over 30" requires exploring connections before making filtering decisions</p>
</li>
<li>
<p><strong>Looking ahead without changing position</strong>:<br />
When you need to check properties of elements further in the graph before deciding how to proceed</p>
</li>
<li>
<p><strong>Complex multi-step conditions</strong>:<br />
When a condition requires checking multiple properties or relationships that would be awkward with chained filters</p>
</li>
<li>
<p><strong>Collecting contextual information</strong>:<br />
When you need to gather information from related elements to inform decisions in the main traversal</p>
</li>
<li>
<p><strong>Avoiding traversal state mutation</strong>:<br />
When you want to explore potential paths without permanently changing your traversal state</p>
</li>
</ul>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<ul>
<li>The detour closure receives a fresh walker starting at the current position</li>
<li>All walker operations inside the detour are executed in a sub-traversal context</li>
<li>Results from the detour replace the current elements in the traversal</li>
<li>The main traversal continues from where it left off, but with the filtered/transformed elements</li>
<li>For better performance, try to use indexed lookups within detours whenever possible</li>
<li>Detours can be nested for extremely complex traversal logic</li>
<li>Using detours improves code readability by logically grouping related traversal operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collect-step"><a class="header" href="#collect-step">Collect Step</a></h1>
<p>The <code>collect</code> step gathers the <strong>IDs</strong> of all elements from a traversal into a specified Rust collection type (e.g., <code>Vec</code>, <code>HashSet</code>, <code>BTreeSet</code>). This is a <strong>terminal</strong> operation that consumes the walker and returns the populated collection.</p>
<object type="image/svg+xml" data="collect/image.svg" title="Collect Step Diagram">
Collect step diagram showing elements flowing into the step and a Rust collection of IDs as the output
</object>
<p>In this diagram:</p>
<ul>
<li><strong>Input Elements</strong>: The walker starts with elements <strong>A, B, C</strong>.</li>
<li>The <strong><code>.collect::&lt;Vec&lt;_&gt;&gt;()</code></strong> step processes the stream and consumes the walker. The type parameter (<code>Vec&lt;_&gt;</code>) specifies the desired collection type.</li>
<li><strong>Returns: Vec&lt;ID&gt;</strong>: The step returns a Rust <code>Vec</code> containing the unique identifiers (IDs) of the elements that were processed (<code>[ID(A), ID(B), ID(C)]</code>).</li>
<li><strong>Terminates Walker</strong>: This step ends the Graph API walker chain.</li>
</ul>
<h2 id="syntax-15"><a class="header" href="#syntax-15">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.collect::&lt;C&gt;()</code></pre>
<p>Where <code>C</code> is the collection type you want to gather results into.</p>
<h2 id="parameters-16"><a class="header" href="#parameters-16">Parameters</a></h2>
<p>This step takes no parameters, but uses a type parameter to specify the collection type.</p>
<h2 id="return-value-16"><a class="header" href="#return-value-16">Return Value</a></h2>
<p>Returns a collection of type <code>C</code> where <code>C</code> implements <code>FromIterator</code>.</p>
<h2 id="examples-13"><a class="header" href="#examples-13">Examples</a></h2>
<h3 id="collecting-into-a-vec"><a class="header" href="#collecting-into-a-vec">Collecting into a Vec</a></h3>
<p>The most common use case is collecting elements into a <code>Vec</code>:</p>
<pre><code class="language-rust noplayground">    // Collect results into a Vec
    // Use the person() index method to get all Person vertices
    let person_vertices: Vec&lt;_&gt; = graph
        .walk()
        .vertices(Vertex::person()) // Type-safe vertex lookup by label
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!("Found {} person vertices", person_vertices.len());</code></pre>
<h3 id="collecting-unique-values"><a class="header" href="#collecting-unique-values">Collecting Unique Values</a></h3>
<p>You can collect into a <code>HashSet</code> to get unique values:</p>
<pre><code class="language-rust noplayground">    // Collect into a HashSet for unique elements
    let unique_names: HashSet&lt;String&gt; = graph
        .walk()
        .vertices(Vertex::person())
        // Use map to extract properties from each person
        .map(|person, _| {
            // Use projection to access Person methods in a type-safe way
            person
                .project::&lt;Person&lt;_&gt;&gt;() // Project to Person type
                .map(|p| p.name().to_string()) // Use accessor method from projection
                .unwrap_or_else(|| "Unknown".to_string())
        })
        .collect::&lt;HashSet&lt;String&gt;&gt;();

    println!("Found {} unique person names", unique_names.len());</code></pre>
<h3 id="collecting-into-an-range-set"><a class="header" href="#collecting-into-an-range-set">Collecting into an Range Set</a></h3>
<p>Use a <code>BTreeSet</code> when you need range unique values:</p>
<pre><code class="language-rust noplayground">    // Collect into a BTreeSet for range unique elements
    let range_ages: BTreeSet&lt;u8&gt; = graph
        .walk()
        .vertices(Vertex::person())
        // Use filter_person() to work exclusively with Person vertices (no closure needed)
        .filter_person() // Label-based type filter with no closure
        // Extract age from each Person vertex
        .map(|person, _| {
            // Use projection to access Person methods in a type-safe way
            person
                .project::&lt;Person&lt;_&gt;&gt;() // Project to Person type
                .map(|p| p.age()) // Use age() accessor method
                .unwrap_or(0)
        })
        .collect::&lt;BTreeSet&lt;u8&gt;&gt;();

    // Print ages in ascending order (BTreeSet maintains order)
    println!("Person ages (range): {:?}", range_ages);</code></pre>
<h2 id="best-practices-19"><a class="header" href="#best-practices-19">Best Practices</a></h2>
<ul>
<li>Use <code>limit</code> before <code>collect</code> when working with large graphs to control memory usage</li>
<li>Choose the right collection type for your needs:
<ul>
<li><code>Vec</code>: When order matters and duplicates are acceptable</li>
<li><code>HashSet</code>: When you need unique elements and don't care about order</li>
<li><code>BTreeSet</code>: When you need unique elements in a specific order</li>
</ul>
</li>
</ul>
<h2 id="common-use-cases-14"><a class="header" href="#common-use-cases-14">Common Use Cases</a></h2>
<ul>
<li><strong>Result accumulation</strong>: Collecting all vertices meeting specific criteria</li>
<li><strong>Set operations</strong>: Gathering unique elements via <code>HashSet</code> for later processing</li>
<li><strong>Ordered results</strong>: Using <code>BTreeSet</code> when elements need to be in a specific order</li>
<li><strong>Custom collections</strong>: Feeding traversal results into specialized data structures</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="count-step"><a class="header" href="#count-step">Count Step</a></h1>
<p>The <code>count</code> step consumes the walker and efficiently counts the number of elements that have passed through the traversal up to that point. It is a <strong>terminal</strong> step that returns a single <code>usize</code> value representing the total count.</p>
<object type="image/svg+xml" data="count/image.svg" title="Count Step Diagram">
Count step diagram showing elements flowing into the step and a usize count as the output
</object>
<p>In this diagram:</p>
<ul>
<li><strong>Input Elements</strong>: The walker starts with elements <strong>A, B, C, D</strong>.</li>
<li>The <strong><code>.count()</code></strong> step processes the stream and consumes the walker.</li>
<li><strong>Returns: usize</strong>: The step returns a single <code>usize</code> value, which is the total number of elements processed (4 in this case).</li>
<li><strong>Terminates Walker</strong>: This step ends the Graph API walker chain.</li>
</ul>
<h2 id="syntax-16"><a class="header" href="#syntax-16">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.count()</code></pre>
<h2 id="parameters-17"><a class="header" href="#parameters-17">Parameters</a></h2>
<p>This step takes no parameters.</p>
<h2 id="return-value-17"><a class="header" href="#return-value-17">Return Value</a></h2>
<p>Returns a <code>usize</code> representing the number of elements in the traversal.</p>
<h2 id="examples-14"><a class="header" href="#examples-14">Examples</a></h2>
<h3 id="basic-count"><a class="header" href="#basic-count">Basic Count</a></h3>
<p>Count the number of people in the graph:</p>
<pre><code class="language-rust noplayground">    // Basic count - how many people are in the graph?
    let person_count = graph.walk().vertices(Vertex::person()).count();

    println!("Total people in graph: {}", person_count);</code></pre>
<h3 id="filtered-count"><a class="header" href="#filtered-count">Filtered Count</a></h3>
<p>Count elements that match specific criteria:</p>
<pre><code class="language-rust noplayground">    // Count with filtering - how many people are over 30?
    let older_person_count = graph
        .walk()
        .vertices(Vertex::person())
        .filter_by_person(|person, _| person.age() &gt; 30)
        .count();

    println!("People over 30: {}", older_person_count);</code></pre>
<h3 id="edge-count"><a class="header" href="#edge-count">Edge Count</a></h3>
<p>Count relationships in the graph:</p>
<pre><code class="language-rust noplayground">    // Count relationships - how many 'follows' relationships exist?
    let knows_count = graph
        .walk()
        .vertices(VertexSearch::scan())
        .edges(Edge::follows())
        .count();

    println!("Total 'follows' relationships: {}", knows_count);</code></pre>
<h3 id="analytics"><a class="header" href="#analytics">Analytics</a></h3>
<p>Use counts to calculate graph analytics:</p>
<pre><code class="language-rust noplayground">    // Count for analytics - average number of people followed per person
    let person_count = graph.walk().vertices(Vertex::person()).count();

    if person_count &gt; 0 {
        let knows_count = graph
            .walk()
            .vertices(Vertex::person())
            .edges(Edge::follows().incoming())
            .count();

        let avg_known = knows_count as f64 / person_count as f64;
        println!("Average people followed per person: {:.2}", avg_known);
    }</code></pre>
<h2 id="best-practices-20"><a class="header" href="#best-practices-20">Best Practices</a></h2>
<ul>
<li>Use count directly rather than collecting results just to count them</li>
<li>Consider indexed counts for large graphs when available in your implementation</li>
<li>Combine with filter steps for specific counting queries</li>
<li>Use count to validate expectations in tests and assertions</li>
</ul>
<h2 id="common-use-cases-15"><a class="header" href="#common-use-cases-15">Common Use Cases</a></h2>
<ul>
<li><strong>Existence checking</strong>: Determining if any elements match criteria (count &gt; 0)</li>
<li><strong>Graph analytics</strong>: Calculating statistics like average connections per node</li>
<li><strong>Validation</strong>: Ensuring expected numbers of elements exist in certain conditions</li>
<li><strong>Performance metrics</strong>: Measuring graph size and density characteristics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="into-iterator"><a class="header" href="#into-iterator">Into Iterator</a></h1>
<p>The <code>into_iter</code> step converts a walker traversal into a standard Rust iterator. This is a <strong>terminal</strong> step that consumes the walker and returns an iterator yielding the <strong>IDs</strong> of the vertices or edges that were in the traversal stream. It allows you to bridge the Graph API's walker system with Rust's standard iterator ecosystem.</p>
<object type="image/svg+xml" data="into_iter/image.svg" title="Into Iterator Step Diagram">
Into Iterator step diagram showing elements flowing into the step and a Rust iterator yielding IDs as the output
</object>
<p>In this diagram:</p>
<ul>
<li><strong>Input Elements</strong>: The walker starts with elements <strong>A, B, C</strong>.</li>
<li>The <strong><code>.into_iter()</code></strong> step processes the stream and consumes the walker.</li>
<li><strong>Rust Iterator</strong>: The step returns a standard Rust iterator. This iterator yields the unique identifiers (IDs) of the elements that were processed (ID(A), ID(B), ID(C)).</li>
<li><strong>Terminates Walker</strong>: This step ends the Graph API walker chain. Subsequent operations must use standard Rust iterator methods.</li>
</ul>
<h2 id="syntax-17"><a class="header" href="#syntax-17">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.into_iter()</code></pre>
<h2 id="parameters-18"><a class="header" href="#parameters-18">Parameters</a></h2>
<p>This step takes no parameters.</p>
<h2 id="return-value-18"><a class="header" href="#return-value-18">Return Value</a></h2>
<p>Returns a standard Rust iterator that yields vertex or edge IDs from the traversal.</p>
<h2 id="examples-15"><a class="header" href="#examples-15">Examples</a></h2>
<h3 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h3>
<p>Convert a traversal to an iterator and collect results:</p>
<pre><code class="language-rust noplayground">    // Basic iteration to collect IDs
    let vertex_ids = graph
        .walk()
        .vertices(VertexSearch::scan())
        .into_iter()
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // There should be at least 4 vertices in the graph
    assert!(vertex_ids.len() &gt;= 4);</code></pre>
<h3 id="filtering-with-standard-iterators"><a class="header" href="#filtering-with-standard-iterators">Filtering with Standard Iterators</a></h3>
<p>Use standard Rust iterator methods:</p>
<pre><code class="language-rust noplayground">    // We can use standard iterator operations like filtering
    let filtered_vertices = graph
        .walk()
        .vertices(VertexSearch::scan())
        .into_iter()
        .filter(|vertex_id| {
            // Get the vertex reference from the ID
            if let Some(vertex) = graph.vertex(*vertex_id) {
                // Check if it's a Person
                matches!(vertex.weight(), Vertex::Person { .. })
            } else {
                false
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // There should be exactly 2 Person vertices (bryn and julia)
    assert_eq!(filtered_vertices.len(), 2);</code></pre>
<h3 id="comparing-with-walker-methods"><a class="header" href="#comparing-with-walker-methods">Comparing with Walker Methods</a></h3>
<p>Walker methods vs standard iterator methods:</p>
<pre><code class="language-rust noplayground">    // Using .map() on the walker directly yields references with context
    let vertex_names = graph
        .walk()
        .vertices(VertexSearch::scan())
        .map(|vertex, _ctx| match vertex.weight() {
            Vertex::Person { name, .. } =&gt; name.clone(),
            Vertex::Project { name } =&gt; name.clone(),
            _ =&gt; "Unknown".to_string(),
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();

    assert!(vertex_names.contains(&amp;"Bryn".to_string()));
    assert!(vertex_names.contains(&amp;"Julia".to_string()));
    assert!(vertex_names.contains(&amp;"GraphApi".to_string()));
    assert!(vertex_names.contains(&amp;"Rust".to_string()));</code></pre>
<h2 id="best-practices-21"><a class="header" href="#best-practices-21">Best Practices</a></h2>
<ul>
<li>Use <code>into_iter</code> only when you need to leverage standard Rust iterators</li>
<li>Remember that standard iterator methods lose access to graph context</li>
<li>Consider extracting essential data into context before converting to an iterator</li>
<li>When working with large graphs, use the Graph API's lazy evaluation before converting to an iterator</li>
</ul>
<h2 id="common-use-cases-16"><a class="header" href="#common-use-cases-16">Common Use Cases</a></h2>
<ul>
<li><strong>Integration with existing code</strong>: Bridging Graph API traversals with existing iterator-based systems</li>
<li><strong>Complex iterator chains</strong>: Using specialized iterator adaptors not available as walker steps</li>
<li><strong>ID-based operations</strong>: Working with element IDs directly for memory efficiency</li>
<li><strong>Ecosystem integration</strong>: Connecting graph traversals with Rust's extensive iterator ecosystem</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="probe-step"><a class="header" href="#probe-step">Probe Step</a></h1>
<p>The <code>probe</code> step allows you to execute a callback function for each element in the traversal, primarily for <strong>side effects</strong> like logging, metrics collection, or debugging, without altering the elements themselves or the flow of the traversal.</p>
<object type="image/svg+xml" data="probe/image.svg" title="Probe Step Diagram">
Probe step diagram showing elements flowing through, side effects, and unchanged output stream
</object>
<p>In this diagram:</p>
<ul>
<li><strong>Input Elements</strong>: The walker starts with elements <strong>A, B, C</strong>.</li>
<li>The <strong><code>.probe(callback)</code></strong> step processes each element.</li>
<li><strong>Side Effect</strong>: As each element (A, B, C) passes through, the provided callback function is executed. This is shown triggering actions like logging or updating metrics.</li>
<li><strong>Output Elements (Unchanged)</strong>: The elements <strong>A, B, C</strong> continue to the next step in the traversal, completely unaffected by the <code>probe</code> operation.</li>
</ul>
<h2 id="syntax-18"><a class="header" href="#syntax-18">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.probe(|element, context| {
    // inspection logic
})</code></pre>
<h2 id="parameters-19"><a class="header" href="#parameters-19">Parameters</a></h2>
<ul>
<li><code>inspector</code>: A function that takes:
<ul>
<li>A reference to the current element (vertex or edge)</li>
<li>The element's context</li>
<li>Performs some side effect like logging or debugging</li>
</ul>
</li>
</ul>
<h2 id="return-value-19"><a class="header" href="#return-value-19">Return Value</a></h2>
<p>Returns the same traversal unchanged, allowing you to continue chaining steps.</p>
<h2 id="examples-16"><a class="header" href="#examples-16">Examples</a></h2>
<h3 id="inspecting-vertices"><a class="header" href="#inspecting-vertices">Inspecting Vertices</a></h3>
<p>This example shows how to use the <code>probe</code> step to inspect and count vertices during traversal:</p>
<pre><code class="language-rust noplayground">    // Use probe to inspect vertices during traversal without affecting the flow
    println!("Examining each person vertex:");

    let mut person_count = 0;

    graph
        .walk()
        .vertices(Vertex::person()) // Type-safe vertex lookup by label
        .probe(|vertex, _| {
            // Inspect vertex properties using type-safe projection
            if let Some(person) = vertex.project::&lt;Person&lt;_&gt;&gt;() {
                person_count += 1;
                println!("  Found person: {} (age {})", person.name(), person.age());
            }
        })
        .count();

    println!("  Total people found: {}", person_count);</code></pre>
<h3 id="inspecting-edges"><a class="header" href="#inspecting-edges">Inspecting Edges</a></h3>
<p>This example demonstrates using the <code>probe</code> step to examine relationships between vertices:</p>
<pre><code class="language-rust noplayground">    // Use probe to inspect relationships between vertices
    println!("\nExamining Bryn's outgoing relationships:");

    graph
        .walk()
        .vertices(Vertex::person_by_username("bryn123"))
        .edges(EdgeSearch::scan().outgoing())
        .probe(|edge, _| {
            // Get the target vertex to display relationship context
            let target = graph.vertex(edge.head()).unwrap();

            // Display relationship information
            match edge.weight() {
                crate::standard_model::Edge::Created =&gt; {
                    if let Some(project) = target.project::&lt;Project&lt;_&gt;&gt;() {
                        println!("  Bryn created project: {}", project.name());
                    }
                }
                crate::standard_model::Edge::Follows =&gt; {
                    if let Some(person) = target.project::&lt;Person&lt;_&gt;&gt;() {
                        println!("  Bryn follows: {}", person.name());
                    }
                }
                crate::standard_model::Edge::Liked { timestamp } =&gt; {
                    if let Some(project) = target.project::&lt;Project&lt;_&gt;&gt;() {
                        println!("  Bryn liked project {} on {}", project.name(), timestamp);
                    }
                }
                crate::standard_model::Edge::Commented { timestamp } =&gt; {
                    if let Some(project) = target.project::&lt;Project&lt;_&gt;&gt;() {
                        println!(
                            "  Bryn commented on project {} on {}",
                            project.name(),
                            timestamp
                        );
                    }
                }
            }
        })
        .count();</code></pre>
<h2 id="best-practices-22"><a class="header" href="#best-practices-22">Best Practices</a></h2>
<ul>
<li>Insert probe steps at key points in complex traversals to verify correct behavior</li>
<li>Use descriptive logging within probes to make debugging output meaningful</li>
<li>Add counters or statistics collection to understand traversal performance</li>
<li>Keep probe functions simple and side-effect only; don't try to affect the traversal flow</li>
</ul>
<h2 id="common-use-cases-17"><a class="header" href="#common-use-cases-17">Common Use Cases</a></h2>
<ul>
<li><strong>Debugging</strong>: Inserting temporary probe steps to understand traversal behavior</li>
<li><strong>Logging</strong>: Recording traversal information during development or in production</li>
<li><strong>Metrics collection</strong>: Gathering statistics about traversal performance and results</li>
<li><strong>Inspection</strong>: Examining element properties at specific points in the traversal</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutate-step"><a class="header" href="#mutate-step">Mutate Step</a></h1>
<p>The <code>mutate</code> step iterates over elements in the traversal, applying a callback function to each one. This callback receives mutable access to the graph, allowing for <strong>in-place modification</strong> of vertices or edges. <code>mutate</code> is a terminal step that consumes the walker and returns the total count (<code>usize</code>) of elements processed.</p>
<object type="image/svg+xml" data="mutate/image.svg" title="Mutate Step Diagram">
Mutate step diagram showing elements being modified in-place and the step returning a count
</object>
<p>In this diagram:</p>
<ul>
<li><strong>Input Elements</strong>: The walker starts with elements <strong>A, B, C</strong>, each having an initial value (e.g., <code>val=1</code>).</li>
<li>The <strong><code>.mutate(callback)</code></strong> step processes each element. The callback function has access to modify the graph.</li>
<li><strong>Mutated Elements (In Graph)</strong>: The diagram shows the state of the elements <em>after</em> the mutation callback has been applied (e.g., <strong>A'</strong> with <code>val=10</code>). This highlights the in-place nature of the operation.</li>
<li><strong>Returns: usize</strong>: The step completes and returns the count of elements processed (3 in this case), terminating the walker chain.</li>
</ul>
<h2 id="syntax-19"><a class="header" href="#syntax-19">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.mutate(|element, context, graph| {
    // mutation logic using graph access
})</code></pre>
<h2 id="parameters-20"><a class="header" href="#parameters-20">Parameters</a></h2>
<ul>
<li><code>callback</code>: A function that takes:
<ul>
<li>A reference to the current element (vertex or edge) - Note: Direct mutable access to the <em>element itself</em> might vary; mutation often happens via the <code>graph</code> reference using the element's ID.</li>
<li>The element's context</li>
<li>A mutable reference to the graph (<code>&amp;mut G</code>)</li>
<li>Performs modifications using the mutable graph reference (e.g., <code>graph.vertex_mut(element.id())</code>).</li>
</ul>
</li>
</ul>
<h2 id="return-value-20"><a class="header" href="#return-value-20">Return Value</a></h2>
<p>Returns a <code>usize</code> representing the number of elements processed by the <code>mutate</code> step.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><code class="language-rust noplayground">    // Example 1: Update all person vertices to increment their age
    println!("Incrementing age of all people:");

    // Print original ages
    graph
        .walk()
        .vertices(Vertex::person())
        .probe(|vertex, _| {
            if let Some(person) = vertex.project::&lt;Person&lt;_&gt;&gt;() {
                println!("  Before: {} is {} years old", person.name(), person.age());
            }
        })
        .count();

    // Perform the mutation - increment everyone's age by 1
    let updated_count = graph
        .walk_mut() // Must use walk_mut() for mutations
        .vertices(Vertex::person())
        .mutate(|graph, vertex_id, _| {
            // Note: updating requires cloning and replacing due to Rust's ownership model
            if let Some(mut vertex) = graph.vertex_mut(vertex_id) {
                if let Some(mut person) = vertex.project_mut::&lt;PersonMut&lt;_, _&gt;&gt;() {
                    // Increment the person age
                    person.set_age(person.age() + 1);
                }
            }
        });

    println!("  Updated {} person vertices", updated_count);</code></pre>
<h2 id="best-practices-23"><a class="header" href="#best-practices-23">Best Practices</a></h2>
<ul>
<li>Use <code>mutate</code> specifically for modifying graph elements based on traversal results.</li>
<li>Access mutable elements via the provided <code>graph</code> reference and the element's ID (e.g., <code>graph.vertex_mut(id)</code>).</li>
<li>Be mindful that mutations are applied directly and immediately to the graph state.</li>
<li>Consider using <code>filter</code> or <code>control_flow</code> <em>before</em> <code>mutate</code> to precisely target which elements should be modified.</li>
<li>Understand the graph implementation's behavior regarding mutations during iteration (e.g., adding/removing elements might invalidate iterators in some graph types).</li>
</ul>
<h2 id="common-use-cases-18"><a class="header" href="#common-use-cases-18">Common Use Cases</a></h2>
<ul>
<li><strong>Updating properties</strong>: Modifying attributes of vertices or edges (e.g., incrementing age, changing status).</li>
<li><strong>Graph cleaning</strong>: Standardizing data or fixing inconsistencies found during traversal.</li>
<li><strong>State transitions</strong>: Updating element states based on workflow logic during traversal.</li>
<li><strong>Bulk updates</strong>: Applying a change to a set of elements identified by prior traversal steps.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-step"><a class="header" href="#debug-step">Debug Step</a></h1>
<p>The <code>dbg</code> step provides a simple way to inspect the elements flowing through a traversal without altering them. It
prints detailed information about each element to the console as it passes through the step.</p>
<object type="image/svg+xml" data="dbg/image.svg" title="Dbg Step Diagram">
Debug step diagram showing elements flowing through, console output, and unchanged output stream
</object>
<p>In this diagram:</p>
<ul>
<li><strong>Input Elements</strong>: The walker starts with elements <strong>A, B, C</strong>.</li>
<li>The <strong><code>.dbg("Label")</code></strong> step processes each element.</li>
<li><strong>Console Output</strong>: As each element (A, B, C) passes through the <code>dbg</code> step, its details are printed to the console,
prefixed with the provided label. This is shown as a side effect.</li>
<li><strong>Output Elements (Unchanged)</strong>: The elements <strong>A, B, C</strong> continue to the next step in the traversal, completely
unaffected by the <code>dbg</code> operation.</li>
</ul>
<h2 id="syntax-20"><a class="header" href="#syntax-20">Syntax</a></h2>
<pre><code class="language-rust noplayground">walker.dbg("Custom label")</code></pre>
<h2 id="parameters-21"><a class="header" href="#parameters-21">Parameters</a></h2>
<ul>
<li><code>label</code>: An optional string label to identify the debug output.</li>
</ul>
<h2 id="return-value-21"><a class="header" href="#return-value-21">Return Value</a></h2>
<p>Returns the same traversal unchanged, allowing you to continue chaining steps.</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><code class="language-rust noplayground">    // Create a pipeline with multiple dbg steps to see how data transforms
    let result = graph
        .walk()
        .vertices(Vertex::person()) // Start with all people
        .dbg("all-people") // Debug all people vertices
        .filter_by_person(|person, _| {
            // Find people over 30
            person.age() &gt; 30
        })
        .dbg("people-over-30") // Debug filtered results
        .count();

    println!("Found {} people over 30", result);</code></pre>
<h2 id="best-practices-24"><a class="header" href="#best-practices-24">Best Practices</a></h2>
<ul>
<li>Use meaningful labels to identify each debug checkpoint in complex traversals</li>
<li>Remove or comment out debug steps before deploying to production</li>
<li>Add debug steps before and after steps that might be causing issues</li>
<li>For production logging, replace with <code>probe</code> steps that have custom formatting</li>
</ul>
<h2 id="common-use-cases-19"><a class="header" href="#common-use-cases-19">Common Use Cases</a></h2>
<ul>
<li><strong>Traversal troubleshooting</strong>: Understanding why a traversal isn't returning expected results</li>
<li><strong>Learning</strong>: Exploring how traversals work by seeing each element's detailed state</li>
<li><strong>Development checkpoints</strong>: Verifying the state of a traversal at key points</li>
<li><strong>Context inspection</strong>: Examining the full context structure during traversal</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-system"><a class="header" href="#context-system">Context System</a></h1>
<p>The context system is a powerful feature of the Graph API that enriches your traversals by carrying data alongside the stream of elements (vertices or edges). This allows you to maintain state, collect information, and make decisions based on previously processed elements as you explore the graph.</p>
<h2 id="what-is-context"><a class="header" href="#what-is-context">What is Context?</a></h2>
<object type="image/svg+xml" data="context_system/image.svg">
Diagram illustrating how context is added, travels with the stream, and is used by subsequent steps
</object>
<p>In this diagram:</p>
<ul>
<li>An <strong>Input Stream</strong> contains elements <strong>A</strong> and <strong>B</strong>.</li>
<li>The <strong><code>push_context</code></strong> step is applied. It calculates a context value (e.g., <code>"Ctx_A"</code>) based on the first element encountered (A) and attaches this <em>fixed</em> context to all subsequent elements.</li>
<li>The <strong>Stream with Context</strong> now contains pairs of <code>(Element, Context)</code>: <code>(A, "Ctx_A")</code>, <code>(B, "Ctx_A")</code>.</li>
<li>A subsequent <strong><code>map</code></strong> step receives both the current element and its associated context, allowing it to perform transformations using both pieces of information.</li>
<li>The <strong>Final Output</strong> shows the results produced by the <code>map</code> step.</li>
</ul>
<p>Context allows you to:</p>
<ul>
<li><strong>Carry information</strong> from previous steps to later steps in the traversal</li>
<li><strong>Transform data</strong> as you move through the graph</li>
<li><strong>Make decisions</strong> based on a combination of current and past elements</li>
<li><strong>Build complex data structures</strong> by accumulating information during traversal</li>
<li><strong>Maintain state</strong> without changing the traversal position</li>
</ul>
<h2 id="context-methods"><a class="header" href="#context-methods">Context Methods</a></h2>
<p>The Graph API provides two primary methods for managing context:</p>
<h3 id="push_context"><a class="header" href="#push_context">push_context</a></h3>
<pre><code class="language-rust noplayground">// Add or transform context
walker.push_context(|element, current_context| {
    // Extract data from the current element
    // Optionally use the existing context
    // Return a new context value
})</code></pre>
<p>This method creates or transforms context based on the current element and any existing context.</p>
<h3 id="push_default_context"><a class="header" href="#push_default_context">push_default_context</a></h3>
<pre><code class="language-rust noplayground">// Add the current vertex or edge as context
walker.push_default_context()</code></pre>
<p>This method stores the current vertex or edge in context, making it available in later steps.</p>
<h2 id="basic-context-usage"><a class="header" href="#basic-context-usage">Basic Context Usage</a></h2>
<p>Here's a simple example of storing information in context and using it later:</p>
<pre><code class="language-rust noplayground">pub fn basic_context_example() {
    let graph = standard_populated_graph();

    // Store person name in context and use it later
    let person_projects = graph
        .walk()
        .vertices()
        .filter_person() // Type-safe filter using generated helper
        .push_context(|v, _| {
            // Extract and store person's name
            v.project::&lt;Person&lt;_&gt;&gt;().unwrap().name().to_string()
        })
        .edges(EdgeSearch::scan().outgoing())
        .filter_created() // Type-safe filter using generated helper
        .vertices()
        .filter_project() // Type-safe filter using generated helper
        .map(|project, ctx| {
            // Format using project name and person name from context
            format!(
                "{} created the {} project",
                ctx,
                project.project::&lt;Project&lt;_&gt;&gt;().unwrap().name()
            )
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
}</code></pre>
<h2 id="nested-context-with-detours"><a class="header" href="#nested-context-with-detours">Nested Context with Detours</a></h2>
<p>When using the <code>detour</code> step, context becomes nested, allowing you to access the parent context:</p>
<pre><code class="language-rust noplayground">pub fn nested_context_example() {
    let graph = standard_populated_graph();

    // Use nested context to track relationships
    let follows_ages = graph
        .walk()
        .vertices()
        .filter_person() // Type-safe filter using generated helper
        .push_context(|v, _| {
            // Store source person's age in context
            v.project::&lt;Person&lt;_&gt;&gt;().unwrap().age()
        })
        .detour(|w| {
            // Start a sub-traversal that keeps parent context
            w.edges(EdgeSearch::scan().outgoing())
                .filter_follows() // Type-safe filter using generated helper
                .vertices()
                .filter_person() // Type-safe filter using generated helper
                .map(|target, ctx| {
                    // Access source's age from context
                    let source_age = *ctx;
                    let target_age = target.project::&lt;Person&lt;_&gt;&gt;().unwrap().age();

                    // Calculate and return age difference
                    let diff = target_age as i32 - source_age as i32;

                    if diff &gt; 0 {
                        "follows someone older"
                    } else if diff &lt; 0 {
                        "follows someone younger"
                    } else {
                        "follows someone the same age"
                    }
                })
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
}</code></pre>
<h2 id="default-context-1"><a class="header" href="#default-context-1">Default Context</a></h2>
<p>The Graph API provides a built-in default context that simplifies common patterns:</p>
<pre><code class="language-rust noplayground">pub fn default_context_example() {
    let graph = standard_populated_graph();

    // Use the built-in default context to access source vertex
    let relationships = graph
        .walk()
        .vertices()
        .filter_person() // Type-safe filter using generated helper
        .push_default_context() // Store current vertex in default context
        .edges(EdgeSearch::scan().outgoing())
        .vertices()
        .map(|target, ctx| {
            // Access the source vertex from context
            let source = ctx.vertex();
            let source_name = source
                .project::&lt;Person&lt;_&gt;&gt;()
                .map(|p| p.name())
                .unwrap_or("Unknown");

            // Format the relationship based on target type
            match target.weight() {
                Vertex::Person { name, .. } =&gt; format!("{} is connected to {}", source_name, name),
                Vertex::Project { name, .. } =&gt; format!("{} works on {}", source_name, name),
                _ =&gt; "Unknown relationship".to_string(),
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
}</code></pre>
<h2 id="type-safety-1"><a class="header" href="#type-safety-1">Type Safety</a></h2>
<p>The context system is fully type-safe:</p>
<ul>
<li>Each context value has a specific type determined by your context function</li>
<li>The compiler enforces correct handling of context types</li>
<li>Context functions must return values compatible with downstream operations</li>
<li>Errors in context type handling are caught at compile time, not runtime</li>
</ul>
<h2 id="context-lifecycle"><a class="header" href="#context-lifecycle">Context Lifecycle</a></h2>
<ol>
<li><strong>Creation</strong>: Context is created when you first call a context method</li>
<li><strong>Transformation</strong>: Context can be transformed at any step in the traversal</li>
<li><strong>Access</strong>: Any step that accepts a closure can access the context</li>
<li><strong>Nesting</strong>: Detours create nested contexts with access to parent contexts</li>
<li><strong>Immutability</strong>: Context is immutable; transformations create new contexts</li>
</ol>
<h2 id="best-practices-25"><a class="header" href="#best-practices-25">Best Practices</a></h2>
<ul>
<li><strong>Keep context small</strong>: Large contexts can impact performance</li>
<li><strong>Use immutable data structures</strong>: Create new contexts rather than modifying existing ones</li>
<li><strong>Leverage type safety</strong>: Let the compiler ensure your context manipulations are valid</li>
<li><strong>Consider cloning costs</strong>: For large data, use <code>Arc</code> or similar for cheap cloning</li>
<li><strong>Use default context</strong>: For simple cases, <code>push_default_context()</code> is cleaner than custom context</li>
<li><strong>Chain context operations</strong>: Build complex data structures through multiple context steps</li>
<li><strong>Document context types</strong>: When using complex context chains, document the context type at each step</li>
</ul>
<h2 id="common-use-cases-20"><a class="header" href="#common-use-cases-20">Common Use Cases</a></h2>
<ul>
<li><strong>Path tracking</strong>: Record the path taken through the graph</li>
<li><strong>Property collection</strong>: Gather properties from different vertices/edges</li>
<li><strong>Decision making</strong>: Use information from earlier elements to influence traversal decisions</li>
<li><strong>Aggregation</strong>: Build composite results during traversal</li>
<li><strong>Statistical analysis</strong>: Calculate metrics as you traverse the graph</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walker-best-practices"><a class="header" href="#walker-best-practices">Walker Best Practices</a></h1>
<p>This page provides guidance on effectively using the Graph API walker system for graph traversals.</p>
<h2 id="general-best-practices"><a class="header" href="#general-best-practices">General Best Practices</a></h2>
<ol>
<li>
<p><strong>Chain steps logically</strong></p>
<ul>
<li>Build your traversal in a logical sequence that mirrors how you would describe the path</li>
<li>Group related operations together to improve readability</li>
</ul>
</li>
<li>
<p><strong>Use appropriate search criteria</strong></p>
<ul>
<li>Limit vertices and edges early in the traversal to reduce the traversal set</li>
<li>Use the most specific search criteria available (label, index, property)</li>
</ul>
</li>
<li>
<p><strong>Leverage type projections</strong></p>
<ul>
<li>Use <code>.project::&lt;Type&lt;_&gt;&gt;()</code> to access type-specific methods</li>
<li>Handle projection failures gracefully with <code>match</code> or <code>if let</code></li>
</ul>
</li>
<li>
<p><strong>Use context for data collection</strong></p>
<ul>
<li>Store intermediate results in context rather than using external collections</li>
<li>Use context to carry state through the traversal</li>
</ul>
</li>
<li>
<p><strong>Consider performance</strong></p>
<ul>
<li>For very large graphs, filter early to reduce the traversal set</li>
<li>Use indexed lookups when available</li>
<li>Limit traversal depth for potentially unbounded searches</li>
</ul>
</li>
</ol>
<h2 id="optimization-tips"><a class="header" href="#optimization-tips">Optimization Tips</a></h2>
<h3 id="early-filtering"><a class="header" href="#early-filtering">Early Filtering</a></h3>
<p>Filter vertices and edges as early as possible in the traversal:</p>
<pre><code class="language-rust noplayground"><span class="boring">use graph_api_test::Vertex;
</span><span class="boring">use graph_api_test::Edge;
</span><span class="boring">use graph_api_test::VertexExt;
</span><span class="boring">use graph_api_test::EdgeExt;
</span><span class="boring">use graph_api_test::Person;
</span><span class="boring">use graph_api_test::Project;
</span><span class="boring">use graph_api_test::populate_graph;
</span><span class="boring">use graph_api_lib::EdgeSearch;
</span><span class="boring">use graph_api_lib::VertexSearch;
</span><span class="boring">use graph_api_simplegraph::SimpleGraph;
</span><span class="boring">use graph_api_lib::Graph;
</span><span class="boring">use graph_api_lib::VertexReference;
</span><span class="boring">use graph_api_lib::EdgeReference;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span><span class="boring">// Create a new graph
</span><span class="boring">let mut graph = SimpleGraph::new();
</span><span class="boring">// Populate the graph with test data
</span><span class="boring">let refs = populate_graph(&amp;mut graph);
</span>// Efficient - filters early
graph.walk()
    .vertices(VertexSearch::scan().with_label(Person::label()))
    .filter(|v, _| v.project::&lt;Person&lt;_&gt;&gt;().unwrap().age() &gt; 30)
    .edges(...)
    // ... rest of traversal

// Less efficient - processes all edges before filtering
graph.walk()
    .vertices(VertexSearch::scan().with_label(Person::label()))
    .edges(...)
    .head()
    .filter(|v, _| v.project::&lt;Person&lt;_&gt;&gt;().unwrap().age() &gt; 30)
    // ... rest of traversal</code></pre>
<h3 id="use-indexes"><a class="header" href="#use-indexes">Use Indexes</a></h3>
<p>Take advantage of indexes when available:</p>
<pre><code class="language-rust noplayground"><span class="boring">use graph_api_test::Vertex;
</span><span class="boring">use graph_api_test::Edge;
</span><span class="boring">use graph_api_test::VertexExt;
</span><span class="boring">use graph_api_test::EdgeExt;
</span><span class="boring">use graph_api_test::Person;
</span><span class="boring">use graph_api_test::Project;
</span><span class="boring">use graph_api_test::populate_graph;
</span><span class="boring">use graph_api_lib::EdgeSearch;
</span><span class="boring">use graph_api_lib::VertexSearch;
</span><span class="boring">use graph_api_simplegraph::SimpleGraph;
</span><span class="boring">use graph_api_lib::Graph;
</span><span class="boring">use graph_api_lib::VertexReference;
</span><span class="boring">use graph_api_lib::EdgeReference;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span><span class="boring">// Create a new graph
</span><span class="boring">let mut graph = SimpleGraph::new();
</span><span class="boring">// Populate the graph with test data
</span><span class="boring">let refs = populate_graph(&amp;mut graph);
</span>// Using an index (more efficient)
graph.walk()
    .vertices(VertexSearch::index(Person::by_name_index(), "Bryn"))
    // ... rest of traversal

// Full scan (less efficient)
graph.walk()
    .vertices(VertexSearch::scan())
    .filter(|v, _| {
        if let Ok(person) = v.project::&lt;Person&lt;_&gt;&gt;() {
            person.name() == "Bryn"
        } else {
            false
        }
    })
    // ... rest of traversal</code></pre>
<h3 id="limit-traversal-size"><a class="header" href="#limit-traversal-size">Limit Traversal Size</a></h3>
<p>Use <code>take()</code> to prevent processing excessive elements:</p>
<pre><code class="language-rust noplayground"><span class="boring">use graph_api_test::Vertex;
</span><span class="boring">use graph_api_test::Edge;
</span><span class="boring">use graph_api_test::VertexExt;
</span><span class="boring">use graph_api_test::EdgeExt;
</span><span class="boring">use graph_api_test::Person;
</span><span class="boring">use graph_api_test::Project;
</span><span class="boring">use graph_api_test::populate_graph;
</span><span class="boring">use graph_api_lib::EdgeSearch;
</span><span class="boring">use graph_api_lib::VertexSearch;
</span><span class="boring">use graph_api_simplegraph::SimpleGraph;
</span><span class="boring">use graph_api_lib::Graph;
</span><span class="boring">use graph_api_lib::VertexReference;
</span><span class="boring">use graph_api_lib::EdgeReference;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span><span class="boring">// Create a new graph
</span><span class="boring">let mut graph = SimpleGraph::new();
</span><span class="boring">// Populate the graph with test data
</span><span class="boring">let refs = populate_graph(&amp;mut graph);
</span>// Limit to first 10 results
graph.walk()
    .vertices(VertexSearch::scan())
    .take(10)
    .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="use-detours-effectively"><a class="header" href="#use-detours-effectively">Use Detours Effectively</a></h3>
<p>Detours allow for complex traversals without losing your place:</p>
<pre><code class="language-rust noplayground"><span class="boring">use graph_api_test::Vertex;
</span><span class="boring">use graph_api_test::Edge;
</span><span class="boring">use graph_api_test::VertexExt;
</span><span class="boring">use graph_api_test::EdgeExt;
</span><span class="boring">use graph_api_test::Person;
</span><span class="boring">use graph_api_test::Project;
</span><span class="boring">use graph_api_test::populate_graph;
</span><span class="boring">use graph_api_lib::EdgeSearch;
</span><span class="boring">use graph_api_lib::VertexSearch;
</span><span class="boring">use graph_api_simplegraph::SimpleGraph;
</span><span class="boring">use graph_api_lib::Graph;
</span><span class="boring">use graph_api_lib::VertexReference;
</span><span class="boring">use graph_api_lib::EdgeReference;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span><span class="boring">// Create a new graph
</span><span class="boring">let mut graph = SimpleGraph::new();
</span><span class="boring">// Populate the graph with test data
</span><span class="boring">let refs = populate_graph(&amp;mut graph);
</span>// Find people and their projects with ratings
graph.walk()
    .vertices(VertexSearch::scan().with_label(Person::label()))
    .push_context(|v, _| v.id()) // Store person ID
    .detour(|v| {
        v.edges(EdgeSearch::scan().with_label(Edge::created_label()))
        .tail()
        .push_context(|v, ctx| {
            // Return both the person ID and project
            (ctx.clone(), v.project::&lt;Project&lt;_&gt;&gt;().unwrap().name().to_string())
        })
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="finding-connected-vertices"><a class="header" href="#finding-connected-vertices">Finding Connected Vertices</a></h3>
<pre><code class="language-rust noplayground"><span class="boring">use graph_api_test::Vertex;
</span><span class="boring">use graph_api_test::Edge;
</span><span class="boring">use graph_api_test::VertexExt;
</span><span class="boring">use graph_api_test::EdgeExt;
</span><span class="boring">use graph_api_test::Person;
</span><span class="boring">use graph_api_test::Project;
</span><span class="boring">use graph_api_test::populate_graph;
</span><span class="boring">use graph_api_lib::EdgeSearch;
</span><span class="boring">use graph_api_lib::VertexSearch;
</span><span class="boring">use graph_api_simplegraph::SimpleGraph;
</span><span class="boring">use graph_api_lib::Graph;
</span><span class="boring">use graph_api_lib::VertexReference;
</span><span class="boring">use graph_api_lib::EdgeReference;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span><span class="boring">// Create a new graph
</span><span class="boring">let mut graph = SimpleGraph::new();
</span><span class="boring">// Populate the graph with test data
</span><span class="boring">let refs = populate_graph(&amp;mut graph);
</span>// Find all friends of Bryn
let friends = graph.walk()
    .vertices(VertexSearch::index(Person::by_name_index(), "Bryn"))
    .edges(EdgeSearch::scan().with_label(Edge::knows_label()))
    .tail()
    .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="filtering-by-properties"><a class="header" href="#filtering-by-properties">Filtering by Properties</a></h3>
<pre><code class="language-rust noplayground"><span class="boring">use graph_api_test::Vertex;
</span><span class="boring">use graph_api_test::Edge;
</span><span class="boring">use graph_api_test::VertexExt;
</span><span class="boring">use graph_api_test::EdgeExt;
</span><span class="boring">use graph_api_test::Person;
</span><span class="boring">use graph_api_test::Project;
</span><span class="boring">use graph_api_test::populate_graph;
</span><span class="boring">use graph_api_lib::EdgeSearch;
</span><span class="boring">use graph_api_lib::VertexSearch;
</span><span class="boring">use graph_api_simplegraph::SimpleGraph;
</span><span class="boring">use graph_api_lib::Graph;
</span><span class="boring">use graph_api_lib::VertexReference;
</span><span class="boring">use graph_api_lib::EdgeReference;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span><span class="boring">// Create a new graph
</span><span class="boring">let mut graph = SimpleGraph::new();
</span><span class="boring">// Populate the graph with test data
</span><span class="boring">let refs = populate_graph(&amp;mut graph);
</span>// Find all people over 30
let seniors = graph.walk()
    .vertices(VertexSearch::scan().with_label(Person::label()))
    .filter(|v, _| v.project::&lt;Person&lt;_&gt;&gt;().unwrap().age() &gt; 30)
    .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="collecting-property-values"><a class="header" href="#collecting-property-values">Collecting Property Values</a></h3>
<pre><code class="language-rust noplayground"><span class="boring">use graph_api_test::Vertex;
</span><span class="boring">use graph_api_test::Edge;
</span><span class="boring">use graph_api_test::VertexExt;
</span><span class="boring">use graph_api_test::EdgeExt;
</span><span class="boring">use graph_api_test::Person;
</span><span class="boring">use graph_api_test::Project;
</span><span class="boring">use graph_api_test::populate_graph;
</span><span class="boring">use graph_api_lib::EdgeSearch;
</span><span class="boring">use graph_api_lib::VertexSearch;
</span><span class="boring">use graph_api_simplegraph::SimpleGraph;
</span><span class="boring">use graph_api_lib::Graph;
</span><span class="boring">use graph_api_lib::VertexReference;
</span><span class="boring">use graph_api_lib::EdgeReference;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span><span class="boring">// Create a new graph
</span><span class="boring">let mut graph = SimpleGraph::new();
</span><span class="boring">// Populate the graph with test data
</span><span class="boring">let refs = populate_graph(&amp;mut graph);
</span>// Collect names of all projects
let project_names = graph.walk()
    .vertices(VertexSearch::scan().with_label(Project::label()))
    .map(|v, _| v.project::&lt;Project&lt;_&gt;&gt;().unwrap().name().to_string())
    .collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
<h3 id="computing-aggregates"><a class="header" href="#computing-aggregates">Computing Aggregates</a></h3>
<pre><code class="language-rust noplayground"><span class="boring">use graph_api_test::Vertex;
</span><span class="boring">use graph_api_test::Edge;
</span><span class="boring">use graph_api_test::VertexExt;
</span><span class="boring">use graph_api_test::EdgeExt;
</span><span class="boring">use graph_api_test::Person;
</span><span class="boring">use graph_api_test::Project;
</span><span class="boring">use graph_api_test::populate_graph;
</span><span class="boring">use graph_api_lib::EdgeSearch;
</span><span class="boring">use graph_api_lib::VertexSearch;
</span><span class="boring">use graph_api_simplegraph::SimpleGraph;
</span><span class="boring">use graph_api_lib::Graph;
</span><span class="boring">use graph_api_lib::VertexReference;
</span><span class="boring">use graph_api_lib::EdgeReference;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span><span class="boring">// Create a new graph
</span><span class="boring">let mut graph = SimpleGraph::new();
</span><span class="boring">// Populate the graph with test data
</span><span class="boring">let refs = populate_graph(&amp;mut graph);
</span>// Calculate average age of all people
let (sum, count) = graph.walk()
    .vertices(VertexSearch::scan().with_label(Person::label()))
    .fold((0, 0), |(sum, count), v, _| {
        let age = v.project::&lt;Person&lt;_&gt;&gt;().unwrap().age();
        (sum + age, count + 1)
    });
    
let average_age = if count &gt; 0 { sum as f64 / count as f64 } else { 0.0 };</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation-guide-for-graph-backends"><a class="header" href="#implementation-guide-for-graph-backends">Implementation Guide for Graph Backends</a></h1>
<p>This guide will walk you through the process of implementing a new graph backend for the Graph API. While the Graph API
provides several ready-to-use implementations (like <code>SimpleGraph</code> and <code>PetGraph</code>), you might want to build your own
implementation to support specific requirements or optimize for particular use cases.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>Implementing a graph backend involves satisfying the requirements of the <code>Graph</code> trait and its associated types. This
guide will walk you through:</p>
<ol>
<li>Understanding the core components needed for a graph implementation</li>
<li>Creating the fundamental data structures</li>
<li>Implementing the required traits</li>
<li>Building support for indexing (optional but recommended)</li>
<li>Testing your implementation</li>
</ol>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<p>A Graph API implementation requires several components:</p>
<ol>
<li><strong>Graph Structure</strong>: The primary data structure that stores vertices and edges</li>
<li><strong>Vertex and Edge IDs</strong>: Unique identifiers for graph elements</li>
<li><strong>References</strong>: Structures that refer to vertices and edges</li>
<li><strong>Iterators</strong>: Types for traversing vertices and edges</li>
<li><strong>Index Support</strong>: Optional components for efficient element lookup by property values</li>
</ol>
<h2 id="step-1-define-ids-and-basic-structures"><a class="header" href="#step-1-define-ids-and-basic-structures">Step 1: Define IDs and Basic Structures</a></h2>
<p>Start by defining your graph ID types and core data structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example vertex and edge IDs
pub struct MyVertexId {
    label: u16,    // Identifies the variant of the vertex enum
    index: u32,    // Unique index within that label
}

pub struct MyEdgeId {
    label: u16,    // Identifies the variant of the edge enum
    index: u32,    // Unique index within that label
    from: MyVertexId,
    to: MyVertexId,
}

// Import the necessary traits
use graph_api_lib::{
    Graph, Element, EdgeSearch, VertexSearch,
    SupportsVertexLabelIndex, SupportsEdgeLabelIndex, SupportsVertexHashIndex,
    SupportsVertexRangeIndex, SupportsEdgeRangeIndex, SupportsVertexFullTextIndex,
    SupportsEdgeAdjacentLabelIndex, SupportsClear
};

// Main graph structure
pub struct MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,  // From graph_api_lib
    Edge: Element,    // From graph_api_lib
{
    // Your internal storage goes here
    // Example:
    vertices: Vec&lt;YourVertexStorage&lt;Vertex&gt;&gt;,
    edges: Vec&lt;YourEdgeStorage&lt;Edge&gt;&gt;,
    // More fields as needed (indexes, etc.)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-2-define-reference-types"><a class="header" href="#step-2-define-reference-types">Step 2: Define Reference Types</a></h2>
<p>Create reference types that will be returned when accessing vertices and edges:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyVertexReference&lt;'graph, Graph&gt;
where
    Graph: graph_api_lib::Graph,
{
    id: Graph::VertexId,
    weight: &amp;'graph Graph::Vertex,
    // Additional fields if needed
}

pub struct MyVertexReferenceMut&lt;'graph, Graph&gt;
where
    Graph: graph_api_lib::Graph,
{
    id: Graph::VertexId,
    weight: &amp;'graph mut Graph::Vertex,
    // Additional fields (like a reference to indexes)
    indexes: &amp;'graph mut YourIndexStorage,
}

// Similar for EdgeReference and EdgeReferenceMut
<span class="boring">}</span></code></pre></pre>
<h2 id="step-3-implement-the-required-traits"><a class="header" href="#step-3-implement-the-required-traits">Step 3: Implement the Required Traits</a></h2>
<p>Now implement the required traits for your reference types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'graph, Graph&gt; graph_api_lib::VertexReference&lt;'graph, Graph&gt; for MyVertexReference&lt;'graph, Graph&gt;
where
    Graph: graph_api_lib::Graph,
{
    fn id(&amp;self) -&gt; Graph::VertexId {
        self.id
    }

    fn weight(&amp;self) -&gt; &amp;Graph::Vertex {
        self.weight
    }

    fn project&lt;
        'reference,
        T: graph_api_lib::Project&lt;'reference, &lt;Graph as graph_api_lib::Graph&gt;::Vertex&gt;,
    &gt;(
        &amp;'reference self,
    ) -&gt; Option&lt;T&gt; {
        graph_api_lib::Project::project(self.weight)
    }
}

// Implement VertexReferenceMut, EdgeReference, EdgeReferenceMut similarly
<span class="boring">}</span></code></pre></pre>
<h2 id="step-4-define-iterator-types"><a class="header" href="#step-4-define-iterator-types">Step 4: Define Iterator Types</a></h2>
<p>Create iterator types for walking through vertices and edges:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyVertexIter&lt;'search, 'graph, Graph&gt;
where
    Graph: graph_api_lib::Graph + 'graph,
{
    // Internal state needed for iteration
    // Example:
    vertices: &amp;'graph [YourVertexStorage&lt;Graph::Vertex&gt;],
    current_label: usize,
    current_index: usize,
    count: usize,
    limit: usize,
}

// Implement Iterator for MyVertexIter

impl&lt;'graph, Graph&gt; Iterator for MyVertexIter&lt;'_, 'graph, Graph&gt;
where
    Graph: graph_api_lib::Graph&lt;VertexId=MyVertexId&gt; + 'graph,
{
    type Item = MyVertexReference&lt;'graph, Graph&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // Your iterator implementation
        // Return the next vertex reference, or None if done
    }
}

// Similarly for MyEdgeIter
<span class="boring">}</span></code></pre></pre>
<h2 id="step-5-implement-the-graph-trait"><a class="header" href="#step-5-implement-the-graph-trait">Step 5: Implement the Graph Trait</a></h2>
<p>Now implement the <code>Graph</code> trait for your graph structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// First implement the core Graph trait
impl&lt;Vertex, Edge&gt; Graph for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Define the core types
    type Vertex = Vertex;
    type Edge = Edge;
    type VertexId = MyVertexId;
    type EdgeId = MyEdgeId;

    // Reference types
    type VertexReference&lt;'graph&gt; = MyVertexReference&lt;'graph, Self&gt;
    where
        Self: 'graph;
    type VertexReferenceMut&lt;'graph&gt; = MyVertexReferenceMut&lt;'graph, Self&gt;
    where
        Self: 'graph;
    type EdgeReference&lt;'graph&gt; = MyEdgeReference&lt;'graph, Self&gt;
    where
        Self: 'graph;
    type EdgeReferenceMut&lt;'graph&gt; = MyEdgeReferenceMut&lt;'graph, Self&gt;
    where
        Self: 'graph;

    // Iterator types
    type EdgeIter&lt;'search, 'graph&gt; = MyEdgeIter&lt;'search, 'graph, Self&gt;
    where
        Self: 'graph;
    type VertexIter&lt;'search, 'graph&gt; = MyVertexIter&lt;'search, 'graph, Self&gt;
    where
        Self: 'graph;

    // Implement the core graph operations
    fn add_vertex(&amp;mut self, vertex: Self::Vertex) -&gt; Self::VertexId {
        // Implementation details
    }

    fn add_edge(
        &amp;mut self,
        from: Self::VertexId,
        to: Self::VertexId,
        edge: Self::Edge,
    ) -&gt; Self::EdgeId {
        // Implementation details
    }

    fn remove_vertex(&amp;mut self, id: Self::VertexId) -&gt; Option&lt;Self::Vertex&gt; {
        // Implementation details
    }

    fn remove_edge(&amp;mut self, id: Self::EdgeId) -&gt; Option&lt;Self::Edge&gt; {
        // Implementation details
    }

    fn vertex(&amp;self, id: Self::VertexId) -&gt; Option&lt;Self::VertexReference&lt;'_&gt;&gt; {
        // Implementation details
    }

    fn vertex_mut(&amp;mut self, id: Self::VertexId) -&gt; Option&lt;Self::VertexReferenceMut&lt;'_&gt;&gt; {
        // Implementation details
    }

    fn vertices&lt;'search&gt;(
        &amp;self,
        vertex_search: &amp;VertexSearch&lt;'search, Self&gt;,
    ) -&gt; Self::VertexIter&lt;'search, '_&gt; {
        // Implementation details
    }

    fn edge(&amp;self, id: Self::EdgeId) -&gt; Option&lt;Self::EdgeReference&lt;'_&gt;&gt; {
        // Implementation details
    }

    fn edge_mut(&amp;mut self, id: Self::EdgeId) -&gt; Option&lt;Self::EdgeReferenceMut&lt;'_&gt;&gt; {
        // Implementation details
    }

    fn edges&lt;'search&gt;(
        &amp;self,
        id: Self::VertexId,
        search: &amp;EdgeSearch&lt;'search, Self&gt;,
    ) -&gt; Self::EdgeIter&lt;'search, '_&gt; {
        // Implementation details
    }

    // No clear method here - it's moved to the SupportsClear trait
}

// Then implement support traits for the features you want to provide
impl&lt;Vertex, Edge&gt; SupportsVertexLabelIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Any trait-specific methods would go here
}

impl&lt;Vertex, Edge&gt; SupportsEdgeLabelIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Any trait-specific methods would go here
}

impl&lt;Vertex, Edge&gt; SupportsVertexHashIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Any trait-specific methods would go here
}

// Add more support trait implementations as needed

// Implement SupportsClear if you want to support clearing the graph
impl&lt;Vertex, Edge&gt; SupportsClear for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    fn clear(&amp;mut self) {
        // Clear all graph data
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-6-implement-indexing-optional"><a class="header" href="#step-6-implement-indexing-optional">Step 6: Implement Indexing (Optional)</a></h2>
<p>If your graph supports indexes, you'll need to implement the index handling. This typically involves:</p>
<ol>
<li>Creating a mutation listener for updating indexes on vertex/edge changes</li>
<li>Creating storage for different index types (hash, range, full-text)</li>
<li>Implementing index update logic when vertices or edges are modified</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example MutationListener for vertex modifications
pub struct MyVertexMutationListener&lt;'reference, Element&gt; {
    // References to indexes and ID information
    indexes: &amp;'reference mut YourIndexStorage,
    id: YourInternalId,
}

impl&lt;'reference, Element&gt; graph_api_lib::MutationListener&lt;'reference, Element&gt;
for MyVertexMutationListener&lt;'reference, Element&gt;
where
    Element: graph_api_lib::Element,
{
    fn update(&amp;mut self, index: &lt;Element::Label as Label&gt;::Index, before: Value, after: Value) {
        // Update the indexes with the changed value
        // Remove old index entry
        // Add new index entry
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-7-advanced-features"><a class="header" href="#step-7-advanced-features">Step 7: Advanced Features</a></h2>
<p>Consider implementing additional features:</p>
<ol>
<li><strong>Custom Traversal Optimizations</strong>: For specific types of queries</li>
<li><strong>Specialized Index Types</strong>: For domain-specific data types</li>
<li><strong>Persistence Layer</strong>: If your graph needs to be saved/loaded</li>
<li><strong>Concurrency Support</strong>: For multi-threaded access</li>
</ol>
<h2 id="step-8-testing"><a class="header" href="#step-8-testing">Step 8: Testing</a></h2>
<p>Test your implementation using the Graph API's test suite:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use crate::MyGraph;
    use graph_api_test::test_suite;

    test_suite!(MyGraph::new());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-26"><a class="header" href="#best-practices-26">Best Practices</a></h2>
<ol>
<li><strong>Optimized ID Types</strong>: Use small, efficient ID types (consider using newtype patterns)</li>
<li><strong>Memory Efficiency</strong>: Consider spatial locality and data structure layout</li>
<li><strong>Index Handling</strong>: Carefully manage indexes to avoid inconsistencies</li>
<li><strong>Error Handling</strong>: Provide meaningful errors for invalid operations</li>
<li><strong>Documentation</strong>: Document the specific characteristics of your implementation</li>
</ol>
<h2 id="example-implementing-a-simple-adjacency-list-graph"><a class="header" href="#example-implementing-a-simple-adjacency-list-graph">Example: Implementing a Simple Adjacency List Graph</a></h2>
<p>Here's a sketch of how you might implement a simple adjacency list graph:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AdjListGraph&lt;V, E&gt; {
    vertices: Vec&lt;Option&lt;V&gt;&gt;,
    edges: Vec&lt;Option&lt;EdgeData&lt;E&gt;&gt;&gt;,
    adjacency: Vec&lt;Vec&lt;EdgeIndex&gt;&gt;, // Outgoing edges for each vertex
}

struct EdgeData&lt;E&gt; {
    edge: E,
    from: VertexIndex,
    to: VertexIndex,
}

// Implement the necessary traits...
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Implementing a graph backend requires careful attention to detail, but the Graph API's trait system provides a clear
structure to follow. By implementing the core traits and considering performance implications, you can create a
specialized graph backend that perfectly fits your use case.</p>
<p>Remember to check the source code of existing implementations like <code>SimpleGraph</code> for more detailed examples of how to
handle complex scenarios like indexing and traversal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-graph-implementation"><a class="header" href="#creating-a-graph-implementation">Creating a Graph Implementation</a></h1>
<p>This chapter provides detailed guidance for implementing a new Graph API backend. It expands on the concepts introduced
in the <a href="implementation/./guide.html">Implementation Guide for Graph Backends</a>.</p>
<h2 id="design-considerations"><a class="header" href="#design-considerations">Design Considerations</a></h2>
<p>Before starting implementation, consider these key design decisions:</p>
<ol>
<li>
<p><strong>Storage Strategy</strong>: How will you store vertices and edges? Options include:</p>
<ul>
<li>Adjacency lists (good for sparse graphs)</li>
<li>Adjacency matrices (good for dense graphs)</li>
<li>Edge lists</li>
<li>Custom hybrid approaches</li>
</ul>
</li>
<li>
<p><strong>Memory vs. Performance Trade-offs</strong>: Will your implementation prioritize:</p>
<ul>
<li>Low memory usage</li>
<li>Fast traversal operations</li>
<li>Fast mutation operations</li>
<li>Fast index lookups</li>
</ul>
</li>
<li>
<p><strong>Feature Support</strong>: Which Graph API features will you support?</p>
<ul>
<li>Basic graph operations (required)</li>
<li>Label indexes</li>
<li>Hash indexes</li>
<li>Range indexes</li>
<li>Full-text indexes</li>
<li>Other specialized indexes</li>
</ul>
</li>
<li>
<p><strong>Usage Context</strong>: Is your implementation designed for:</p>
<ul>
<li>General-purpose use</li>
<li>Specific application domains</li>
<li>Particular data patterns</li>
</ul>
</li>
</ol>
<h2 id="core-implementation-approach"><a class="header" href="#core-implementation-approach">Core Implementation Approach</a></h2>
<p>A typical implementation follows these steps:</p>
<h3 id="1-define-id-types"><a class="header" href="#1-define-id-types">1. Define ID Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyVertexId {
    // Implementation-specific fields
    label: u16,
    index: u32,
}

pub struct MyEdgeId {
    // Implementation-specific fields
    label: u16,
    index: u32,
    from: MyVertexId,
    to: MyVertexId,
}
<span class="boring">}</span></code></pre></pre>
<p>Make sure your ID types:</p>
<ul>
<li>Implement <code>Copy</code>, <code>Clone</code>, <code>Debug</code>, <code>Eq</code>, <code>PartialEq</code>, and <code>Hash</code></li>
<li>Are small and efficient (IDs are used extensively)</li>
<li>Can be converted to <code>ElementId</code></li>
</ul>
<h3 id="2-create-core-graph-structure"><a class="header" href="#2-create-core-graph-structure">2. Create Core Graph Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Your internal storage
    vertices: Vec&lt;VertexCollection&gt;,
    edges: Vec&lt;EdgeCollection&gt;,
    // Optional index structures
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-implement-reference-types"><a class="header" href="#3-implement-reference-types">3. Implement Reference Types</a></h3>
<p>Reference types provide safe access to graph elements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyVertexReference&lt;'graph, Graph&gt;
where
    Graph: graph_api_lib::Graph,
{
    id: Graph::VertexId,
    weight: &amp;'graph Graph::Vertex,
}

pub struct MyVertexReferenceMut&lt;'graph, Graph&gt;
where
    Graph: graph_api_lib::Graph,
{
    id: Graph::VertexId,
    weight: &amp;'graph mut Graph::Vertex,
    // Reference to indexes for updating
    indexes: &amp;'graph mut IndexCollection,
}
<span class="boring">}</span></code></pre></pre>
<p>Implement similar types for <code>EdgeReference</code> and <code>EdgeReferenceMut</code>.</p>
<h3 id="4-implement-iterator-types"><a class="header" href="#4-implement-iterator-types">4. Implement Iterator Types</a></h3>
<p>Create iterator types for traversing vertices and edges:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyVertexIter&lt;'search, 'graph, Graph&gt;
where
    Graph: graph_api_lib::Graph + 'graph,
{
    // Internal state
    graph: &amp;'graph Graph,
    current_position: usize,
    // ...
}

impl&lt;'graph, Graph&gt; Iterator for MyVertexIter&lt;'_, 'graph, Graph&gt;
where
    Graph: graph_api_lib::Graph&lt;VertexId=MyVertexId&gt; + 'graph,
{
    type Item = MyVertexReference&lt;'graph, Graph&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // Implementation
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-mutation-listener-for-indexes"><a class="header" href="#5-mutation-listener-for-indexes">5. Mutation Listener for Indexes</a></h3>
<p>If your graph supports indexes, implement a mutation listener:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyMutationListener&lt;'reference, Element&gt; {
    // References to index structures
    indexes: &amp;'reference mut IndexCollection,
    id: VertexInternalId,
}

impl&lt;'reference, Element&gt; graph_api_lib::MutationListener&lt;'reference, Element&gt;
for MyMutationListener&lt;'reference, Element&gt;
where
    Element: graph_api_lib::Element,
{
    fn update(&amp;mut self, index: &lt;Element::Label as Label&gt;::Index, before: Value, after: Value) {
        // Update indexes as needed
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-tips"><a class="header" href="#implementation-tips">Implementation Tips</a></h2>
<h3 id="efficiency-considerations"><a class="header" href="#efficiency-considerations">Efficiency Considerations</a></h3>
<ol>
<li>
<p><strong>Memory Layout</strong>: Keep related data together to improve cache locality.</p>
</li>
<li>
<p><strong>Data Structures</strong>: Choose the right data structures for your use case:</p>
<ul>
<li><code>Vec</code> for dense storage with stable IDs</li>
<li><code>HashMap</code> for sparse storage with integer IDs</li>
<li><code>BTreeMap</code> for ordered collections</li>
<li>Consider specialized structures like <code>smallbox</code> for tiny collections</li>
</ul>
</li>
<li>
<p><strong>Avoid Cloning</strong>: Pass references whenever possible instead of cloning data.</p>
</li>
<li>
<p><strong>Index Carefully</strong>: Indexes improve query performance but add overhead to mutations.</p>
</li>
</ol>
<h3 id="supporting-advanced-features"><a class="header" href="#supporting-advanced-features">Supporting Advanced Features</a></h3>
<p>For implementing advanced features like range and full-text indexing:</p>
<ol>
<li><strong>Range Indexes</strong>: Consider using <code>BTreeMap</code> or similar ordered collections.</li>
<li><strong>Full-text Indexes</strong>: Implement tokenization, stemming, and inverted indexes.</li>
<li><strong>Custom Properties</strong>: Support for user-defined property types may require generics.</li>
</ol>
<h2 id="example-implementation-structure"><a class="header" href="#example-implementation-structure">Example Implementation Structure</a></h2>
<p>A typical implementation might be organized like this:</p>
<pre><code>my_graph/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs          # Main exports and Graph trait implementation
â”‚   â”œâ”€â”€ id.rs           # ID type definitions
â”‚   â”œâ”€â”€ graph/
â”‚   â”‚   â”œâ”€â”€ mod.rs      # Core graph implementation
â”‚   â”‚   â”œâ”€â”€ iter.rs     # Iterator implementations
â”‚   â”‚   â””â”€â”€ debug.rs    # Debug helpers
â”‚   â””â”€â”€ index/
â”‚       â”œâ”€â”€ mod.rs      # Index type definitions
â”‚       â”œâ”€â”€ hash.rs     # Hash index implementation
â”‚       â”œâ”€â”€ range.rs    # Range index implementation
â”‚       â””â”€â”€ full_text.rs # Full-text index implementation
â””â”€â”€ tests/
    â””â”€â”€ integration.rs  # Integration tests using test_suite!
</code></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>After implementing the basic graph functionality:</p>
<ol>
<li>Review the <a href="implementation/./testing.html">Testing Your Implementation</a> chapter for testing strategies.</li>
<li>Check the <a href="implementation/./indexes.html">Implementing Indexes</a> chapter for adding index support.</li>
</ol>
<p>Remember that implementing a graph backend is an iterative process. Start with a minimal working implementation, test it
thoroughly, and then add more features incrementally.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-your-implementation"><a class="header" href="#testing-your-implementation">Testing Your Implementation</a></h1>
<p>Testing a graph implementation thoroughly is essential to ensure correctness, reliability, and performance. The Graph
API provides a comprehensive test suite to verify that your implementation meets all the requirements of the Graph API
traits.</p>
<h2 id="using-the-test-suite"><a class="header" href="#using-the-test-suite">Using the Test Suite</a></h2>
<p>The <code>graph-api-test</code> crate provides a test suite that can be used to verify your graph implementation. The test suite
covers:</p>
<ol>
<li>Basic graph operations (adding/removing vertices and edges)</li>
<li>Graph traversal and walker steps</li>
<li>Index functionality</li>
<li>Edge cases and error handling</li>
<li>Fuzzing tests for robustness</li>
</ol>
<h3 id="setting-up-the-test-suite"><a class="header" href="#setting-up-the-test-suite">Setting Up the Test Suite</a></h3>
<p>To test your implementation:</p>
<ol>
<li>Add <code>graph-api-test</code> as a dev-dependency in your <code>Cargo.toml</code>:</li>
</ol>
<pre><code class="language-toml">[dev-dependencies]
graph-api-test = { version = "0.1.5", features = ["vertex-hash-index", "vertex-label-index", "vertex-full-text-index", "vertex-range-index", "edge-label-index"] }

</code></pre>
<ol start="2">
<li>Create a test module in your crate:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use crate::MyGraph;
    use graph_api_test::test_suite;

    test_suite!(MyGraph::new());
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>test_suite!</code> macro generates test cases for all the functionality supported by the Graph API.</p>
<h2 id="understanding-test-coverage"><a class="header" href="#understanding-test-coverage">Understanding Test Coverage</a></h2>
<p>The test suite covers several areas:</p>
<h3 id="basic-graph-operations"><a class="header" href="#basic-graph-operations">Basic Graph Operations</a></h3>
<ul>
<li>Adding vertices and edges</li>
<li>Removing vertices and edges</li>
<li>Retrieving vertices and edges by ID</li>
<li>Modifying vertex and edge properties</li>
</ul>
<h3 id="walker-steps-2"><a class="header" href="#walker-steps-2">Walker Steps</a></h3>
<p>Tests for all walker steps:</p>
<ul>
<li><code>vertices</code>, <code>vertices_by_id</code>, <code>edges</code></li>
<li><code>filter</code>, <code>map</code>, <code>limit</code>, <code>first</code></li>
<li><code>head</code>, <code>tail</code>, <code>detour</code></li>
<li><code>collect</code>, <code>count</code>, <code>into_iter</code></li>
<li><code>probe</code>, <code>mutate</code>, <code>dbg</code></li>
<li>Context operations</li>
</ul>
<h3 id="index-tests"><a class="header" href="#index-tests">Index Tests</a></h3>
<p>If your graph supports indexes, tests for:</p>
<ul>
<li>Vertex and edge label indexes</li>
<li>Hash indexes</li>
<li>Range indexes</li>
<li>Full-text indexes</li>
</ul>
<h3 id="conditional-feature-testing"><a class="header" href="#conditional-feature-testing">Conditional Feature Testing</a></h3>
<p>The test suite adapts to the features your graph implementation supports. For example, if your graph doesn't support
range indexes, those tests will be skipped.</p>
<h2 id="writing-additional-tests"><a class="header" href="#writing-additional-tests">Writing Additional Tests</a></h2>
<p>While the test suite covers most functionality, you should write additional tests for:</p>
<ol>
<li><strong>Implementation-specific features</strong>: Any custom functionality your graph provides.</li>
<li><strong>Edge cases</strong>: Unusual usage patterns specific to your implementation.</li>
<li><strong>Performance tests</strong>: Verify that your implementation meets performance requirements.</li>
</ol>
<h3 id="example-testing-a-custom-feature"><a class="header" href="#example-testing-a-custom-feature">Example: Testing a Custom Feature</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_my_custom_feature() {
    let mut graph = MyGraph::new();

    // Test setup
    let vertex = graph.add_vertex(Vertex::Person { name: "Test".to_string(), ... });

    // Test the custom feature
    let result = graph.my_custom_feature(vertex);

    // Assertions
    assert_eq!(result, expected_value);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fuzzing-tests"><a class="header" href="#fuzzing-tests">Fuzzing Tests</a></h2>
<p>The test suite includes fuzzing tests that apply random sequences of operations to your graph to find edge cases and
bugs. These tests help ensure your implementation is robust against unexpected usage patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features-and-extensions"><a class="header" href="#features-and-extensions">Features and Extensions</a></h1>
<p>This chapter covers how to extend your graph implementation with additional features and capabilities beyond the basic
Graph API requirements.</p>
<h2 id="core-vs-extended-features"><a class="header" href="#core-vs-extended-features">Core vs. Extended Features</a></h2>
<p>The Graph API defines a set of core features required for all graph implementations, plus optional extended features:</p>
<h3 id="required-core-features"><a class="header" href="#required-core-features">Required Core Features</a></h3>
<p>All graph implementations must support:</p>
<ol>
<li><strong>Basic Graph Management</strong>: Adding/removing vertices and edges</li>
<li><strong>Element Access</strong>: Retrieving vertices and edges by ID</li>
<li><strong>Graph Traversal</strong>: Supporting the walker API</li>
<li><strong>Vertex and Edge Types</strong>: Using the client's vertex and edge enum definitions</li>
</ol>
<h3 id="optional-extended-features"><a class="header" href="#optional-extended-features">Optional Extended Features</a></h3>
<p>Optional features you may want to support:</p>
<ol>
<li><strong>Indexing</strong>: Various indexing strategies (label, hash, range, full-text)</li>
<li><strong>Graph Clearing</strong>: Efficiently removing all elements</li>
<li><strong>Custom Traversal Steps</strong>: Graph-specific optimization for certain traversals</li>
<li><strong>Persistence</strong>: Saving and loading graphs from storage</li>
<li><strong>Concurrency</strong>: Thread-safe access to graph elements</li>
</ol>
<h2 id="declaring-feature-support"><a class="header" href="#declaring-feature-support">Declaring Feature Support</a></h2>
<p>The Graph API uses separate support traits to indicate which features a graph implementation supports:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// First implement the core Graph trait
impl&lt;Vertex, Edge&gt; Graph for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Core Graph functionality
    // ...
}

// Then implement the relevant support traits
impl&lt;Vertex, Edge&gt; SupportsVertexLabelIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Any trait-specific methods if needed
}

impl&lt;Vertex, Edge&gt; SupportsEdgeLabelIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Any trait-specific methods if needed
}

// Skip implementing SupportsVertexFullTextIndex if not supported
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-optional-features"><a class="header" href="#implementing-optional-features">Implementing Optional Features</a></h2>
<h3 id="index-support"><a class="header" href="#index-support">Index Support</a></h3>
<p>To add index support to your graph implementation:</p>
<ol>
<li><strong>Declare Support</strong>: Update your <code>Graph</code> implementation to declare support for specific index types.</li>
<li><strong>Create Index Structures</strong>: Implement the appropriate data structures for each index type.</li>
<li><strong>Update Index Maintenance</strong>: Ensure indexes are updated when vertices/edges are added, modified, or removed.</li>
</ol>
<p>Example for hash index support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Declare support
type SupportsVertexHashIndex = Supported;

// Create index structure
struct HashIndex&lt;K, V&gt; {
    map: HashMap&lt;K, HashSet&lt;V&gt;&gt;,
}

impl&lt;K: Hash + Eq, V: Copy + Eq + Hash&gt; HashIndex&lt;K, V&gt; {
    fn new() -&gt; Self {
        Self {
            map: HashMap::new(),
        }
    }

    fn insert(&amp;mut self, key: K, value: V) {
        self.map.entry(key).or_default().insert(value);
    }

    fn remove(&amp;mut self, key: &amp;K, value: &amp;V) {
        if let Some(values) = self.map.get_mut(key) {
            values.remove(value);
            if values.is_empty() {
                self.map.remove(key);
            }
        }
    }

    fn get(&amp;self, key: &amp;K) -&gt; impl Iterator&lt;Item=V&gt; + '_ {
        self.map
            .get(key)
            .into_iter()
            .flat_map(|values| values.iter().copied())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="graph-clearing"><a class="header" href="#graph-clearing">Graph Clearing</a></h3>
<p>To support clearing all elements from a graph, implement the <code>SupportsClear</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// First implement the Graph trait
impl&lt;Vertex, Edge&gt; Graph for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // ...core graph functionality
}

// Then implement the SupportsClear trait
impl&lt;Vertex, Edge&gt; SupportsClear for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    fn clear(&amp;mut self) {
        self.vertices.clear();
        self.edges.clear();
        self.indexes.iter_mut().for_each(|idx| idx.clear());
        // Clear any other data structures
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="extending-the-walker-api"><a class="header" href="#extending-the-walker-api">Extending the Walker API</a></h2>
<p>You can extend the Walker API for your graph implementation by creating custom steps:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a custom step extension trait
pub trait CustomStepExt&lt;'g, G: Graph&gt; {
    // A custom step that applies a specific algorithm
    fn my_custom_step(self, param: CustomParam) -&gt; Self;
}

// Implement for the appropriate walker type
impl&lt;'g, G: Graph&gt; CustomStepExt&lt;'g, G&gt; for VertexWalker&lt;'g, G&gt; {
    fn my_custom_step(self, param: CustomParam) -&gt; Self {
        // Implementation that uses the walker's state
        // and applies your custom algorithm
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>See <a href="https://github.com/BrynCooke/graph-api/blob/main/graph-api-lib/examples/custom_step.rs">custom_step.rs</a> for a full
example.</p>
<h2 id="integration-with-external-systems"><a class="header" href="#integration-with-external-systems">Integration with External Systems</a></h2>
<p>You might want to integrate your graph implementation with external systems:</p>
<h3 id="serializationdeserialization"><a class="header" href="#serializationdeserialization">Serialization/Deserialization</a></h3>
<p>Add support for saving and loading graphs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;V, E&gt; MyGraph&lt;V, E&gt;
where
    V: Element + Serialize + for&lt;'de&gt; Deserialize&lt;'de&gt;,
    E: Element + Serialize + for&lt;'de&gt; Deserialize&lt;'de&gt;,
{
    pub fn save&lt;W: Write&gt;(&amp;self, writer: W) -&gt; Result&lt;(), Error&gt; {
        // Serialize the graph
    }

    pub fn load&lt;R: Read&gt;(reader: R) -&gt; Result&lt;Self, Error&gt; {
        // Deserialize the graph
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="database-integration"><a class="header" href="#database-integration">Database Integration</a></h3>
<p>Create adapters for database systems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DatabaseBackedGraph&lt;V, E&gt; {
    connection: DbConnection,
    // Other fields for caching, etc.
    _phantom: PhantomData&lt;(V, E)&gt;,
}

impl&lt;V, E&gt; Graph for DatabaseBackedGraph&lt;V, E&gt;
where
    V: Element,
    E: Element,
{
    // Implement Graph trait with database operations
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="feature-compatibility"><a class="header" href="#feature-compatibility">Feature Compatibility</a></h2>
<p>When implementing optional features, use trait bounds in your API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn search_full_text&lt;G&gt;(graph: &amp;G, text: &amp;str) -&gt; Vec&lt;G::VertexId&gt;
where
    G: Graph + SupportsVertexFullTextIndex,
{
    // Can safely use full text search here
    graph.walk()
        .vertices(Vertex::person_by_biography(text))
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-for-extensions"><a class="header" href="#best-practices-for-extensions">Best Practices for Extensions</a></h2>
<p>When adding features and extensions, follow these best practices:</p>
<ol>
<li><strong>Maintain Core API Compatibility</strong>: Ensure extensions don't break the core Graph API.</li>
<li><strong>Document Extensions Thoroughly</strong>: Clearly document what extensions are available and how to use them.</li>
<li><strong>Test Extensions Separately</strong>: Write dedicated tests for extended features.</li>
<li><strong>Consider Performance Impact</strong>: Ensure extensions don't negatively impact core operations.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-indexes"><a class="header" href="#implementing-indexes">Implementing Indexes</a></h1>
<p>Indexes are a critical component for efficient graph operations, allowing for quick lookups of elements based on
property values. This chapter guides you through implementing different types of indexes in your graph backend.</p>
<h2 id="index-types-overview"><a class="header" href="#index-types-overview">Index Types Overview</a></h2>
<p>The Graph API supports four main types of indexes:</p>
<ol>
<li><strong>Label Indexes</strong>: Index vertices and edges by their label (enum variant)</li>
<li><strong>Hash Indexes</strong>: Lookup elements by a property value using exact matching</li>
<li><strong>Range Indexes</strong>: Find elements with property values in a specific range</li>
<li><strong>Full-Text Indexes</strong>: Search text properties using more complex matching</li>
</ol>
<h2 id="the-index-infrastructure"><a class="header" href="#the-index-infrastructure">The Index Infrastructure</a></h2>
<h3 id="the-index-trait"><a class="header" href="#the-index-trait">The Index Trait</a></h3>
<p>The Graph API defines the <code>Index</code> trait to represent element indexes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Index
where
    Self: Sized + Copy + Eq + Hash + Debug,
{
    /// The type of the element being indexed
    fn ty(&amp;self) -&gt; TypeId;

    /// The index ordinal
    fn ordinal(&amp;self) -&gt; usize;

    /// The type of index
    fn index_type(&amp;self) -&gt; IndexType;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="index-types"><a class="header" href="#index-types">Index Types</a></h3>
<p>The <code>IndexType</code> enum defines the supported index types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum IndexType {
    Hash,       // Exact matching
    Range,      // Range queries
    FullText,   // Text search
}
<span class="boring">}</span></code></pre></pre>
<h3 id="declare-index-support"><a class="header" href="#declare-index-support">Declare Index Support</a></h3>
<p>To support indexes in your implementation, implement the appropriate support traits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Vertex, Edge&gt; Graph for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{
    // Core Graph functionality
    // ...
}

// Implement support traits for the indexing features you want to provide
impl&lt;Vertex, Edge&gt; SupportsVertexLabelIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsEdgeLabelIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsVertexHashIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsEdgeHashIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsVertexRangeIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsEdgeRangeIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}

impl&lt;Vertex, Edge&gt; SupportsVertexFullTextIndex for MyGraph&lt;Vertex, Edge&gt;
where
    Vertex: Element,
    Edge: Element,
{}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-label-indexes"><a class="header" href="#implementing-label-indexes">Implementing Label Indexes</a></h2>
<p>Label indexes allow for quickly finding all vertices or edges of a specific label (enum variant).</p>
<h3 id="data-structure"><a class="header" href="#data-structure">Data Structure</a></h3>
<p>A simple label index can be implemented using a vector of sets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Stores vertex IDs by label
struct LabelIndex {
    // One entry per label, containing all vertex IDs with that label
    indexes: Vec&lt;HashSet&lt;VertexId&gt;&gt;,
}

impl LabelIndex {
    fn new(label_count: usize) -&gt; Self {
        Self {
            indexes: (0..label_count).map(|_| HashSet::new()).collect(),
        }
    }

    fn insert(&amp;mut self, label: usize, id: VertexId) {
        self.indexes[label].insert(id);
    }

    fn remove(&amp;mut self, label: usize, id: &amp;VertexId) {
        self.indexes[label].remove(id);
    }

    fn get(&amp;self, label: usize) -&gt; impl Iterator&lt;Item=VertexId&gt; + '_ {
        self.indexes[label].iter().copied()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-with-vertexedge-operations"><a class="header" href="#integration-with-vertexedge-operations">Integration with Vertex/Edge Operations</a></h3>
<p>Update label indexes during vertex/edge operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_vertex(&amp;mut self, vertex: Self::Vertex) -&gt; Self::VertexId {
    let label_idx = vertex.label().ordinal();
    let vertex_id = // create a new vertex ID

        // Add to label index
        self.label_index.insert(label_idx, vertex_id);

    // Rest of implementation
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-hash-indexes"><a class="header" href="#implementing-hash-indexes">Implementing Hash Indexes</a></h2>
<p>Hash indexes allow for quick lookups by property value using exact matching.</p>
<h3 id="data-structure-1"><a class="header" href="#data-structure-1">Data Structure</a></h3>
<p>A hash index maps property values to sets of element IDs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HashIndex&lt;K, V&gt; {
    map: HashMap&lt;K, HashSet&lt;V&gt;&gt;,
}

impl&lt;K: Hash + Eq, V: Copy + Eq + Hash&gt; HashIndex&lt;K, V&gt; {
    fn new() -&gt; Self {
        Self {
            map: HashMap::new(),
        }
    }

    fn insert(&amp;mut self, key: K, value: V) {
        self.map.entry(key).or_default().insert(value);
    }

    fn remove(&amp;mut self, key: &amp;K, value: &amp;V) {
        if let Some(values) = self.map.get_mut(key) {
            values.remove(value);
            if values.is_empty() {
                self.map.remove(key);
            }
        }
    }

    fn get(&amp;self, key: &amp;K) -&gt; impl Iterator&lt;Item=V&gt; + '_ {
        self.map
            .get(key)
            .into_iter()
            .flat_map(|values| values.iter().copied())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-with-mutation-handling"><a class="header" href="#integration-with-mutation-handling">Integration with Mutation Handling</a></h3>
<p>When a vertex or edge property changes, you need to update the hash indexes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyMutationListener&lt;'reference, Element&gt; {
    indexes: &amp;'reference mut IndexCollection,
    id: VertexInternalId,
}

impl&lt;'reference, Element&gt; MutationListener&lt;'reference, Element&gt;
for MyMutationListener&lt;'reference, Element&gt;
where
    Element: Element,
{
    fn update(&amp;mut self, index: &lt;Element::Label as Label&gt;::Index, before: Value, after: Value) {
        // Remove the old value from the index
        self.indexes[index.ordinal()].remove(&amp;before, self.id);

        // Add the new value to the index
        self.indexes[index.ordinal()].insert(after, self.id);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-range-indexes"><a class="header" href="#implementing-range-indexes">Implementing Range Indexes</a></h2>
<p>Range indexes allow for finding elements with property values in a specific range.</p>
<h3 id="data-structure-2"><a class="header" href="#data-structure-2">Data Structure</a></h3>
<p>A range index typically uses an ordered map like <code>BTreeMap</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RangeIndex&lt;K, V&gt; {
    map: BTreeMap&lt;K, HashSet&lt;V&gt;&gt;,
}

impl&lt;K: Ord, V: Copy + Eq + Hash&gt; RangeIndex&lt;K, V&gt; {
    fn new() -&gt; Self {
        Self {
            map: BTreeMap::new(),
        }
    }

    fn insert(&amp;mut self, key: K, value: V) {
        self.map.entry(key).or_default().insert(value);
    }

    fn remove(&amp;mut self, key: &amp;K, value: &amp;V) {
        if let Some(values) = self.map.get_mut(key) {
            values.remove(value);
            if values.is_empty() {
                self.map.remove(key);
            }
        }
    }

    fn get(&amp;self, key: &amp;K) -&gt; impl Iterator&lt;Item=V&gt; + '_ {
        self.map
            .get(key)
            .into_iter()
            .flat_map(|values| values.iter().copied())
    }

    fn range&lt;'a, R&gt;(&amp;'a self, range: R) -&gt; impl Iterator&lt;Item=V&gt; + 'a
    where
        R: RangeBounds&lt;K&gt; + 'a,
        K: 'a,
    {
        self.map
            .range(range)
            .flat_map(|(_, values)| values.iter().copied())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handling-range-queries"><a class="header" href="#handling-range-queries">Handling Range Queries</a></h3>
<p>Implement range query support in your vertex and edge iterators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn vertices&lt;'search&gt;(
    &amp;self,
    search: &amp;VertexSearch&lt;'search, Self&gt;,
) -&gt; Self::VertexIter&lt;'search, '_&gt; {
    // ...other search handling

    if let VertexSearch::Range { index, range, .. } = search {
        let index_storage = &amp;self.indexes[index.ordinal()];
        return VertexIter {
            iter: index_storage.range(range.clone(), index),
            // ...other fields
        };
    }

    // ...default handling
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-full-text-indexes"><a class="header" href="#implementing-full-text-indexes">Implementing Full-Text Indexes</a></h2>
<p>Full-text indexes enable searching through text properties with capabilities like prefix matching, fuzzy matching, or
tokenized searches.</p>
<h3 id="data-structure-3"><a class="header" href="#data-structure-3">Data Structure</a></h3>
<p>A simple full-text index implementation might use an inverted index:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FullTextIndex&lt;V&gt; {
    // Maps tokens to element IDs
    tokens: HashMap&lt;String, HashSet&lt;V&gt;&gt;,
    // Maps element IDs to their full text
    contents: HashMap&lt;V, String&gt;,
}

impl&lt;V: Copy + Eq + Hash&gt; FullTextIndex&lt;V&gt; {
    fn new() -&gt; Self {
        Self {
            tokens: HashMap::new(),
            contents: HashMap::new(),
        }
    }

    fn insert(&amp;mut self, id: V, text: &amp;str) {
        // Remove old content if it exists
        self.remove(&amp;id);

        // Store the full text
        self.contents.insert(id, text.to_string());

        // Tokenize the text and add to inverted index
        for token in tokenize(text) {
            self.tokens.entry(token).or_default().insert(id);
        }
    }

    fn remove(&amp;mut self, id: &amp;V) {
        if let Some(text) = self.contents.remove(id) {
            // Remove from token index
            for token in tokenize(&amp;text) {
                if let Some(ids) = self.tokens.get_mut(&amp;token) {
                    ids.remove(id);
                    if ids.is_empty() {
                        self.tokens.remove(&amp;token);
                    }
                }
            }
        }
    }

    fn search(&amp;self, query: &amp;str) -&gt; impl Iterator&lt;Item=V&gt; + '_ {
        // Tokenize the query
        let query_tokens: Vec&lt;_&gt; = tokenize(query).collect();

        // Find matches
        query_tokens
            .into_iter()
            .filter_map(move |token| self.tokens.get(&amp;token))
            .flatten()
            .copied()
            .collect::&lt;HashSet&lt;_&gt;&gt;() // Deduplicate
            .into_iter()
    }
}

// Helper function to tokenize text
fn tokenize(text: &amp;str) -&gt; impl Iterator&lt;Item=String&gt; + '_ {
    text.to_lowercase()
        .split_whitespace()
        .map(|s| s.to_string())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-full-text-features"><a class="header" href="#advanced-full-text-features">Advanced Full-Text Features</a></h3>
<p>For more advanced full-text search capabilities, consider:</p>
<ol>
<li><strong>Stemming</strong>: Reducing words to their root form (e.g., "running" â†’ "run")</li>
<li><strong>N-grams</strong>: Creating token sequences for partial matching</li>
<li><strong>Fuzzy Matching</strong>: Supporting approximate matching with edit distance</li>
<li><strong>Relevance Scoring</strong>: Ranking results by relevance to the query</li>
</ol>
<h2 id="efficient-index-updates"><a class="header" href="#efficient-index-updates">Efficient Index Updates</a></h2>
<p>For efficient index updates, consider these strategies:</p>
<h3 id="lazy-updates"><a class="header" href="#lazy-updates">Lazy Updates</a></h3>
<p>Only update indexes when needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_vertex(&amp;mut self, id: Self::VertexId) -&gt; Option&lt;Self::Vertex&gt; {
    // Fetch the vertex
    let vertex = self.vertices.get(id.index())?;

    // Only update indexes if the vertex exists
    for index in vertex.label().indexes() {
        self.indexes[index.ordinal()].remove(&amp;self.get_value(vertex, index), id.index());
    }

    // Remove the vertex
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batched-updates"><a class="header" href="#batched-updates">Batched Updates</a></h3>
<p>For bulk operations, batch index updates:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_vertices_batch(&amp;mut self, vertices: Vec&lt;Self::Vertex&gt;) -&gt; Vec&lt;Self::VertexId&gt; {
    let mut ids = Vec::with_capacity(vertices.len());
    let mut index_updates = Vec::new();

    // First pass: add vertices and collect index updates
    for vertex in vertices {
        let id = self.add_vertex_no_index(vertex);
        ids.push(id);

        // Collect index updates
        for index in vertex.label().indexes() {
            index_updates.push((index, self.get_value(&amp;vertex, index), id));
        }
    }

    // Second pass: apply all index updates
    for (index, value, id) in index_updates {
        self.indexes[index.ordinal()].insert(value, id);
    }

    ids
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<p>When implementing indexes, watch out for these common issues:</p>
<ol>
<li><strong>Index Inconsistency</strong>: Ensure indexes are always updated when elements change</li>
<li><strong>Memory Overhead</strong>: Indexes increase memory usage; consider selective indexing</li>
<li><strong>Type Safety</strong>: Ensure index type safety, especially with range and full-text indexes</li>
<li><strong>Empty Sets</strong>: Handle empty index entries to avoid wasted memory</li>
<li><strong>Concurrency</strong>: If supporting concurrent access, protect indexes with appropriate synchronization</li>
</ol>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>For optimal index performance:</p>
<ol>
<li><strong>Index Selection</strong>: Only index properties that will be frequently queried</li>
<li><strong>Data Structure Choice</strong>: Choose appropriate data structures based on workload</li>
<li><strong>Memory vs. Speed</strong>: Balance memory usage with lookup speed</li>
<li><strong>Measure</strong>: Benchmark index operations to identify bottlenecks</li>
</ol>
<h2 id="testing-indexes"><a class="header" href="#testing-indexes">Testing Indexes</a></h2>
<p>Test your index implementation thoroughly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_hash_index() {
    let mut graph = MyGraph::new();

    // Add vertices with indexed properties
    let v1 = graph.add_vertex(Vertex::Person {
        name: "Alice".to_string(),
        age: 30,
        // ...other fields
    });

    let v2 = graph.add_vertex(Vertex::Person {
        name: "Bob".to_string(),
        age: 25,
        // ...other fields
    });

    // Test index lookup
    let results = graph.walk()
        .vertices(Vertex::person_by_name("Alice"))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    assert_eq!(results.len(), 1);
    assert_eq!(results[0].id(), v1);

    // Test index update after mutation
    graph.vertex_mut(v1).unwrap()
        .project_mut::&lt;PersonMut&lt;_&gt;&gt;().unwrap()
        .set_name("Alicia");

    let results = graph.walk()
        .vertices(Vertex::person_by_name("Alicia"))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    assert_eq!(results.len(), 1);
    assert_eq!(results[0].id(), v1);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>Implementing efficient indexes is key to building a high-performance graph backend. By carefully designing index
structures and ensuring proper updates during mutations, you can provide fast lookup capabilities while maintaining
reasonable memory usage. Remember that different use cases may require different indexing strategies, so consider the
expected query patterns when deciding which indexes to implement and how to optimize them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h1>
<p>Benchmarking is essential for measuring and comparing the performance of your graph implementation. This chapter covers
how to set up and run benchmarks, interpret results, and use benchmarking to guide optimization.</p>
<h2 id="setting-up-benchmarks"><a class="header" href="#setting-up-benchmarks">Setting Up Benchmarks</a></h2>
<p>The Graph API provides built-in benchmarking tools to help you evaluate your implementation's performance.</p>
<h3 id="adding-benchmarking-dependencies"><a class="header" href="#adding-benchmarking-dependencies">Adding Benchmarking Dependencies</a></h3>
<p>First, add the necessary dependencies to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = "0.5"
graph-api-benches = { version = "0.1.5", features = ["vertex-hash-index", "vertex-label-index", "vertex-full-text-index", "vertex-range-index", "edge-label-index"] }

[[bench]]
name = "my_graph_benchmarks"
harness = false
</code></pre>
<h3 id="creating-a-basic-benchmark-suite"><a class="header" href="#creating-a-basic-benchmark-suite">Creating a Basic Benchmark Suite</a></h3>
<p>Create a benchmark file in your project's <code>benches</code> directory:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// benches/my_graph_benchmarks.rs
use criterion::{criterion_group, criterion_main, Criterion};
use graph_api_benches::bench_suite;
use my_graph::MyGraph;

fn criterion_benchmark(c: &amp;mut Criterion) {
    bench_suite!(c, || MyGraph::new());
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<p>The <code>bench_suite!</code> macro runs a standardized set of benchmarks against your graph implementation.</p>
<h2 id="standard-benchmark-suite"><a class="header" href="#standard-benchmark-suite">Standard Benchmark Suite</a></h2>
<p>The standard benchmark suite in <code>graph-api-benches</code> tests several aspects of graph performance:</p>
<h3 id="1-construction-benchmarks"><a class="header" href="#1-construction-benchmarks">1. Construction Benchmarks</a></h3>
<p>Measures the performance of creating graph elements:</p>
<ul>
<li>Creating vertices</li>
<li>Creating edges</li>
<li>Creating graphs of different sizes</li>
</ul>
<h3 id="2-query-benchmarks"><a class="header" href="#2-query-benchmarks">2. Query Benchmarks</a></h3>
<p>Evaluates lookup and traversal performance:</p>
<ul>
<li>Vertex retrieval by ID</li>
<li>Vertex retrieval by index</li>
<li>Edge traversal</li>
<li>Path finding</li>
</ul>
<h3 id="3-mutation-benchmarks"><a class="header" href="#3-mutation-benchmarks">3. Mutation Benchmarks</a></h3>
<p>Tests the efficiency of modifying the graph:</p>
<ul>
<li>Adding vertices and edges</li>
<li>Removing vertices and edges</li>
<li>Modifying vertex and edge properties</li>
</ul>
<h3 id="4-traversal-benchmarks"><a class="header" href="#4-traversal-benchmarks">4. Traversal Benchmarks</a></h3>
<p>Measures the performance of walking the graph:</p>
<ul>
<li>Simple steps (vertices, edges)</li>
<li>Filter operations</li>
<li>Map operations</li>
<li>Complex traversals</li>
</ul>
<h3 id="5-scale-benchmarks"><a class="header" href="#5-scale-benchmarks">5. Scale Benchmarks</a></h3>
<p>Assesses how performance scales with graph size:</p>
<ul>
<li>Small graphs (10s of vertices)</li>
<li>Medium graphs (100s of vertices)</li>
<li>Large graphs (1000s of vertices)</li>
<li>Huge graphs (10,000s of vertices)</li>
</ul>
<h2 id="running-benchmarks"><a class="header" href="#running-benchmarks">Running Benchmarks</a></h2>
<p>To run the benchmarks:</p>
<pre><code class="language-bash"># Run all benchmarks
cargo bench

# Run a specific benchmark
cargo bench -- vertex_insertion
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>Check out the <a href="https://docs.rs/graph-api-lib/0.1.4/graph_api_lib/">docs on docs.rs</a>,</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="support-traits"><a class="header" href="#support-traits">Support Traits</a></h1>
<p>The Graph API uses a trait-based approach to indicate which optional features a graph implementation supports. This
allows for a more flexible and extensible API, where new capabilities can be added over time without breaking existing
implementations.</p>
<h2 id="core-trait"><a class="header" href="#core-trait">Core Trait</a></h2>
<p>The core <code>Graph</code> trait provides the essential functionality that all graph implementations must provide:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Graph: Sized + Debug {
    type Vertex: Debug + Element;
    type Edge: Debug + Element;
    type VertexId: Debug + Eq + PartialEq + Copy + Clone + Hash + Into&lt;ElementId&lt;Self&gt;&gt; + 'static;
    type EdgeId: Debug + Eq + PartialEq + Copy + Clone + Hash + Into&lt;ElementId&lt;Self&gt;&gt; + 'static;
    
    // Reference types
    type VertexReference&lt;'graph&gt;: VertexReference&lt;'graph, Self&gt; where Self: 'graph;
    type VertexReferenceMut&lt;'graph&gt;: VertexReferenceMut&lt;'graph, Self&gt; where Self: 'graph;
    type EdgeReference&lt;'graph&gt;: EdgeReference&lt;'graph, Self&gt; where Self: 'graph;
    type EdgeReferenceMut&lt;'graph&gt;: EdgeReferenceMut&lt;'graph, Self&gt; where Self: 'graph;
    
    // Iterator types
    type EdgeIter&lt;'search, 'graph&gt;: Iterator&lt;Item = Self::EdgeReference&lt;'graph&gt;&gt; where Self: 'graph;
    type VertexIter&lt;'search, 'graph&gt;: Iterator&lt;Item = Self::VertexReference&lt;'graph&gt;&gt; where Self: 'graph;
    
    // Core methods
    fn add_vertex(&amp;mut self, vertex: Self::Vertex) -&gt; Self::VertexId;
    fn add_edge(&amp;mut self, from: Self::VertexId, to: Self::VertexId, edge: Self::Edge) -&gt; Self::EdgeId;
    fn remove_vertex(&amp;mut self, id: Self::VertexId) -&gt; Option&lt;Self::Vertex&gt;;
    fn remove_edge(&amp;mut self, id: Self::EdgeId) -&gt; Option&lt;Self::Edge&gt;;
    fn vertex(&amp;self, id: Self::VertexId) -&gt; Option&lt;Self::VertexReference&lt;'_&gt;&gt;;
    fn vertex_mut(&amp;mut self, id: Self::VertexId) -&gt; Option&lt;Self::VertexReferenceMut&lt;'_&gt;&gt;;
    fn vertices&lt;'search&gt;(&amp;self, vertex_search: &amp;VertexSearch&lt;'search, Self&gt;) -&gt; Self::VertexIter&lt;'search, '_&gt;;
    fn edge(&amp;self, id: Self::EdgeId) -&gt; Option&lt;Self::EdgeReference&lt;'_&gt;&gt;;
    fn edge_mut(&amp;mut self, id: Self::EdgeId) -&gt; Option&lt;Self::EdgeReferenceMut&lt;'_&gt;&gt;;
    fn edges&lt;'search&gt;(&amp;self, id: Self::VertexId, search: &amp;EdgeSearch&lt;'search, Self&gt;) -&gt; Self::EdgeIter&lt;'search, '_&gt;;
    
    // Default implementations
    fn dbg&lt;T: Into&lt;ElementId&lt;Self&gt;&gt;&gt;(&amp;self, id: T) -&gt; String { ... }
    fn walk(&amp;self) -&gt; StartWalkerBuilder&lt;ImmutableMarker, Self&gt; { ... }
    fn walk_mut(&amp;mut self) -&gt; StartWalkerBuilder&lt;MutableMarker, Self&gt; { ... }
    
    // Default implementation that panics if SupportsClear is not implemented
    fn clear(&amp;mut self) {
        panic!("This graph implementation does not support clearing. Implement the SupportsClear trait for this graph type to add clearing support.")
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="support-traits-1"><a class="header" href="#support-traits-1">Support Traits</a></h2>
<p>These traits enable optional features for graph implementations. Each support trait extends the <code>Graph</code> trait, so
implementations must first implement <code>Graph</code> before they can implement any support traits.</p>
<h3 id="vertex-index-support"><a class="header" href="#vertex-index-support">Vertex Index Support</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Supports indexing of vertices by label
pub trait SupportsVertexLabelIndex: Graph {}

/// Supports indexing of vertices by field using a hash index
pub trait SupportsVertexHashIndex: Graph {}

/// Supports indexing of vertices by field with range queries
pub trait SupportsVertexRangeIndex: Graph {}

/// Supports indexing of vertices by field using a full text index
pub trait SupportsVertexFullTextIndex: Graph {}
<span class="boring">}</span></code></pre></pre>
<h3 id="edge-index-support"><a class="header" href="#edge-index-support">Edge Index Support</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Supports indexing of edges by label
pub trait SupportsEdgeLabelIndex: Graph {}

/// Supports indexing of edges by field using a hash index
pub trait SupportsEdgeHashIndex: Graph {}

/// Supports indexing of edges by field with range queries
pub trait SupportsEdgeRangeIndex: Graph {}

/// Supports indexing of edges by adjacent vertex label
pub trait SupportsEdgeAdjacentLabelIndex: Graph {}
<span class="boring">}</span></code></pre></pre>
<h3 id="other-support"><a class="header" href="#other-support">Other Support</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Supports clearing all vertices and edges
pub trait SupportsClear: Graph {
    /// Clears the graph, removing all vertices and edges
    fn clear(&amp;mut self);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-support-traits"><a class="header" href="#using-support-traits">Using Support Traits</a></h2>
<p>When you implement a graph, first implement the core <code>Graph</code> trait, and then implement any support traits for the
features you want to provide:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Core implementation
impl&lt;V, E&gt; Graph for MyGraph&lt;V, E&gt;
where
    V: Element,
    E: Element,
{
    // Implement required methods and types...
}

// Add support for vertex label indexing
impl&lt;V, E&gt; SupportsVertexLabelIndex for MyGraph&lt;V, E&gt;
where
    V: Element,
    E: Element,
{
    // No additional methods required
}

// Add support for clearing
impl&lt;V, E&gt; SupportsClear for MyGraph&lt;V, E&gt;
where
    V: Element,
    E: Element,
{
    fn clear(&amp;mut self) {
        // Implementation to clear all vertices and edges
        self.vertices.clear();
        self.edges.clear();
        // Clear any indexes...
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-supported-features"><a class="header" href="#using-supported-features">Using Supported Features</a></h2>
<p>When writing code that uses supported features, use trait bounds to ensure the graph implementation supports the
required features:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Function that uses vertex label indexing
fn get_people&lt;G&gt;(graph: &amp;G) -&gt; Vec&lt;G::VertexId&gt;
where
    G: Graph + SupportsVertexLabelIndex,
{
    // Can safely use label indexing here
    graph.walk()
        .vertices(Vertex::person())
        .map(|v| v.id())
        .collect()
}

// Function that uses range indexing
fn get_adults&lt;G&gt;(graph: &amp;G) -&gt; Vec&lt;G::VertexId&gt;
where
    G: Graph + SupportsVertexRangeIndex,
{
    // Can safely use range indexing here
    graph.walk()
        .vertices(Vertex::person_by_age_range(18..))
        .map(|v| v.id())
        .collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="adding-new-support-traits"><a class="header" href="#adding-new-support-traits">Adding New Support Traits</a></h2>
<p>The trait-based approach allows for adding new support traits over time without breaking existing code. To add a new
support trait:</p>
<ol>
<li>Define the new trait extending the <code>Graph</code> trait</li>
<li>Add any required methods</li>
<li>Implement the trait for graph implementations that support the feature</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Adding support for spatial indexing
pub trait SupportsSpatialIndex: Graph {
    // Optional specialized methods for spatial indexing
    fn nearest_neighbors(&amp;self, point: Point, k: usize) -&gt; Vec&lt;Self::VertexId&gt;;
}

// Implement for a graph that supports spatial indexing
impl&lt;V, E&gt; SupportsSpatialIndex for SpatialGraph&lt;V, E&gt;
where
    V: Element,
    E: Element,
{
    fn nearest_neighbors(&amp;self, point: Point, k: usize) -&gt; Vec&lt;Self::VertexId&gt; {
        // Implementation...
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-macros-1"><a class="header" href="#derive-macros-1">Derive Macros</a></h1>
<p>The Graph API provides derive macros to make working with your graph model types straightforward and type-safe. These
macros generate code that integrates your custom types with the Graph API framework.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>There are two primary derive macros:</p>
<ol>
<li><code>VertexExt</code> - For vertex enum types</li>
<li><code>EdgeExt</code> - For edge enum types</li>
</ol>
<p>These macros generate:</p>
<ul>
<li>Label enums for type-safe queries</li>
<li>Index enums for efficient property lookups</li>
<li>Helper methods for traversing and querying the graph</li>
<li>Projection types for type-safe access to variant fields</li>
<li>Walker builder filter extensions for type-safe filtering</li>
</ul>
<h2 id="vertexext-derive-macro"><a class="header" href="#vertexext-derive-macro">VertexExt Derive Macro</a></h2>
<h3 id="generated-types"><a class="header" href="#generated-types">Generated Types</a></h3>
<p>When you apply <code>#[derive(VertexExt)]</code> to an enum, the following types are generated:</p>
<ol>
<li><strong>VertexLabel</strong> enum - Contains variants matching your enum's variants</li>
<li><strong>VertexIndex</strong> enum - Contains variants for each indexed field</li>
<li><strong>Projection</strong> structs - For accessing fields in a type-safe way</li>
</ol>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-rust noplayground">use graph_api_derive::VertexExt;
use uuid::Uuid;

#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    Person {
        #[index]
        name: String,

        #[index(range)]
        age: u64,

        #[index(full_text)]
        biography: String,

        unique_id: Uuid, // Not indexed
    },
    Project {
        name: String,
    },
    Tag, // Unit variant
}</code></pre>
<p>This generates:</p>
<pre><code class="language-rust noplayground">// Label enum
pub enum VertexLabel {
    Person,
    Project,
    Tag,
}

// Index enum with methods
pub enum VertexIndex {
    PersonName,
    PersonAge,
    PersonBiography,
}

// Projection structs (simplified)
pub struct Person&lt;'a, V&gt; {
    name: &amp;'a String,
    age: &amp;'a u64,
    biography: &amp;'a String,
    unique_id: &amp;'a Uuid,
}

pub struct PersonMut&lt;'a, V, L&gt; {
    name: &amp;'a mut String,
    age: &amp;'a mut u64,
    biography: &amp;'a mut String,
    unique_id: &amp;'a mut Uuid,
}</code></pre>
<h3 id="generated-methods"><a class="header" href="#generated-methods">Generated Methods</a></h3>
<p>The derive macro generates several methods on the <code>VertexIndex</code> enum:</p>
<h4 id="label-based-querying"><a class="header" href="#label-based-querying">Label-based Querying</a></h4>
<p>For each enum variant, a method is generated to query by label:</p>
<pre><code class="language-rust noplayground">// Query for all Person vertices
Vertex::person() -&gt; VertexSearch&lt;'_, Graph&gt;</code></pre>
<h4 id="property-based-querying"><a class="header" href="#property-based-querying">Property-based Querying</a></h4>
<p>For each indexed field, methods are generated for exact matching:</p>
<pre><code class="language-rust noplayground">// Query for Person vertices with a specific name
Vertex::person_by_name(value: &amp; str) -&gt; VertexSearch&lt;'_, Graph&gt;

// Query for Person vertices with a specific age
Vertex::person_by_age(value: u64) -&gt; VertexSearch&lt;'_, Graph&gt;</code></pre>
<h4 id="range-based-querying"><a class="header" href="#range-based-querying">Range-based Querying</a></h4>
<p>For fields with the <code>#[index(range)]</code> attribute:</p>
<pre><code class="language-rust noplayground">// Query for Person vertices with age in a range
Vertex::person_by_age_range(range: Range&lt;u64&gt;) -&gt; VertexSearch&lt;'_, Graph&gt;</code></pre>
<h4 id="full-text-querying"><a class="header" href="#full-text-querying">Full-text Querying</a></h4>
<p>For fields with the <code>#[index(full_text)]</code> attribute:</p>
<pre><code class="language-rust noplayground">// Query for Person vertices with matching text in biography
Vertex::person_by_biography(search: &amp; str) -&gt; VertexSearch&lt;'_, Graph&gt;</code></pre>
<h2 id="edgeext-derive-macro"><a class="header" href="#edgeext-derive-macro">EdgeExt Derive Macro</a></h2>
<h3 id="generated-types-1"><a class="header" href="#generated-types-1">Generated Types</a></h3>
<p>When you apply <code>#[derive(EdgeExt)]</code> to an enum, similar types are generated:</p>
<ol>
<li><strong>EdgeLabel</strong> enum - Contains variants matching your enum's variants</li>
<li><strong>EdgeIndex</strong> enum - Contains variants for each indexed field</li>
<li>Projection structs - For accessing fields in a type-safe way</li>
</ol>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-rust noplayground">use graph_api_derive::EdgeExt;

#[derive(Debug, Clone, EdgeExt)]
pub enum Edge {
    Knows {
        since: u32,
    },
    Created,
    Rated(Rating),
}</code></pre>
<p>This generates:</p>
<pre><code class="language-rust noplayground">// Label enum
pub enum EdgeLabel {
    Knows,
    Created,
    Rated,
}

// Index enum with methods
pub enum EdgeIndex {
    // EdgeIndex variants (if indexed fields exist)
}</code></pre>
<h3 id="generated-methods-1"><a class="header" href="#generated-methods-1">Generated Methods</a></h3>
<p>The EdgeIndex enum offers methods for edge traversal:</p>
<pre><code class="language-rust noplayground">// Query for all Knows edges
EdgeIndex::knows() -&gt; EdgeSearch&lt;'_, Graph&gt;

// Specify outgoing direction
EdgeIndex::knows().outgoing()

// Specify incoming direction
EdgeIndex::knows().incoming()

// Limit result count
EdgeIndex::knows().limit(n)</code></pre>
<h2 id="walker-builder-filter-extensions"><a class="header" href="#walker-builder-filter-extensions">Walker Builder Filter Extensions</a></h2>
<p>The derive macros also generate filter extension methods on the walker builders to simplify filtering based on
vertex/edge types.</p>
<h3 id="for-unit-variants"><a class="header" href="#for-unit-variants">For Unit Variants</a></h3>
<p>For unit variants (without fields), a single filter method is generated:</p>
<pre><code class="language-rust noplayground">// Filter for all instances of the unit variant
fn filter_tag(self) -&gt; /* walker builder */</code></pre>
<p>Usage example:</p>
<pre><code class="language-rust noplayground">// Get all Tag vertices
let tags = graph
.walk()
.vertices(VertexSearch::scan())
.filter_tag()
.collect::&lt;Vec&lt;_ &gt; &gt; ();</code></pre>
<h3 id="for-named-fields-variants"><a class="header" href="#for-named-fields-variants">For Named Fields Variants</a></h3>
<p>For variants with named fields, two filter methods are generated:</p>
<pre><code class="language-rust noplayground">// 1. Filter for all instances of this variant
fn filter_person(self) -&gt; /* walker builder */

// 2. Filter with custom logic using the projected fields
fn filter_by_person&lt;F&gt;(self, filter: F) -&gt; /* walker builder */
where
    F: Fn(Person&lt;Graph::Vertex&gt;, &amp;Context) -&gt; bool</code></pre>
<p>Usage example:</p>
<pre><code class="language-rust noplayground">// Get all Person vertices
let all_persons = graph
.walk()
.vertices(VertexSearch::scan())
.filter_person()
.collect::&lt;Vec&lt;_ &gt; &gt; ();

// Get Person vertices with specific criteria
let adults = graph
.walk()
.vertices(VertexSearch::scan())
.filter_by_person( | person, _ | person.age() &gt; = 18)
.collect::&lt;Vec&lt;_ &gt; &gt; ();</code></pre>
<h3 id="for-tuple-variants"><a class="header" href="#for-tuple-variants">For Tuple Variants</a></h3>
<p>For tuple variants, similar filter methods are generated:</p>
<pre><code class="language-rust noplayground">// 1. Filter for all instances of this variant
fn filter_rated(self) -&gt; /* walker builder */

// 2. Filter with custom logic using the tuple fields
fn filter_by_rated&lt;F&gt;(self, filter: F) -&gt; /* walker builder */
where
    F: Fn(&amp;Rating, &amp;Context) -&gt; bool</code></pre>
<p>Usage example:</p>
<pre><code class="language-rust noplayground">// Get edges with high ratings
let high_ratings = graph
.walk()
.vertices_by_id([person_id])
.edges(EdgeSearch::scan())
.filter_by_rated( | rating, _ | rating.stars &gt; = 4)
.collect::&lt;Vec&lt;_ &gt; &gt; ();</code></pre>
<h3 id="benefits-of-filter-extensions"><a class="header" href="#benefits-of-filter-extensions">Benefits of Filter Extensions</a></h3>
<p>These filter extensions provide several advantages:</p>
<ol>
<li><strong>Type Safety</strong> - The closures receive strongly typed projections</li>
<li><strong>Code Clarity</strong> - Filters are expressive and self-documenting</li>
<li><strong>IDE Support</strong> - Better autocompletion for variant fields</li>
<li><strong>Context Access</strong> - Access to the walker's context object</li>
<li><strong>Pattern Matching</strong> - No need for manual pattern matching</li>
</ol>
<h2 id="using-generated-types"><a class="header" href="#using-generated-types">Using Generated Types</a></h2>
<h3 id="in-graph-queries"><a class="header" href="#in-graph-queries">In Graph Queries</a></h3>
<p>The generated types integrate with the Graph walker pattern:</p>
<pre><code class="language-rust noplayground">// Find all person vertices
let people = graph
.walk()
.vertices(Vertex::person())
.collect::&lt;Vec&lt;_ &gt; &gt; ();

// Find people with a specific name
let named_people = graph
.walk()
.vertices(Vertex::person_by_name("Bryn"))
.collect::&lt;Vec&lt;_ &gt; &gt; ();

// Find people in an age range
let adults = graph
.walk()
.vertices(Vertex::person_by_age_range(18..65))
.collect::&lt;Vec&lt;_ &gt; &gt; ();

// Find outgoing 'knows' edges from a vertex
let friends = graph
.walk()
.vertices_by_id([person_id])
.edges(EdgeIndex::knows().outgoing())
.collect::&lt;Vec&lt;_ &gt; &gt; ();</code></pre>
<h3 id="combined-with-filter-extensions"><a class="header" href="#combined-with-filter-extensions">Combined with Filter Extensions</a></h3>
<p>Filter extensions can be combined with other walker steps:</p>
<pre><code class="language-rust noplayground">// Find adults named "Bryn" with a complex filter
let result = graph
.walk()
.vertices(Vertex::person())
.filter_by_person( | person, _ | {
person.age() &gt; = 18 &amp; &amp; person.name().contains("Bryn")
})
.collect::&lt;Vec&lt;_ &gt; &gt; ();

// Find friendship edges created before 2000
let old_friendships = graph
.walk()
.vertices_by_id([person_id])
.edges(EdgeIndex::knows().outgoing())
.filter_by_knows( | knows, _ | knows.since() &lt; 2000)
.collect::&lt;Vec&lt;_ &gt; &gt; ();</code></pre>
<h3 id="type-constraints"><a class="header" href="#type-constraints">Type Constraints</a></h3>
<p>When using these types, your Graph type needs to implement appropriate support:</p>
<pre><code class="language-rust noplayground">fn example&lt;G&gt;(graph: &amp;G)
where
    G: Graph&lt;Vertex=Vertex, Edge=Edge&gt;,
    G::SupportsVertexLabelIndex: Supported,
{
    // Now you can use label-based indexes
    graph.walk().vertices(Vertex::person())...
}</code></pre>
<h2 id="index-attributes-1"><a class="header" href="#index-attributes-1">Index Attributes</a></h2>
<p>You can use these attributes on struct fields:</p>
<ul>
<li><code>#[index]</code> - Basic indexing for efficient lookups</li>
<li><code>#[index(range)]</code> - Enables range queries</li>
<li><code>#[index(full_text)]</code> - Enables text search (String fields only)</li>
</ul>
<h2 id="best-practices-27"><a class="header" href="#best-practices-27">Best Practices</a></h2>
<ol>
<li>
<p>Use the appropriate index type for your query pattern:</p>
<ul>
<li>Use label index for type filtering</li>
<li>Use property index for exact matches</li>
<li>Use range index for numeric ranges</li>
<li>Use full-text for searching text content</li>
</ul>
</li>
<li>
<p>Apply indexes sparingly:</p>
<ul>
<li>Each index adds memory overhead</li>
<li>Only index fields you'll query frequently, it's OK to filter once you are on the graph.</li>
</ul>
</li>
<li>
<p>Consider the query planner:</p>
<ul>
<li>Using an index in a vertices() step is typically more efficient than filtering the entire graph</li>
<li>Combining indices with other walker steps can create efficient traversal patterns</li>
</ul>
</li>
<li>
<p>Use filter extensions for type-safety:</p>
<ul>
<li>Prefer <code>filter_by_person()</code> over <code>filter()</code> with manual pattern matching</li>
<li>Leverage the projection types for field access</li>
<li>Use specific filter methods for clearer, more maintainable code</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="existing-implementations"><a class="header" href="#existing-implementations">Existing Implementations</a></h1>
<p>The Graph API ecosystem includes two ready-to-use graph implementations that cater to different use cases and
performance requirements. This section provides an overview of the existing implementations, their features, and
suitability for different applications.</p>
<h2 id="core-implementations"><a class="header" href="#core-implementations">Core Implementations</a></h2>
<p>The Graph API project provides two main graph implementations:</p>
<ol>
<li>
<p><strong><a href="reference/./implementations/simple_graph.html">SimpleGraph</a></strong>: A reference implementation built specifically for the Graph
API. It fully supports all Graph API features, including most index types, making it ideal for testing Graph API
functionality and serving as a blueprint for new implementations.</p>
</li>
<li>
<p><strong><a href="reference/./implementations/petgraph.html">PetGraph</a></strong>: An adapter for the excellent and widely-used
<a href="https://crates.io/crates/petgraph">petgraph</a> crate. This demonstrates Graph API compatibility with established
Rust graph libraries and is a great choice for performance-sensitive applications or projects already using
petgraph.</p>
</li>
</ol>
<h2 id="choosing-an-implementation"><a class="header" href="#choosing-an-implementation">Choosing an Implementation</a></h2>
<p>When deciding which graph implementation to use, consider the following factors:</p>
<h3 id="feature-support"><a class="header" href="#feature-support">Feature Support</a></h3>
<p>Different implementations support different features:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>SimpleGraph</th><th>PetGraph</th></tr></thead><tbody>
<tr><td>Vertex label indexes</td><td>âœ…</td><td>âŒ</td></tr>
<tr><td>Edge label indexes</td><td>âœ…</td><td>âŒ</td></tr>
<tr><td>Vertex hash indexes</td><td>âœ…</td><td>âŒ</td></tr>
<tr><td>Edge hash indexes</td><td>âŒ</td><td>âŒ</td></tr>
<tr><td>Vertex range indexes</td><td>âœ…</td><td>âŒ</td></tr>
<tr><td>Edge range indexes</td><td>âŒ</td><td>âŒ</td></tr>
<tr><td>Vertex full-text indexes</td><td>âœ…</td><td>âŒ</td></tr>
<tr><td>Edge adjacent label indexes*</td><td>âœ…</td><td>âŒ</td></tr>
<tr><td>Graph clearing</td><td>âœ…</td><td>âœ…</td></tr>
</tbody></table>
</div>
<p>* Edge adjacent indexes are not fully supported in graph-api yet.</p>
<h3 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h3>
<p>Performance varies between implementations:</p>
<ul>
<li><strong>SimpleGraph</strong>: Primarily designed for feature completeness and testing; not optimized for high performance.</li>
<li><strong>PetGraph</strong>: A mature, well-optimized, and widely-used graph library suitable for production use.</li>
</ul>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<ul>
<li><strong>SimpleGraph</strong>: Memory usage is straightforward but not heavily optimized.</li>
<li><strong>PetGraph</strong>: Leverages petgraph's memory model, which is generally efficient.</li>
</ul>
<h3 id="integration"><a class="header" href="#integration">Integration</a></h3>
<ul>
<li><strong>SimpleGraph</strong>: Best for demonstrating and testing Graph API features or as a starting point for custom
implementations.</li>
<li><strong>PetGraph</strong>: Ideal for integrating Graph API capabilities into projects already using petgraph or when requiring
petgraph's performance characteristics.</li>
</ul>
<h2 id="creating-your-own-implementation"><a class="header" href="#creating-your-own-implementation">Creating Your Own Implementation</a></h2>
<p>If the existing implementations don't meet your needs, you can create your own by implementing the <code>Graph</code> trait. See
the <a href="reference/../implementation/guide.html">Implementation Guide</a> for detailed instructions on creating a custom graph
implementation.</p>
<h2 id="future-implementations"><a class="header" href="#future-implementations">Future Implementations</a></h2>
<p>The Graph API is designed to support a variety of graph implementations.</p>
<p>Community contributions of new graph implementations are welcomed and encouraged!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simplegraph"><a class="header" href="#simplegraph">SimpleGraph</a></h1>
<p><code>SimpleGraph</code> is the reference implementation for the Graph API, designed primarily to showcase and test the full
capabilities of the API, including comprehensive indexing support for property graphs. While functional, it's not
optimized for high performance.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Add SimpleGraph to your project dependencies:</p>
<pre><code class="language-toml">[dependencies]
graph-api-lib = "0.1.4"
graph-api-derive = "0.1.2"  # For derive macros
graph-api-simplegraph = "0.1.4"
</code></pre>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p><code>SimpleGraph</code> is a custom in-memory graph implementation built specifically to demonstrate and validate all Graph API
features, including every type of index. It serves as a clear example for developers implementing the Graph API traits
and is invaluable for testing Graph API consumers against a fully compliant backend. It handles property graph use cases
where elements have labels (enum variants) and indexed properties.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use graph_api_simplegraph::SimpleGraph;
use graph_api_derive::{VertexExt, EdgeExt};
use graph_api_lib::Graph;

// Define vertex and edge types
#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    Person {
        #[index(hash)]
        name: String,
        #[index(range)]
        age: u64,
    },
    Project {
        name: String
    },
}

#[derive(Debug, Clone, EdgeExt)]
pub enum Edge {
    Knows { since: i32 },
    Created,
}

// Create a new graph
let mut graph = SimpleGraph::new();

// Use the graph
let alice = graph.add_vertex(Vertex::Person {
name: "Alice".to_string(),
age: 30
});
let project = graph.add_vertex(Vertex::Project {
name: "Graph API".to_string()
});
graph.add_edge(alice, project, Edge::Created);
<span class="boring">}</span></code></pre></pre>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p><code>SimpleGraph</code> uses a custom data structure designed specifically for property graphs:</p>
<ol>
<li>
<p><strong>Vertex Storage</strong>: Vertices are stored in collections grouped by label (enum variant), allowing for efficient
label-based filtering.</p>
</li>
<li>
<p><strong>Edge Storage</strong>: Edges are stored with both head and tail connections, enabling fast traversal in both directions.</p>
</li>
<li>
<p><strong>Indexes</strong>: Multiple index types are implemented to support different query patterns:</p>
<ul>
<li>Label indexes for finding vertices/edges by label</li>
<li>Hash indexes for exact property matching</li>
<li>Range indexes for numeric and string range queries</li>
<li>Full-text indexes for text search</li>
</ul>
</li>
<li>
<p><strong>Adjacency Lists</strong>: Each vertex maintains an adjacency list for fast edge traversal.</p>
</li>
</ol>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p><code>SimpleGraph</code> supports all Graph API features:</p>
<ul>
<li>âœ… Vertex label indexes</li>
<li>âœ… Edge label indexes</li>
<li>âœ… Vertex hash indexes</li>
<li>âŒ Edge hash indexes</li>
<li>âœ… Vertex range indexes</li>
<li>âŒ Edge range indexes</li>
<li>âœ… Vertex full-text indexes</li>
<li>âœ… Edge adjacent label indexes (this isn't fully supported in graph-api-lib yet)</li>
<li>âœ… Graph clearing</li>
</ul>
<h2 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h2>
<p><code>SimpleGraph</code> is primarily designed for feature completeness and ease of understanding, not for high performance:</p>
<ol>
<li><strong>Correctness over Speed</strong>: Implementation prioritizes demonstrating API features correctly.</li>
<li><strong>Basic Optimizations</strong>: Includes fundamental optimizations like adjacency lists but lacks advanced performance
tuning.</li>
</ol>
<h3 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h3>
<p>Benchmarks exist primarily to validate the <em>functionality</em> of the API features rather than to showcase raw speed.
Expect:</p>
<ul>
<li>Functional insertion and removal.</li>
<li>Correct index lookups (hash, range, full-text) but potentially slower than highly optimized alternatives.</li>
<li>Basic traversal efficiency.</li>
</ul>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p><code>SimpleGraph</code> is ideal for:</p>
<ul>
<li><strong>Testing</strong>: Verifying code that uses the Graph API against a fully compliant implementation.</li>
<li><strong>Reference</strong>: Understanding how to implement the Graph API traits and features.</li>
<li><strong>Learning</strong>: Exploring the capabilities of the Graph API in a controlled environment.</li>
<li><strong>Prototyping</strong>: Quickly building graph-based applications where performance is not the primary concern initially.</li>
</ul>
<h2 id="implementation-notes-1"><a class="header" href="#implementation-notes-1">Implementation Notes</a></h2>
<p><code>SimpleGraph</code> is implemented using several key components:</p>
<h3 id="core-data-structures"><a class="header" href="#core-data-structures">Core Data Structures</a></h3>
<ul>
<li><code>LabelledVertices</code>: Stores vertices by label, with efficient access by ID</li>
<li><code>LabelledEdges</code>: Stores edges by label</li>
<li><code>VertexStorage</code>: Maintains vertex data and adjacency information</li>
<li><code>VertexIndexStorage</code>: Handles different index types (hash, range, full-text)</li>
</ul>
<h3 id="indexes"><a class="header" href="#indexes">Indexes</a></h3>
<p><code>SimpleGraph</code> implements several index types:</p>
<ul>
<li><code>HashIndex</code>: Maps property values to sets of vertex/edge IDs</li>
<li><code>RangeIndex</code>: Uses ordered maps for range queries</li>
<li><code>FullTextIndex</code>: Implements inverted indexes for text search</li>
</ul>
<h3 id="mutation-handling"><a class="header" href="#mutation-handling">Mutation Handling</a></h3>
<p>To maintain index consistency, <code>SimpleGraph</code> uses a mutation listener system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When a vertex property changes, the index is automatically updated
graph.vertex_mut(vertex_id)
.unwrap()
.project_mut::&lt;PersonMut&lt;_ &gt; &gt; ()
.unwrap()
.set_name("New Name");
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<p>While <code>SimpleGraph</code> is a robust implementation, it has some limitations:</p>
<ul>
<li><strong>In-memory only</strong>: All graph data must fit in memory</li>
<li><strong>Single-threaded</strong>: No built-in support for concurrent access</li>
<li><strong>No persistence</strong>: No built-in support for saving/loading graphs</li>
</ul>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>The source code for <code>SimpleGraph</code> is available in
the <a href="https://github.com/BrynCooke/graph-api/tree/main/graph-api-simplegraph">graph-api-simplegraph</a> crate.</p>
<h2 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h2>
<p>Here's a complete example demonstrating key features of <code>SimpleGraph</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use graph_api_simplegraph::SimpleGraph;
use graph_api_derive::{VertexExt, EdgeExt};
use graph_api_lib::{Graph, VertexSearch, EdgeSearch, Direction};

// Define vertex and edge types
#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    Person {
        #[index(hash)]
        name: String,
        #[index(range)]
        age: u64,
        #[index(full_text)]
        bio: String,
    },
    Project {
        name: String
    },
}

#[derive(Debug, Clone, EdgeExt)]
pub enum Edge {
    Knows { since: i32 },
    Created,
}

// Create a new graph
let mut graph = SimpleGraph::new();

// Add vertices
let alice = graph.add_vertex(Vertex::Person {
name: "Alice".to_string(),
age: 30,
bio: "Graph enthusiast".to_string(),
});

let bob = graph.add_vertex(Vertex::Person {
name: "Bob".to_string(),
age: 25,
bio: "Software developer".to_string(),
});

let project = graph.add_vertex(Vertex::Project {
name: "Graph API".to_string()
});

// Add edges
graph.add_edge(alice, bob, Edge::Knows { since: 2020 });
graph.add_edge(alice, project, Edge::Created);
graph.add_edge(bob, project, Edge::Created);

// Query by label
let people = graph.walk()
.vertices(Vertex::person_all())
.collect::&lt;Vec&lt;_ &gt; &gt; ();
assert_eq!(people.len(), 2);

// Query by property (hash index)
let alice_found = graph.walk()
.vertices(Vertex::person_by_name("Alice"))
.collect::&lt;Vec&lt;_ &gt; &gt; ();
assert_eq!(alice_found.len(), 1);

// Query by range (range index)
let young_people = graph.walk()
.vertices(Vertex::person_by_age(20..30))
.collect::&lt;Vec&lt;_ &gt; &gt; ();
assert_eq!(young_people.len(), 1);

// Text search (full-text index)
let developers = graph.walk()
.vertices(Vertex::person_by_bio("developer"))
.collect::&lt;Vec&lt;_ &gt; &gt; ();
assert_eq!(developers.len(), 1);

// Traversal
let alices_creations = graph.walk()
.vertices(Vertex::person_by_name("Alice"))
.edges(Edge::created().direction(Direction::Outgoing))
.head()
.collect::&lt;Vec&lt;_ &gt; &gt; ();
assert_eq!(alices_creations.len(), 1);
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<p><code>SimpleGraph</code> supports several advanced features:</p>
<h3 id="custom-indexing"><a class="header" href="#custom-indexing">Custom Indexing</a></h3>
<p>You can define custom indexes on vertex and edge properties:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    Person {
        #[index(hash)]
        id: u64,
        #[index(range)]
        score: f64,
        #[index(full_text)]
        description: String,
    },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mutation-with-index-updates"><a class="header" href="#mutation-with-index-updates">Mutation with Index Updates</a></h3>
<p>When properties are modified, indexes are automatically updated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update an indexed property
graph.vertex_mut(vertex_id)
.unwrap()
.project_mut::&lt;PersonMut&lt;_ &gt; &gt; ()
.unwrap()
.set_age(31);

// The age index is automatically updated, so this query now works
let people = graph.walk()
.vertices(Vertex::person_by_age(31..32))
.collect::&lt;Vec&lt;_ &gt; &gt; ();
assert_eq!(people.len(), 1);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="petgraph-adapter"><a class="header" href="#petgraph-adapter">PetGraph Adapter</a></h1>
<p>The <code>PetGraph</code> adapter provides Graph API compatibility for the excellent and
widely-used <a href="https://crates.io/crates/petgraph">petgraph</a> Rust graph library. This allows projects using <code>petgraph</code> to
benefit from the Graph API's ergonomic query interface while retaining <code>petgraph</code>'s robust performance, extensive
algorithm suite, and maturity.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>Add PetGraph support to your project dependencies:</p>
<pre><code class="language-toml">[dependencies]
graph-api-lib = "0.1.4"
graph-api-derive = "0.1.2"  # For derive macros
graph-api-petgraph = "0.1.4"  # Graph API adapter for petgraph
petgraph = "0.6"  # The underlying graph library
</code></pre>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>This adapter wraps <code>petgraph::stable_graph::StableGraph</code>, enabling it to be used seamlessly with Graph API traits and
walkers. It acts as a bridge, translating Graph API calls into <code>petgraph</code> operations. Note that it primarily exposes
<code>petgraph</code>'s core graph structure and does <em>not</em> add the advanced indexing features found in <code>SimpleGraph</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use petgraph::stable_graph::StableGraph;
use graph_api_derive::{VertexExt, EdgeExt};
use graph_api_lib::Graph;

// Define vertex and edge types
#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    Person {
        name: String,
        age: u64,
    },
    Project {
        name: String
    },
}

#[derive(Debug, Clone, EdgeExt)]
pub enum Edge {
    Knows { since: i32 },
    Created,
}

// Create a new petgraph StableGraph (which implements Graph)
let mut graph = StableGraph::new();

// Use the graph through the Graph API
let alice = graph.add_vertex(Vertex::Person {
name: "Alice".to_string(),
age: 30
});
let project = graph.add_vertex(Vertex::Project {
name: "Graph API".to_string()
});
graph.add_edge(alice, project, Edge::Created);
<span class="boring">}</span></code></pre></pre>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>The PetGraph adapter:</p>
<ol>
<li><strong>Maps Graph API concepts to petgraph</strong>: Translates between Graph API's model and petgraph's model</li>
<li><strong>Provides wrapper types</strong>: Wraps petgraph references to implement Graph API reference traits</li>
<li><strong>Adapts traversal patterns</strong>: Adapts petgraph's traversal methods to match Graph API expectations</li>
</ol>
<h2 id="features-1"><a class="header" href="#features-1">Features</a></h2>
<p><code>PetGraph</code> supports a subset of Graph API features:</p>
<ul>
<li>âŒ Vertex label indexes</li>
<li>âŒ Edge label indexes</li>
<li>âŒ Vertex hash indexes</li>
<li>âŒ Edge hash indexes</li>
<li>âŒ Vertex range indexes</li>
<li>âŒ Edge range indexes</li>
<li>âŒ Vertex full-text indexes</li>
<li>âŒ Edge adjacent label indexes</li>
<li>âœ… Graph clearing</li>
</ul>
<h2 id="petgraph-integration"><a class="header" href="#petgraph-integration">Petgraph Integration</a></h2>
<p>The primary advantage of <code>PetGraph</code> is access to petgraph's rich ecosystem:</p>
<h3 id="graph-algorithms"><a class="header" href="#graph-algorithms">Graph Algorithms</a></h3>
<p>Petgraph provides many graph algorithms that can be used alongside Graph API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use petgraph::algo::dijkstra;
use petgraph::stable_graph::StableGraph;
use graph_api_lib::Graph;

// Create and populate graph using Graph API
let mut graph = StableGraph::new();
let a = graph.add_vertex(Vertex::Person { name: "A".to_string(), age: 30 });
let b = graph.add_vertex(Vertex::Person { name: "B".to_string(), age: 25 });
let c = graph.add_vertex(Vertex::Person { name: "C".to_string(), age: 40 });

graph.add_edge(a, b, Edge::Knows { since: 2010 });
graph.add_edge(b, c, Edge::Knows { since: 2015 });
graph.add_edge(a, c, Edge::Knows { since: 2020 });

// Use petgraph algorithms directly on the same graph
let path = dijkstra( &amp; graph, a, Some(c), | _ | 1);
<span class="boring">}</span></code></pre></pre>
<h3 id="visualization"><a class="header" href="#visualization">Visualization</a></h3>
<p>Petgraph supports graph visualization with Graphviz:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use petgraph::dot::{Dot, Config};

// Create and populate graph using Graph API
let mut graph = StableGraph::new();
// ... add vertices and edges ...

// Use petgraph's Dot export
println!("{:?}", Dot::with_config(&amp;graph, &amp;[Config::EdgeNoLabel]));
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics-2"><a class="header" href="#performance-characteristics-2">Performance Characteristics</a></h2>
<p><code>PetGraph</code> inherits performance characteristics from petgraph:</p>
<ol>
<li><strong>Efficient traversal</strong>: Petgraph's adjacency list representation enables fast traversal</li>
<li><strong>Fast mutations</strong>: Quick addition and removal of vertices and edges</li>
<li><strong>Algorithm optimizations</strong>: Petgraph's algorithms are optimized for performance</li>
</ol>
<p>However, <code>PetGraph</code> lacks indexing support, which means:</p>
<ul>
<li>All label-based searches require full scans</li>
<li>Property-based lookups require iterating through all vertices/edges</li>
</ul>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<p>The <code>PetGraph</code> adapter is an excellent choice when:</p>
<ul>
<li><strong>Performance is critical</strong>: Leverage <code>petgraph</code>'s optimized data structures and algorithms.</li>
<li><strong>Integrating with existing <code>petgraph</code> code</strong>: Use the Graph API interface on existing <code>petgraph</code> graphs.</li>
<li><strong>Needing advanced graph algorithms</strong>: Access <code>petgraph</code>'s rich library of algorithms directly.</li>
<li><strong>Working with simpler graph structures</strong>: When the advanced indexing features of <code>SimpleGraph</code> are not required.</li>
<li><strong>Building production systems</strong>: Benefit from <code>petgraph</code>'s maturity and widespread use.</li>
</ul>
<h2 id="implementation-notes-2"><a class="header" href="#implementation-notes-2">Implementation Notes</a></h2>
<p>The <code>PetGraph</code> adapter consists of several wrapper types:</p>
<ul>
<li><code>VertexReferenceWrapper</code>: Wraps petgraph node references</li>
<li><code>VertexReferenceWrapperMut</code>: Wraps mutable petgraph node references</li>
<li><code>EdgeReferenceWrapper</code>: Wraps petgraph edge references</li>
<li><code>EdgeReferenceWrapperMut</code>: Wraps mutable petgraph edge references</li>
<li><code>VertexIter</code>: Adapts petgraph's vertex iteration</li>
<li><code>EdgeIter</code>: Adapts petgraph's edge iteration</li>
</ul>
<p>These wrappers implement the corresponding Graph API traits to provide compatibility.</p>
<h2 id="limitations-2"><a class="header" href="#limitations-2">Limitations</a></h2>
<p>When using <code>PetGraph</code>, be aware of these limitations:</p>
<ol>
<li><strong>No indexing support</strong>: All lookups by label or property require full scans</li>
<li><strong>Limited filtering</strong>: Edge and vertex filtering must be done after retrieval</li>
<li><strong>Compatibility gaps</strong>: Some petgraph features may not map directly to Graph API concepts</li>
</ol>
<h2 id="source-code-1"><a class="header" href="#source-code-1">Source Code</a></h2>
<p>The source code for the <code>PetGraph</code> adapter is available in
the <a href="https://github.com/BrynCooke/graph-api/tree/main/graph-api-lib/src/petgraph">graph-api-lib</a> crate under the
<code>petgraph</code> module.</p>
<h2 id="example-usage-1"><a class="header" href="#example-usage-1">Example Usage</a></h2>
<p>Here's an example demonstrating <code>PetGraph</code> usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use petgraph::stable_graph::StableGraph;
use graph_api_derive::{VertexExt, EdgeExt};
use graph_api_lib::{Graph, VertexSearch, EdgeSearch, Direction};

// Define vertex and edge types
#[derive(Debug, Clone, VertexExt)]
pub enum Vertex {
    Person {
        name: String,
        age: u64,
    },
    Project {
        name: String
    },
}

#[derive(Debug, Clone, EdgeExt)]
pub enum Edge {
    Knows { since: i32 },
    Created,
}

// Create a new graph
let mut graph = StableGraph::new();

// Add vertices
let alice = graph.add_vertex(Vertex::Person {
name: "Alice".to_string(),
age: 30,
});

let bob = graph.add_vertex(Vertex::Person {
name: "Bob".to_string(),
age: 25,
});

let project = graph.add_vertex(Vertex::Project {
name: "Graph API".to_string()
});

// Add edges
graph.add_edge(alice, bob, Edge::Knows { since: 2020 });
graph.add_edge(alice, project, Edge::Created);
graph.add_edge(bob, project, Edge::Created);

// Basic traversal (without indexing)
let all_vertices = graph.walk()
.vertices(VertexSearch::scan())
.collect::&lt;Vec&lt;_ &gt; &gt; ();
assert_eq!(all_vertices.len(), 3);

// Find all people (manual filtering since indexing isn't supported)
let people = graph.walk()
.vertices(VertexSearch::scan())
.filter_by_person( | _, _ | true)
.collect::&lt;Vec&lt;_ &gt; &gt; ();
assert_eq!(people.len(), 2);

// Find projects connected to Alice
let alices_projects = graph.walk()
.vertices_by_id(vec![alice])
.edges(EdgeSearch::scan())
.filter_by_created( | _, _ | true)
.head()
.collect::&lt;Vec&lt;_ &gt; &gt; ();
assert_eq!(alices_projects.len(), 1);
<span class="boring">}</span></code></pre></pre>
<h2 id="integrating-with-petgraph-algorithms"><a class="header" href="#integrating-with-petgraph-algorithms">Integrating with Petgraph Algorithms</a></h2>
<p>One of the main advantages of using <code>PetGraph</code> is access to petgraph's algorithms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use petgraph::stable_graph::StableGraph;
use petgraph::algo::{dijkstra, is_cyclic_directed};
use graph_api_lib::Graph;

// Create and populate graph using Graph API
let mut graph = StableGraph::new();
let a = graph.add_vertex(Vertex::Person { name: "A".to_string(), age: 30 });
let b = graph.add_vertex(Vertex::Person { name: "B".to_string(), age: 25 });
let c = graph.add_vertex(Vertex::Person { name: "C".to_string(), age: 40 });

graph.add_edge(a, b, Edge::Knows { since: 2010 });
graph.add_edge(b, c, Edge::Knows { since: 2015 });

// Use petgraph algorithms
let distances = dijkstra( &amp; graph, a, None, | _ | 1);
assert_eq!(distances[&amp;c], 2); // Distance from A to C is 2

let is_cyclic = is_cyclic_directed( &amp; graph);
assert_eq!(is_cyclic, false);

// Add an edge to create a cycle
graph.add_edge(c, a, Edge::Knows { since: 2020 });
let is_cyclic = is_cyclic_directed( &amp; graph);
assert_eq!(is_cyclic, true);
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-choose-petgraph"><a class="header" href="#when-to-choose-petgraph">When to Choose PetGraph</a></h2>
<p>Consider using <code>PetGraph</code> when:</p>
<ol>
<li>You're already using petgraph in your project</li>
<li>You need access to petgraph's graph algorithms</li>
<li>You want to use the Graph API's ergonomic interface</li>
<li>You don't need indexing features</li>
</ol>
<p>If you require index-based lookups or other advanced Graph API features, consider using <code>SimpleGraph</code> instead.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
