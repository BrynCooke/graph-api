#!/usr/bin/env python3
import json
import os
import re
import sys

def extract_function(file_path, function_name):
    """Extract a specific function from a Rust file."""
    try:
        with open(file_path, 'r') as f:
            content = f.read()

        # Pattern to match function declarations and their body
        # We look for fn function_name(...) { ... }
        pattern = re.compile(
            r'fn\s+' + re.escape(function_name) + r'\s*\([^)]*\)(?:\s*->\s*[^{]*)?{((?:[^{}]|{(?:[^{}]|{(?:[^{}]|{[^{}]*})*})*})*)}',
            re.DOTALL
        )

        match = pattern.search(content)
        if match:
            # Return the full function definition
            start_idx = match.start()
            # Find the start of the line containing the function
            line_start = content.rfind('\n', 0, start_idx) + 1
            return content[line_start:match.end()]

        return None
    except Exception as e:
        print(f"Error extracting function: {str(e)}", file=sys.stderr)
        return None

def process_markdown_content(content, book_dir):
    """Process markdown content, replacing include directives with code."""

    # Pattern to match include directives like: {% include_fn path/to/file.rs:function_name %}
    pattern = re.compile(r'{%\s*include_fn\s+([^:]+):([^\s%]+)\s*%}')

    def replace_include(match):
        rust_file = match.group(1).strip()
        function_name = match.group(2).strip()

        # Handle relative paths - assuming relative to book directory
        if not os.path.isabs(rust_file):
            rust_file = os.path.normpath(os.path.join(book_dir, rust_file))

        # Check if file exists
        if not os.path.isfile(rust_file):
            return f"```rust\n// ERROR: File not found: {rust_file}\n```"

        # Extract the function
        code = extract_function(rust_file, function_name)
        if not code:
            return f"```rust\n// ERROR: Function '{function_name}' not found in {rust_file}\n```"

        # Format as a code block
        return f"```rust\n{code}\n```"

    # Replace all include directives
    return pattern.sub(replace_include, content)

def main():
    # Add some debug output to a file
    with open("/tmp/mdbook-include-fn.log", "a") as log:
        log.write(f"Args: {sys.argv}\n")

    # If 'supports' command, return success
    if len(sys.argv) > 1 and sys.argv[1] == 'supports':
        sys.exit(0)
    
    # Create a minimal valid response
    minimal_response = {
        "root": "/Users/bryn/git/graph-api/graph-api-book",
        "sections": [],
        "__non_exhaustive": None
    }
    
    # For 'preprocessor' command or any other command
    try:
        # First, try to read from stdin
        stdin_data = sys.stdin.read()
        with open("/tmp/mdbook-include-fn-stdin.log", "w") as log:
            log.write(f"Stdin: {stdin_data}\n")

        # If stdin data is empty, return a minimal valid response
        if not stdin_data.strip():
            json.dump(minimal_response, sys.stdout)
            sys.exit(0)

        # Parse the context
        context = json.loads(stdin_data)
        
        # Get the book directory
        book_dir = context.get("root", ".")
        
        # Make sure sections exists
        if "sections" not in context:
            context["sections"] = []
            
        # Make sure __non_exhaustive exists
        if "__non_exhaustive" not in context:
            context["__non_exhaustive"] = None
            
        # Process each chapter
        for section in context.get("sections", []):
            if "Chapter" in section:
                chapter = section["Chapter"]
                # Process the content of the chapter
                content = chapter.get("content", "")
                chapter["content"] = process_markdown_content(content, book_dir)

            # Also handle part intros
            if "PartTitle" in section:
                part = section["PartTitle"]
                content = part.get("content", "")
                part["content"] = process_markdown_content(content, book_dir)

        # Output the modified context
        json.dump(context, sys.stdout)
    except Exception as e:
        with open("/tmp/mdbook-include-fn-error.log", "w") as log:
            log.write(f"Error: {str(e)}\n")
        # Return minimal valid response on error
        json.dump(minimal_response, sys.stdout)
        
    # Always exit successfully
    sys.exit(0)

if __name__ == "__main__":
    main()