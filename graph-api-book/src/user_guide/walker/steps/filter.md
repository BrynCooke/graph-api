# Filter Step

The `filter` step narrows a traversal by keeping only vertices or edges that match a specified predicate.

```pikchr
# Before filter - all vertices 
A: box rad 10px "A" "age=35" fit
B: box rad 10px at 1.5 right of A "B" "age=25" fit
C: box rad 10px at 1.5 right of B "C" "age=40" fit

# Connect vertices with edges
line from A.e to B.w
line from B.e to C.w

text at 0.4 below B "Before step: All vertices in traversal"

# After filter - highlight only those matching age > 30
Aprime: box rad 10px at 1 below A "A" "age=35" fit fill lightgreen
Bprime: box rad 10px at 1.5 right of Aprime "B" "age=25" fit color gray
Cprime: box rad 10px at 1.5 right of Bprime "C" "age=40" fit fill lightgreen

# Connect vertices with edges (grayed out for non-matching)
line from Aprime.e to Bprime.w color gray
line from Bprime.e to Cprime.w color gray

text at 0.4 below Bprime "After step (filter where age > 30): Only A and C match"
```

## Syntax

```rust,noplayground
walker.filter(|element, context| /* predicate logic */)
```

## Parameters

- `predicate`: A function that takes a reference to a graph element and optional context, and returns a boolean.
    - Returns `true` to keep the element in the traversal
    - Returns `false` to remove it from the traversal

## Return Value

Returns a new walker containing only the elements that match the predicate.

## Examples

### Basic Filter

Filter vertices based on a simple condition:

```rust,noplayground
{{#include filter/filter_examples.rs:basic_filter}}
```

### Type-Specific Filtering

Use the type-specific filter methods generated by derive macros:

```rust,noplayground
{{#include filter/filter_examples.rs:type_specific_filter}}
```

### Chained Filters

Combine multiple filters for complex queries:

```rust,noplayground
{{#include filter/filter_examples.rs:chained_filters}}
```

### Filter with Context

Filter based on context information:

```rust,noplayground
{{#include filter/filter_examples.rs:context_filter}}
```

## Notes

- The filter step does not modify the graph, only the traversal
- Filtering is lazy - predicates are only evaluated when traversal elements are accessed
- For complex filtering conditions:
    - Chain multiple filter steps for better readability
    - Use pattern matching for different vertex/edge types
- The filter predicate has access to the current element and context
- When possible, consider using indexed searches (like `VertexSearch` with properties) instead of filtering after
  retrieval
- Type-specific filter methods (like `filter_by_person`) provide better type safety and code completion