# Filter Step

The `filter` step narrows a traversal by keeping only vertices or edges that match a specified predicate.

<object type="image/svg+xml" data="filter/image.svg" title="Filter Step Diagram">
Filter step diagram showing elements being kept or discarded based on a predicate
</object>

In this diagram:

- **Before `filter()`**: The walker contains highlighted vertices **A** (age=35), **B** (age=25), and **C** (age=40).
- The **`.filter(|v| v.age > 30)`** step is applied.
- **After `filter()`**: Only vertices **A** and **C** remain highlighted, as their age is greater than 30. Vertex **B** is faded and marked with an 'X' to indicate it was removed by the filter.

## Syntax

```rust,noplayground
walker.filter(|element, context| /* predicate logic */)
```

## Parameters

- `predicate`: A function that takes a reference to a graph element and optional context, and returns a boolean.
    - Returns `true` to keep the element in the traversal
    - Returns `false` to remove it from the traversal

## Return Value

Returns a new walker containing only the elements that match the predicate.

## Examples

### Basic Filter

Filter vertices based on a simple condition:

```rust,noplayground
{{#include filter/filter_examples.rs:basic_filter}}
```

### Type-Specific Filtering

Use the type-specific filter methods generated by derive macros:

```rust,noplayground
{{#include filter/filter_examples.rs:type_specific_filter}}
```

### Chained Filters

Combine multiple filters for complex queries:

```rust,noplayground
{{#include filter/filter_examples.rs:chained_filters}}
```

### Filter with Context

Filter based on context information:

```rust,noplayground
{{#include filter/filter_examples.rs:context_filter}}
```

## Best Practices

- Prefer indexed searches over filter steps when querying by property values
- Break complex filtering logic into multiple chained filters for readability
- Use pattern matching to handle different vertex or edge types correctly
- Leverage generated filter methods from derive macros for stronger type safety

## Common Use Cases

- **Post-retrieval refinement**: Filtering elements after initial selection when indexes don't fully cover criteria
- **Dynamic filtering**: Applying runtime conditions that can't be encoded in initial searches
- **Complex conditions**: Implementing filtering logic that combines multiple properties or calculations
- **Context-aware filtering**: Using information from previous traversal steps to inform filtering decisions
