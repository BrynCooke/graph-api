# Filter Step

The `filter` step narrows a traversal by keeping only vertices or edges that match a specified predicate.

## Syntax

```rust,noplayground
walker.filter(|element, context| /* predicate logic */)
```

## Parameters

- `predicate`: A function that takes a reference to a graph element and optional context, and returns a boolean.
    - Returns `true` to keep the element in the traversal
    - Returns `false` to remove it from the traversal

## Return Value

Returns a new walker containing only the elements that match the predicate.

## Diagram

```bob
Before step:
  [A(age=35)]* --- [B(age=25)]* --- [C(age=40)]*
  Position: All vertices in traversal

After step (filter where age > 30):
  [A(age=35)]* --- [B(age=25)] --- [C(age=40)]*
  Position: Only vertices matching predicate
```

## Examples

### Basic Filter

Filter vertices based on a simple condition:

```rust,noplayground
{{#include filter/filter_examples.rs:basic_filter}}
```

### Type-Specific Filtering

Use the type-specific filter methods generated by derive macros:

```rust,noplayground
{{#include filter/filter_examples.rs:type_specific_filter}}
```

### Chained Filters

Combine multiple filters for complex queries:

```rust,noplayground
{{#include filter/filter_examples.rs:chained_filters}}
```

### Filter with Context

Filter based on context information:

```rust,noplayground
{{#include filter/filter_examples.rs:context_filter}}
```

## Notes

- The filter step does not modify the graph, only the traversal
- Filtering is lazy - predicates are only evaluated when traversal elements are accessed
- For complex filtering conditions:
    - Chain multiple filter steps for better readability
    - Use pattern matching for different vertex/edge types
- The filter predicate has access to the current element and context
- When possible, consider using indexed searches (like `VertexSearch` with properties) instead of filtering after
  retrieval
- Type-specific filter methods (like `filter_by_person`) provide better type safety and code completion