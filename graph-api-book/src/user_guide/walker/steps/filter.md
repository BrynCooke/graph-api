# Filter Step

The `filter` step narrows a traversal by keeping only vertices or edges that match a specified predicate.

<object type="image/svg+xml" data="filter/image.svg" width="650" height="300">
Filter step diagram showing how vertices are filtered based on a condition
</object>

## Syntax

```rust,noplayground
walker.filter(|element, context| /* predicate logic */)
```

## Parameters

- `predicate`: A function that takes a reference to a graph element and optional context, and returns a boolean.
    - Returns `true` to keep the element in the traversal
    - Returns `false` to remove it from the traversal

## Return Value

Returns a new walker containing only the elements that match the predicate.

## Examples

### Basic Filter

Filter vertices based on a simple condition:

```rust,noplayground
{{#include filter/filter_examples.rs:basic_filter}}
```

### Type-Specific Filtering

Use the type-specific filter methods generated by derive macros:

```rust,noplayground
{{#include filter/filter_examples.rs:type_specific_filter}}
```

### Chained Filters

Combine multiple filters for complex queries:

```rust,noplayground
{{#include filter/filter_examples.rs:chained_filters}}
```

### Filter with Context

Filter based on context information:

```rust,noplayground
{{#include filter/filter_examples.rs:context_filter}}
```

## Best Practices

- Prefer indexed searches over filter steps when querying by property values
- Break complex filtering logic into multiple chained filters for readability
- Use pattern matching to handle different vertex or edge types correctly
- Leverage generated filter methods from derive macros for stronger type safety

## Common Use Cases

- **Post-retrieval refinement**: Filtering elements after initial selection when indexes don't fully cover criteria
- **Dynamic filtering**: Applying runtime conditions that can't be encoded in initial searches
- **Complex conditions**: Implementing filtering logic that combines multiple properties or calculations
- **Context-aware filtering**: Using information from previous traversal steps to inform filtering decisions